<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/neumino/rethinkdbdash#readme">rethinkdbdash (v2.3.28)</a>
</h1>
<h4>A Node.js driver for RethinkDB with promises and a connection pool</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash">module rethinkdbdash</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.rethinkdbdash">
            function <span class="apidocSignatureSpan"></span>rethinkdbdash
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>connection
            <span class="apidocSignatureSpan">(r, options, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>cursor
            <span class="apidocSignatureSpan">(connection, token, options, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>dequeue
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>metadata
            <span class="apidocSignatureSpan">(resolve, reject, query, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool
            <span class="apidocSignatureSpan">(r, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool_master
            <span class="apidocSignatureSpan">(r, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>stream
            <span class="apidocSignatureSpan">(options, cursor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>term
            <span class="apidocSignatureSpan">(r, value, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>transform_stream
            <span class="apidocSignatureSpan">(table, options, connection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.writable_stream">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>writable_stream
            <span class="apidocSignatureSpan">(table, options, connection)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>connection.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>cursor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>dequeue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>error</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>helper</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>metadata.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>pool.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>pool_master.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>stream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>term.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>transform_stream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>writable_stream.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.connection">module rethinkdbdash.connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.connection">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>connection
            <span class="apidocSignatureSpan">(r, options, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.super_">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.connection.prototype">module rethinkdbdash.connection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._abort">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._checkProtocolVersion">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_checkProtocolVersion
            <span class="apidocSignatureSpan">(messageServer, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._compareDigest">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_compareDigest
            <span class="apidocSignatureSpan">(messageServer, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._computeSaltedPassword">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_computeSaltedPassword
            <span class="apidocSignatureSpan">(messageServer, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._continue">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_continue
            <span class="apidocSignatureSpan">(token, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._end">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_end
            <span class="apidocSignatureSpan">(token, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._flush">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._getToken">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_getToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._isConnection">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_isConnection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._isOpen">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_isOpen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._processResponse">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_processResponse
            <span class="apidocSignatureSpan">(response, token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._send">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_send
            <span class="apidocSignatureSpan">(query, token, resolve, reject, originalQuery, options, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._sendProof">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_sendProof
            <span class="apidocSignatureSpan">(authentication, randomNonce, saltedPassword)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype.close">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>close
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype.noReplyWait">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>noReplyWait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype.noreplyWait">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>noreplyWait
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype.reconnect">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>reconnect
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype.server">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>server
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype.use">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>use
            <span class="apidocSignatureSpan">(db)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.cursor">module rethinkdbdash.cursor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.cursor">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>cursor
            <span class="apidocSignatureSpan">(connection, token, options, type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.cursor.prototype">module rethinkdbdash.cursor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._done">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_done
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._each">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_each
            <span class="apidocSignatureSpan">(callback, onFinish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._eachAsync">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_eachAsync
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._eachAsyncInternal">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_eachAsyncInternal
            <span class="apidocSignatureSpan">(callback, finalResolve, finalReject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._eachCb">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_eachCb
            <span class="apidocSignatureSpan">(err, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._fetch">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._flush">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._makeEmitter">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_makeEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._next">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_next
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._push">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_push
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._pushError">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_pushError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._set">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_set
            <span class="apidocSignatureSpan">(ar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._unsupportedToArray">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_unsupportedToArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.addListener">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.close">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.each">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>each
            <span class="apidocSignatureSpan">(callback, onFinish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.eachAsync">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>eachAsync
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.emit">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.getType">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>getType
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.hasNext">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>hasNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.includesStates">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>includesStates
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.listeners">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.next">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>next
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.on">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.once">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.removeListener">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.setIncludesStates">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>setIncludesStates
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.toArray">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>toArray
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.toJSON">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.toString">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.dequeue">module rethinkdbdash.dequeue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.dequeue">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>dequeue
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.dequeue.prototype">module rethinkdbdash.dequeue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.delete">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>delete
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.get">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>get
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.getLength">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>getLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.pop">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>pop
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.push">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>push
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.shift">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>shift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.toArray">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>toArray
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.unshift">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>unshift
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.error">module rethinkdbdash.error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.ReqlClientError">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlClientError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.ReqlCompileError">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlCompileError
            <span class="apidocSignatureSpan">(message, query, frames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.ReqlDriverError">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlDriverError
            <span class="apidocSignatureSpan">(message, query, secondMessage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.ReqlRuntimeError">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlRuntimeError
            <span class="apidocSignatureSpan">(message, query, frames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.ReqlServerError">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlServerError
            <span class="apidocSignatureSpan">(message, query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.generateBacktrace">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>generateBacktrace
            <span class="apidocSignatureSpan">(term, index, father, frames, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.setOperational">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>setOperational
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.helper">module rethinkdbdash.helper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.changeProto">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>changeProto
            <span class="apidocSignatureSpan">(object, other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.compareDigest">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>compareDigest
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.createLogger">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>createLogger
            <span class="apidocSignatureSpan">(poolMaster, silent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.getCanonicalAddress">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>getCanonicalAddress
            <span class="apidocSignatureSpan">(addresses)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.hasImplicit">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>hasImplicit
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.isPlainObject">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>isPlainObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.loopKeys">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>loopKeys
            <span class="apidocSignatureSpan">(obj, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.makeAtom">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>makeAtom
            <span class="apidocSignatureSpan">(response, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.makeSequence">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>makeSequence
            <span class="apidocSignatureSpan">(response, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.splitCommaEqual">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>splitCommaEqual
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.toArray">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>toArray
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.tryCatch">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>tryCatch
            <span class="apidocSignatureSpan">(toTry, handleError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.xorBuffer">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>xorBuffer
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>localhostAliases</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.metadata">module rethinkdbdash.metadata</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata.metadata">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>metadata
            <span class="apidocSignatureSpan">(resolve, reject, query, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.metadata.prototype">module rethinkdbdash.metadata.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata.prototype.removeCallbacks">
            function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>removeCallbacks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata.prototype.removeEndCallbacks">
            function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>removeEndCallbacks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata.prototype.setCallbacks">
            function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>setCallbacks
            <span class="apidocSignatureSpan">(resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata.prototype.setCursor">
            function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>setCursor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata.prototype.setEnd">
            function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>setEnd
            <span class="apidocSignatureSpan">(resolve, reject)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.pool">module rethinkdbdash.pool</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.pool">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool
            <span class="apidocSignatureSpan">(r, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.super_">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.pool.prototype">module rethinkdbdash.pool.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype._aggressivelyExpandBuffer">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_aggressivelyExpandBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype._decreaseNumConnections">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_decreaseNumConnections
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype._expandBuffer">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_expandBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype._increaseNumConnections">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_increaseNumConnections
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.createConnection">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>createConnection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.drain">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>drain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.drainLocalhost">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>drainLocalhost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.getAddress">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getAddress
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.getAvailableLength">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getAvailableLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.getConnection">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getConnection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.getLength">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.putConnection">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>putConnection
            <span class="apidocSignatureSpan">(connection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.setOptions">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>setOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.pool_master">module rethinkdbdash.pool_master</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.pool_master">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool_master
            <span class="apidocSignatureSpan">(r, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.super_">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.pool_master.prototype">module rethinkdbdash.pool_master.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype._expandAll">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>_expandAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype._flushErrors">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>_flushErrors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.createPool">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>createPool
            <span class="apidocSignatureSpan">(server)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.createPoolSettings">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>createPoolSettings
            <span class="apidocSignatureSpan">(globalOptions, serverOptions, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.deletePool">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>deletePool
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.drain">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>drain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.emitStatus">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>emitStatus
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.fetchServers">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>fetchServers
            <span class="apidocSignatureSpan">(useSeeds)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.getAvailableLength">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getAvailableLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.getConnection">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getConnection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.getLength">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.getNumAvailableConnections">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getNumAvailableConnections
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.getNumConnections">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getNumConnections
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.getPools">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getPools
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.handleAllServersResponse">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>handleAllServersResponse
            <span class="apidocSignatureSpan">(servers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.initPool">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>initPool
            <span class="apidocSignatureSpan">(pool)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.resetBufferParameters">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>resetBufferParameters
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.stream">module rethinkdbdash.stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.stream">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>stream
            <span class="apidocSignatureSpan">(options, cursor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.super_">
            function <span class="apidocSignatureSpan">rethinkdbdash.stream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.stream.prototype">module rethinkdbdash.stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.prototype._fetch">
            function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.prototype._fetchAndDecrement">
            function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_fetchAndDecrement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.prototype._read">
            function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_read
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.prototype._setCursor">
            function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_setCursor
            <span class="apidocSignatureSpan">(cursor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.prototype.close">
            function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.term">module rethinkdbdash.term</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.term">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>term
            <span class="apidocSignatureSpan">(r, value, error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.term.prototype">module rethinkdbdash.term.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.ISO8601">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ISO8601
            <span class="apidocSignatureSpan">(isoTime, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._arity">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_arity
            <span class="apidocSignatureSpan">(args, num, method, term)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._arityRange">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_arityRange
            <span class="apidocSignatureSpan">(args, min, max, method, term)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._fastArity">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_fastArity
            <span class="apidocSignatureSpan">(len, num)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._fastArityRange">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_fastArityRange
            <span class="apidocSignatureSpan">(len, min, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._fillArgs">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_fillArgs
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._noPrefix">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_noPrefix
            <span class="apidocSignatureSpan">(term, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._setArrayLimit">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_setArrayLimit
            <span class="apidocSignatureSpan">(arrayLimit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._setNestingLevel">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_setNestingLevel
            <span class="apidocSignatureSpan">(nestingLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._toReadableStream">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_toReadableStream
            <span class="apidocSignatureSpan">(connection, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._toTransformStream">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_toTransformStream
            <span class="apidocSignatureSpan">(connection, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._toWritableStream">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_toWritableStream
            <span class="apidocSignatureSpan">(connection, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._wrap">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_wrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.add">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>add
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.and">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>and
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.append">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>append
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.april">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>april
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.args">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>args
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.asc">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>asc
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.august">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>august
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.avg">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>avg
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.between">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>between
            <span class="apidocSignatureSpan">(start, end, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.binary">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>binary
            <span class="apidocSignatureSpan">(bin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.bracket">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>bracket
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.branch">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>branch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.catch">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>catch
            <span class="apidocSignatureSpan">(reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.ceil">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ceil
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.changeAt">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>changeAt
            <span class="apidocSignatureSpan">(index, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.changes">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>changes
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.circle">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>circle
            <span class="apidocSignatureSpan">(center, radius, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.coerceTo">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>coerceTo
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.concatMap">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>concatMap
            <span class="apidocSignatureSpan">(transformation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.config">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>config
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.contains">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>contains
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.count">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>count
            <span class="apidocSignatureSpan">(filter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.date">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>date
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.day">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>day
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.dayOfWeek">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dayOfWeek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.dayOfYear">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dayOfYear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.db">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>db
            <span class="apidocSignatureSpan">(db)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.dbCreate">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dbCreate
            <span class="apidocSignatureSpan">(db)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.dbDrop">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dbDrop
            <span class="apidocSignatureSpan">(db)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.dbList">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dbList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.december">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>december
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.default">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>default
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.delay">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>delay
            <span class="apidocSignatureSpan">(msecs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.delete">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>delete
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.deleteAt">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>deleteAt
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.desc">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>desc
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.difference">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>difference
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.distance">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>distance
            <span class="apidocSignatureSpan">(geometry, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.distinct">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>distinct
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.div">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>div
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.do">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>do
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.downcase">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>downcase
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.during">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>during
            <span class="apidocSignatureSpan">(left, right, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.epochTime">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>epochTime
            <span class="apidocSignatureSpan">(epochTime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.eq">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>eq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.eqJoin">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>eqJoin
            <span class="apidocSignatureSpan">(rightKey, sequence, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.error">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>error
            <span class="apidocSignatureSpan">(reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.expr">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>expr
            <span class="apidocSignatureSpan">(expression, nestingLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.february">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>february
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.fill">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>fill
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.filter">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>filter
            <span class="apidocSignatureSpan">(filter, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.finally">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>finally
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.floor">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>floor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.fold">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>fold
            <span class="apidocSignatureSpan">(base, func, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.forEach">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>forEach
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.friday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>friday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.ge">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ge
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.geojson">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>geojson
            <span class="apidocSignatureSpan">(geometry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.get">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>get
            <span class="apidocSignatureSpan">(primaryKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.getAll">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.getField">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getField
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.getIntersecting">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getIntersecting
            <span class="apidocSignatureSpan">(geometry, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.getNearest">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getNearest
            <span class="apidocSignatureSpan">(geometry, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.grant">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>grant
            <span class="apidocSignatureSpan">(name, access)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.group">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>group
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.gt">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>gt
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.hasFields">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>hasFields
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.hours">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>hours
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.http">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>http
            <span class="apidocSignatureSpan">(url, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.inTimezone">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>inTimezone
            <span class="apidocSignatureSpan">(timezone)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.includes">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>includes
            <span class="apidocSignatureSpan">(geometry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexCreate">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexCreate
            <span class="apidocSignatureSpan">(name, fn, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexDrop">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexDrop
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexList">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexRename">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexRename
            <span class="apidocSignatureSpan">(oldName, newName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexStatus">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexStatus
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexWait">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexWait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexesOf">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexesOf
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.info">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>info
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.innerJoin">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>innerJoin
            <span class="apidocSignatureSpan">(sequence, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.insert">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>insert
            <span class="apidocSignatureSpan">(documents, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.insertAt">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>insertAt
            <span class="apidocSignatureSpan">(index, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.intersects">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>intersects
            <span class="apidocSignatureSpan">(geometry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.isEmpty">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.january">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>january
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.js">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>js
            <span class="apidocSignatureSpan">(arg, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.json">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>json
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.july">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>july
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.june">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>june
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.keys">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.le">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>le
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.limit">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>limit
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.line">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.literal">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>literal
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.lt">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>lt
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.map">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>map
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.march">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>march
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.match">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>match
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.max">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>max
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.maxval">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>maxval
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.may">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>may
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.merge">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>merge
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.min">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>min
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.minutes">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>minutes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.minval">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>minval
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.mod">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>mod
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.monday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>monday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.month">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>month
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.mul">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>mul
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.ne">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ne
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.not">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.november">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>november
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.now">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>now
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.nth">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>nth
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.object">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>object
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.october">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>october
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.offsetsOf">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>offsetsOf
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.or">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>or
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.orderBy">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>orderBy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.outerJoin">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>outerJoin
            <span class="apidocSignatureSpan">(sequence, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.pluck">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>pluck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.point">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>point
            <span class="apidocSignatureSpan">(longitude, latitude)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.polygon">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>polygon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.polygonSub">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>polygonSub
            <span class="apidocSignatureSpan">(geometry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.prepend">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>prepend
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.random">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>random
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.range">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>range
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.rebalance">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>rebalance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.reconfigure">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>reconfigure
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.reduce">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>reduce
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.replace">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>replace
            <span class="apidocSignatureSpan">(newValue, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.round">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>round
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.row">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>row
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.run">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>run
            <span class="apidocSignatureSpan">(connection, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.sample">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sample
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.saturday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>saturday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.seconds">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>seconds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.september">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>september
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.setDifference">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setDifference
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.setInsert">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setInsert
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.setIntersection">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setIntersection
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.setUnion">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setUnion
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.skip">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>skip
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.slice">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>slice
            <span class="apidocSignatureSpan">(start, end, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.spliceAt">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>spliceAt
            <span class="apidocSignatureSpan">(index, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.split">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>split
            <span class="apidocSignatureSpan">(separator, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.status">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>status
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.sub">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.sum">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sum
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.sunday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sunday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.sync">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.table">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>table
            <span class="apidocSignatureSpan">(table, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.tableCreate">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tableCreate
            <span class="apidocSignatureSpan">(table, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.tableDrop">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tableDrop
            <span class="apidocSignatureSpan">(table)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.tableList">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tableList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.then">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>then
            <span class="apidocSignatureSpan">(resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.thursday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>thursday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.time">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>time
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.timeOfDay">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>timeOfDay
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.timezone">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>timezone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toEpochTime">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toEpochTime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toGeojson">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toGeojson
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toISO8601">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toISO8601
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toJSON">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toJsonString">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toJsonString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toStream">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toStream
            <span class="apidocSignatureSpan">(connection, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toString">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.tuesday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tuesday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.typeOf">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>typeOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.ungroup">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ungroup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.union">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>union
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.upcase">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>upcase
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.update">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>update
            <span class="apidocSignatureSpan">(newValue, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.uuid">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>uuid
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.values">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.wait">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>wait
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.wednesday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>wednesday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.withFields">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>withFields
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.without">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>without
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.year">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>year
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.zip">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>zip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_translateArgs</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.transform_stream">module rethinkdbdash.transform_stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream.transform_stream">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>transform_stream
            <span class="apidocSignatureSpan">(table, options, connection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream.super_">
            function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.transform_stream.prototype">module rethinkdbdash.transform_stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream.prototype._flush">
            function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_flush
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream.prototype._insert">
            function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_insert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream.prototype._next">
            function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_next
            <span class="apidocSignatureSpan">(value, encoding, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream.prototype._transform">
            function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_transform
            <span class="apidocSignatureSpan">(value, encoding, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.writable_stream">module rethinkdbdash.writable_stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.writable_stream.writable_stream">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>writable_stream
            <span class="apidocSignatureSpan">(table, options, connection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.writable_stream.super_">
            function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.writable_stream.prototype">module rethinkdbdash.writable_stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.writable_stream.prototype._insert">
            function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.prototype.</span>_insert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.writable_stream.prototype._next">
            function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.prototype.</span>_next
            <span class="apidocSignatureSpan">(value, encoding, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.writable_stream.prototype._write">
            function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.prototype.</span>_write
            <span class="apidocSignatureSpan">(value, encoding, done)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash" id="apidoc.module.rethinkdbdash">module rethinkdbdash</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.rethinkdbdash" id="apidoc.element.rethinkdbdash.rethinkdbdash">
        function <span class="apidocSignatureSpan"></span>rethinkdbdash
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function main(options) {
  var _r = new r();

  if (!helper.isPlainObject(options)) options = {};
  if (options.pool !== false) _r.createPools(options);
  _r._options = {};
  if (options.cursor === true) _r._options.cursor = true;
  if (options.stream === true) _r._options.stream = true;
  if (options.optionalRun === false) {
    delete _r._Term.prototype.then
    delete _r._Term.prototype.error
    delete _r._Term.prototype.catch
    delete _r._Term.prototype.finally
  }
  return _r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection" id="apidoc.element.rethinkdbdash.connection">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>connection
        <span class="apidocSignatureSpan">(r, options, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connection(r, options, resolve, reject) {
  var self = this;
  this.r = r;
  this.state = 0; // Track the progress of the handshake. -1 will be used for an error state.

  // Set default options - We have to save them in case the user tries to reconnect
  if (!helper.isPlainObject(options)) options = {};
  this.host = options.host || r._host;
  this.port = options.port || r._port;
  if (options.authKey != null) {
    if (options.user != null || options.password != null) {
      throw new Err.ReqlDriverError('Cannot use both authKey and password');
    }
    this.user = r._user;
    this.password = options.authKey;
  } else {
    if (options.user === undefined) {
      this.user = r._user;
    } else {
      this.user = options.user;
    }
    if (options.password === undefined) {
      this.password = r._password;
    } else {
      this.password = options.password;
    }
  }

  this.authKey = options.authKey || r._authKey;
  // period in *seconds* for the connection to be opened
  this.timeoutConnect = options.timeout || r._timeoutConnect;
  // The connection will be pinged every &lt;pingInterval&gt; seconds
  this.pingInterval = options.pingInterval || r._pingInterval;

  if (options.db) this.db = options.db; // Pass to each query

  this.token = 1;
  this.buffer = new Buffer(0);

  this.metadata = {}

  this.open = false; // true only if the user can write on the socket
  this.timeout = null;

  if (options.connection) {
    this.connection = options.connection;
  }
  else {
    var family = 'IPv4';
    if (net.isIPv6(self.host)) {
      family = 'IPv6';
    }

    var connectionArgs = {
      host: self.host,
      port: self.port,
      family: family
    }

    var tlsOptions = options.ssl || false;
    if (tlsOptions === false) {
      self.connection = net.connect(connectionArgs);
    } else {
      if (helper.isPlainObject(tlsOptions)) {
        // Copy the TLS options in connectionArgs
        helper.loopKeys(tlsOptions, function(tlsOptions, key) {
          connectionArgs[key] = tlsOptions[key];
        });
      }
      self.connection = tls.connect(connectionArgs);
    }
  }

  self.connection.setKeepAlive(true);

  self.timeoutOpen = setTimeout(function() {
    self.connection.end(); // Send a FIN packet
    reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+' in less than '+self.timeoutConnect+'s').setOperational
());
  }, self.timeoutConnect*1000);

  self.connection.on('end', function() {
    self.open = false;
    self.emit('end');
    // We got a FIN packet, so we'll just flush
    self._flush();
  });
  self.connection.on('close', function() {
    // We emit end or close just once
    clearTimeout(self.timeoutOpen)
    clearInterval(self.pingIntervalId);
    self.connection.removeAllListeners();
    self.open = false;
    self.emit('closed');
    // The connection is fully closed, flush (in case 'end' was not triggered)
    self._flush();
  });
  self.connection.setNoDelay();
  self.connection.once('error', function(error) {
    reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+'\nFull error:\n'+JSON.stringify(error)).setOperational
());
  });
  self.connection.on('connect', function() {
    self.connection.removeAllListeners('error');
    self.connection.on('error', function(error) {
      self.emit('error', error);
    });

    var versionBuffer = new Buffer(4)
    versionBuffer.writeUInt32LE(protodef.VersionDummy.Version.V1_0, 0)

    self.randomString = new Buffer(crypto.randomBytes(18)).toString('base64')
    var authBuffer = new Buffer(JSON.stringify({
      protocol_version: PROTOCOL_VERSION,
      authentication_method: AUTHENTIFICATION_METHOD,
      authentication: "n,,n=" + self.user + ",r=" + self.randomString
    }));

    helper.tryCatch(function() {
      self.connection.write(Buffer.concat([versionBuffer, authBuffer, NULL_BUFFER]));
    }, function(err) {
      // The TCP connection is open, but the ReQL connection wasn't established.
      // We can just abort the whole thing
      self.open = false;
      reject(new Err.ReqlD ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor" id="apidoc.element.rethinkdbdash.cursor">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>cursor
        <span class="apidocSignatureSpan">(connection, token, options, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cursor(connection, token, options, type) {
  this.connection = connection;
  this.token = token;

  this._stackSize = 0; // Estimation of our call stack.
  this._index = 0; // Position in this._data[0]
  this._data = []; // Array of non empty arrays
  this._fetching = false; // Are we fetching data
  this._canFetch = true; // Can we fetch more data?
  this._pendingPromises = []; // Pending promises' resolve/reject
  this.options = options || {};
  this._closed = false;
  this._closingPromise = null; // Promise returned by close
  this._type = type;
  this._setIncludesStates = false;
  if ((type === 'feed') || (type === 'atomFeed')) {
    this.toArray = _unsupportedToArray;
  }
  this._emittedEnd = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue" id="apidoc.element.rethinkdbdash.dequeue">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>dequeue
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Dequeue(size) {
  this.start = 0;
  this.end = 0;

  size = size || 50;
  this.buffer = new Array(size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata" id="apidoc.element.rethinkdbdash.metadata">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>metadata
        <span class="apidocSignatureSpan">(resolve, reject, query, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Metadata(resolve, reject, query, options) {
  this.resolve = resolve;
  this.reject = reject;
  this.query = query; // The query in case we have to build a backtrace
  this.options = options || {};
  this.cursor = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool" id="apidoc.element.rethinkdbdash.pool">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool
        <span class="apidocSignatureSpan">(r, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pool(r, options) {
  this._r = r;

  if (!helper.isPlainObject(options)) options = {};
  this.options = {};
  this.options.max = options.max || 1000; // 4000 is about the maximum the kernel can take
  var buffer = (typeof options.buffer === 'number') ? options.buffer : 50;
  this.options.buffer = (buffer &lt; this.options.max) ? buffer : this.options.max;
  this.options.timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed
?
  this.options.timeoutGb = options.timeoutGb || 60*60*1000; // Default timeout for TCP connection is 2 hours on Linux, we time out
 after one hour.
  this.options.maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError

  this.options.silent = options.silent || false;

  this.options.connection = {
    host: options.host || this._r._host,
    port: options.port || this._r._port,
    db: options.db || this._r._db,
    timeout: options.timeout || this._r._timeoutConnect,
    authKey: options.authKey,
    user: options.user,
    password: options.password,
    cursor: options.cursor || false,
    stream: options.stream || false,
    ssl: options.ssl || false,
    pingInterval: options.pingInterval || this._r._pingInterval
  }
  this._log = options._log;

  this._pool = new Dequeue(this.options.buffer+1);
  this._draining = false;
  this._drainingHandlers = null; // Store the resolve/reject methods once draining is called
  this._localhostToDrain = 0; // number of connections to "localhost" to remove
  this._connectionToReplace = 0; // number of connections to "localhost" to remove

  this._numConnections = 0;
  this._openingConnections = 0; // Number of connections being opened
  this._consecutiveFails = 0;   // In slow growth, the number of consecutive failures to open a connection
  this._slowGrowth = false;     // Opening one connection at a time
  this._slowlyGrowing = false;  // The next connection to be returned is one opened in slowGrowth mode
  this._extraConnections = 0; // Number of extra connections being opened that we should eventually close

  this._empty = true;

  var self = this;
  // So we can let the pool master bind listeners
  setTimeout(function() {
    if (self._draining === false) {
      for(var i=0; i&lt;self.options.buffer; i++) {
        if (self.getLength() &lt; self.options.max) {
          self.createConnection();
        }
      }
    }
  }, 0);
  this.id = Math.floor(Math.random()*100000);
  this._log('Creating a pool connected to '+this.getAddress());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master" id="apidoc.element.rethinkdbdash.pool_master">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool_master
        <span class="apidocSignatureSpan">(r, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PoolMaster(r, options) {
  var self = this;
  var options = options || {};
  var lineLength = options.buffer || 50;

  self._r = r;
  self._line = new Dequeue(lineLength);
  self._pools = {};
  self._pools[UNKNOWN_POOLS] = []; // pools for which we do not know the server'id
  self._healthyPools = [];
  self._healthy = false;
  self._init = false;
  self._index = 0; // next pool to used
  self._indexUnknown =  0 // next unknown pool to used
  self._discovery = (typeof options.discovery === 'boolean') ? options.discovery: false; // Whether the pool master is in discovery
 mode or not
  //self._refresh = (typeof options.refresh === 'number') ? options.refresh: 1000*60*60; // Refresh rate for the list of servers
  self._options = options;
  self._options.buffer = options.buffer || 50;
  self._options.max = options.max || 1000;
  self._log = helper.createLogger(self, options.silent || false);
  self._draining = false;
  self._numConnections = 0;
  self._numAvailableConnections = 0;
  self._hasPrintWarningLocalhost = false;
  self._feed = null;
  self._consecutiveFails = -1;
  self._timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?
  self._maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError

  //TODO
  //self._usingPool = true; // If we have used the pool
  self._seed = 0;

  var pool;
  if (Array.isArray(options.servers)) {
    if (options.servers.length &gt; 0) {
      self._servers = options.servers;
      for(var i=0; i&lt;options.servers.length; i++) {
        var settings = self.createPoolSettings(options, options.servers[i], self._log);
        pool = new Pool(self._r, settings);
        self._pools[UNKNOWN_POOLS].push(pool);
        // A pool is considered healthy by default such that people can do
        // var = require(...)(); query.run();
        self._healthyPools.push(pool);
        self.emitStatus()
      }
    }
    else {
      throw new Err.ReqlDriverError("If `servers` is an array, it must contain at least one server")
    }
  }
  else {
    self._servers = [{
      host: options.host || 'localhost',
      port: options.port || 28015
    }]
    var settings = self.createPoolSettings(options, {}, self._log);
    pool = new Pool(self._r, settings);
    self._pools[UNKNOWN_POOLS].push(pool);
    self._healthyPools.push(pool);
    self.emitStatus()
  }

  // Initialize all the pools - bind listeners
  for(var i=0; i&lt;self._pools[UNKNOWN_POOLS].length; i++) {
    self.initPool(self._pools[UNKNOWN_POOLS][i]);
  }
  if ((self._discovery === true)) {
    self._timeout = setTimeout(function() { self.fetchServers() }, 0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream" id="apidoc.element.rethinkdbdash.stream">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>stream
        <span class="apidocSignatureSpan">(options, cursor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadableStream(options, cursor) {
  if (cursor) this._cursor = cursor;
  this._pending = 0; // How many time we called _read while no cursor was available
  this._index = 0;
  this._maxRecursion = 1000; // Hardcoded
  this._highWaterMark = options.highWaterMark;
  this._closed = false;

  Readable.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term" id="apidoc.element.rethinkdbdash.term">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>term
        <span class="apidocSignatureSpan">(r, value, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Term(r, value, error) {
  var self = this;
  var term = function(field) {
    if (Term.prototype._fastArity(arguments.length, 1) === false) {
      var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
      Term.prototype._arity(_args, 1, '(...)', self);
    }
    return term.bracket(field);
  }
  helper.changeProto(term, self);

  if (value === undefined) {
    term._query = [];
  }
  else {
    term._query = value;
  }
  term._r = r; // Keep a reference to r for global settings

  if (error !== undefined) {
    term._error = error;
    term._frames = [];
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream" id="apidoc.element.rethinkdbdash.transform_stream">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>transform_stream
        <span class="apidocSignatureSpan">(table, options, connection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TransformStream(table, options, connection) {
  this._table = table;
  this._r = table._r;
  this._options = options;
  this._cache = [];
  this._pendingCallback = null;
  this._ended = false;
  this._inserting = false;
  this._delayed = false;
  this._connection = connection;
  this._highWaterMark = options.highWaterMark || 100;
  this._insertOptions = {};
  this._insertOptions.durability = options.durability || 'hard';
  this._insertOptions.conflict = options.conflict || 'error';
  this._insertOptions.returnChanges = options.returnChanges || true;

  // Internal option to run some tests
  if (options.debug === true) {
    this._sequence = [];
  }

  Transform.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.writable_stream" id="apidoc.element.rethinkdbdash.writable_stream">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>writable_stream
        <span class="apidocSignatureSpan">(table, options, connection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WritableStream(table, options, connection) {
  this._table = table;
  this._options = options;
  this._cache = [];
  this._pendingCallback = null;
  this._inserting = false;
  this._delayed = false;
  this._connection = connection;
  this._highWaterMark = options.highWaterMark || 100;

  this._insertOptions = {};
  this._insertOptions.durability = options.durability || 'hard';
  this._insertOptions.conflict = options.conflict || 'error';

  // Internal option to run some tests
  if (options.debug === true) {
    this._sequence = [];
  }

  Writable.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
  this._i = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.connection" id="apidoc.module.rethinkdbdash.connection">module rethinkdbdash.connection</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.connection" id="apidoc.element.rethinkdbdash.connection.connection">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>connection
        <span class="apidocSignatureSpan">(r, options, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connection(r, options, resolve, reject) {
  var self = this;
  this.r = r;
  this.state = 0; // Track the progress of the handshake. -1 will be used for an error state.

  // Set default options - We have to save them in case the user tries to reconnect
  if (!helper.isPlainObject(options)) options = {};
  this.host = options.host || r._host;
  this.port = options.port || r._port;
  if (options.authKey != null) {
    if (options.user != null || options.password != null) {
      throw new Err.ReqlDriverError('Cannot use both authKey and password');
    }
    this.user = r._user;
    this.password = options.authKey;
  } else {
    if (options.user === undefined) {
      this.user = r._user;
    } else {
      this.user = options.user;
    }
    if (options.password === undefined) {
      this.password = r._password;
    } else {
      this.password = options.password;
    }
  }

  this.authKey = options.authKey || r._authKey;
  // period in *seconds* for the connection to be opened
  this.timeoutConnect = options.timeout || r._timeoutConnect;
  // The connection will be pinged every &lt;pingInterval&gt; seconds
  this.pingInterval = options.pingInterval || r._pingInterval;

  if (options.db) this.db = options.db; // Pass to each query

  this.token = 1;
  this.buffer = new Buffer(0);

  this.metadata = {}

  this.open = false; // true only if the user can write on the socket
  this.timeout = null;

  if (options.connection) {
    this.connection = options.connection;
  }
  else {
    var family = 'IPv4';
    if (net.isIPv6(self.host)) {
      family = 'IPv6';
    }

    var connectionArgs = {
      host: self.host,
      port: self.port,
      family: family
    }

    var tlsOptions = options.ssl || false;
    if (tlsOptions === false) {
      self.connection = net.connect(connectionArgs);
    } else {
      if (helper.isPlainObject(tlsOptions)) {
        // Copy the TLS options in connectionArgs
        helper.loopKeys(tlsOptions, function(tlsOptions, key) {
          connectionArgs[key] = tlsOptions[key];
        });
      }
      self.connection = tls.connect(connectionArgs);
    }
  }

  self.connection.setKeepAlive(true);

  self.timeoutOpen = setTimeout(function() {
    self.connection.end(); // Send a FIN packet
    reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+' in less than '+self.timeoutConnect+'s').setOperational
());
  }, self.timeoutConnect*1000);

  self.connection.on('end', function() {
    self.open = false;
    self.emit('end');
    // We got a FIN packet, so we'll just flush
    self._flush();
  });
  self.connection.on('close', function() {
    // We emit end or close just once
    clearTimeout(self.timeoutOpen)
    clearInterval(self.pingIntervalId);
    self.connection.removeAllListeners();
    self.open = false;
    self.emit('closed');
    // The connection is fully closed, flush (in case 'end' was not triggered)
    self._flush();
  });
  self.connection.setNoDelay();
  self.connection.once('error', function(error) {
    reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+'\nFull error:\n'+JSON.stringify(error)).setOperational
());
  });
  self.connection.on('connect', function() {
    self.connection.removeAllListeners('error');
    self.connection.on('error', function(error) {
      self.emit('error', error);
    });

    var versionBuffer = new Buffer(4)
    versionBuffer.writeUInt32LE(protodef.VersionDummy.Version.V1_0, 0)

    self.randomString = new Buffer(crypto.randomBytes(18)).toString('base64')
    var authBuffer = new Buffer(JSON.stringify({
      protocol_version: PROTOCOL_VERSION,
      authentication_method: AUTHENTIFICATION_METHOD,
      authentication: "n,,n=" + self.user + ",r=" + self.randomString
    }));

    helper.tryCatch(function() {
      self.connection.write(Buffer.concat([versionBuffer, authBuffer, NULL_BUFFER]));
    }, function(err) {
      // The TCP connection is open, but the ReQL connection wasn't established.
      // We can just abort the whole thing
      self.open = false;
      reject(new Err.ReqlD ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.super_" id="apidoc.element.rethinkdbdash.connection.super_">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.connection.prototype" id="apidoc.module.rethinkdbdash.connection.prototype">module rethinkdbdash.connection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._abort" id="apidoc.element.rethinkdbdash.connection.prototype._abort">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_abort = function () {
  this.state = -1;
  this.removeAllListeners();
  this.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      for(var i=0; i&lt;self.buffer.length; i++) {
if (self.buffer[i] === 0) {
  var messageServerStr = self.buffer.slice(0, i).toString();
  self.buffer = self.buffer.slice(i+1); // +1 to remove the null byte
  try {
    var messageServer = JSON.parse(messageServerStr);
  } catch(error) {
    self.<span class="apidocCodeKeywordSpan">_abort</span>();
    reject(new Err.ReqlDriverError('Could not parse the message sent by the server : \''+messageServerStr+'\&amp;#
x27;').setOperational());
    return;
  }
  if (messageServer.success !== true) {
    self._abort();
    reject(new Err.ReqlDriverError('Error '+messageServer.error_code+':'+messageServer.error).setOperational
());
    return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._checkProtocolVersion" id="apidoc.element.rethinkdbdash.connection.prototype._checkProtocolVersion">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_checkProtocolVersion
        <span class="apidocSignatureSpan">(messageServer, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkProtocolVersion = function (messageServer, reject) {
  // Expect max_protocol_version, min_protocol_version, server_version, success
  var minVersion = messageServer.min_protocol_version
  var maxVersion = messageServer.max_protocol_version

  if (minVersion &gt; PROTOCOL_VERSION || maxVersion &lt; PROTOCOL_VERSION) {
    this._abort();
    reject(new Err.ReqlDriverError('Unsupported protocol version: '+PROTOCOL_VERSION+', expected between '+minVersion+' and '+ maxVersion
).setOperational());
  }
  this.state = 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (messageServer.success !== true) {
    self._abort();
    reject(new Err.ReqlDriverError('Error '+messageServer.error_code+':'+messageServer.error).setOperational
());
    return;
  }

  if (self.state === 0) {
    self.<span class="apidocCodeKeywordSpan">_checkProtocolVersion</span>(messageServer, reject);
  } else if (self.state === 1) {
    // Compute salt and send the proof
    self._computeSaltedPassword(messageServer, reject);
  } else if (self.state === 2) {
    self._compareDigest(messageServer, resolve, reject);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._compareDigest" id="apidoc.element.rethinkdbdash.connection.prototype._compareDigest">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_compareDigest
        <span class="apidocSignatureSpan">(messageServer, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compareDigest = function (messageServer, resolve, reject) {
  var self = this;
  var firstEquals = messageServer.authentication.indexOf('=')
  var serverSignatureValue = messageServer.authentication.slice(firstEquals+1)

  if (!helper.compareDigest(serverSignatureValue, self.serverSignature.toString("base64"))) {
    reject(new Err.ReqlDriverError('Invalid server signature').setOperational());
  }

  self.state = 4
  self.connection.removeAllListeners('error');
  self.open = true;
  self.connection.on('error', function(e) {
    self.open = false;
  });
  clearTimeout(self.timeoutOpen)
  resolve(self);
  if (self.pingInterval &gt; 0) {
    self.pingIntervalId = setInterval(function() {
      self.pendingPing = true;
      self.r.error(PING_VALUE).run(self).error(function(error) {
        self.pendingPing = false;
        if (error.message !== PING_VALUE) {
          self.emit('error', new Err.ReqlDriverError(
                'Could not ping the connection').setOperational());
          self.open = false;
          self.connection.end();
        } else {
        }
      });
    }, self.pingInterval*1000);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      if (self.state === 0) {
        self._checkProtocolVersion(messageServer, reject);
      } else if (self.state === 1) {
        // Compute salt and send the proof
        self._computeSaltedPassword(messageServer, reject);
      } else if (self.state === 2) {
        self.<span class="apidocCodeKeywordSpan">_compareDigest</span>(messageServer, resolve, reject);
      }
    }
  }
}
else {
  while(self.buffer.length &gt;= 12) {
    var token = self.buffer.readUInt32LE(0) + 0x100000000 * self.buffer.readUInt32LE(4);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._computeSaltedPassword" id="apidoc.element.rethinkdbdash.connection.prototype._computeSaltedPassword">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_computeSaltedPassword
        <span class="apidocSignatureSpan">(messageServer, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_computeSaltedPassword = function (messageServer, reject) {
  var self = this;
  var authentication = helper.splitCommaEqual(messageServer.authentication);

  var randomNonce = authentication.r
  var salt = new Buffer(authentication.s, 'base64')
  var iterations = parseInt(authentication.i)

  if (randomNonce.substr(0, self.randomString.length) !== self.randomString) {
    self._abort();
    reject(new Err.ReqlDriverError('Invalid nonce from server').setOperational());
  }

  // The salt is constant, so we can cache the salted password.
  var cacheKey = self.password.toString("base64")+','+salt.toString("base64")+','+iterations;
  if (CACHE_PBKDF2.hasOwnProperty(cacheKey)) {
    helper.tryCatch(function() {
      self._sendProof(messageServer.authentication, randomNonce, CACHE_PBKDF2[cacheKey]);
    }, function(err) {
      // The TCP connection is open, but the ReQL connection wasn't established.
      // We can just abort the whole thing
      self.open = false;
      reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational());
    });
  } else {
    crypto.pbkdf2(self.password, salt, iterations, KEY_LENGTH, "sha256", function(error, saltedPassword) {
      if (error != null) {
        self._abort();
        reject(new Err.ReqlDriverError('Could not derive the key. Error:' + error.toString()).setOperational());
      }
      CACHE_PBKDF2[cacheKey] = saltedPassword;
      helper.tryCatch(function() {
        self._sendProof(messageServer.authentication, randomNonce, saltedPassword);
      }, function(err) {
        // The TCP connection is open, but the ReQL connection wasn't established.
        // We can just abort the whole thing
        self.open = false;
        reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational());
      });
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
      }

      if (self.state === 0) {
        self._checkProtocolVersion(messageServer, reject);
      } else if (self.state === 1) {
        // Compute salt and send the proof
        self.<span class="apidocCodeKeywordSpan">_computeSaltedPassword</span>(messageServer, reject);
      } else if (self.state === 2) {
        self._compareDigest(messageServer, resolve, reject);
      }
    }
  }
}
else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._continue" id="apidoc.element.rethinkdbdash.connection.prototype._continue">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_continue
        <span class="apidocSignatureSpan">(token, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_continue = function (token, resolve, reject) {
  var query = [protodef.Query.QueryType.CONTINUE];
  this._send(query, token, resolve, reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Cursor.prototype._fetch = function() {
var self = this;
this._fetching = true;

var p = new Promise(function(resolve, reject) {
  self.connection.<span class="apidocCodeKeywordSpan">_continue</span>(self.token, resolve, reject);
}).then(function(response) {
  self._push(response);
  return null;
}).error(function(error) {
  self._fetching = false;
  self._canFetch = false;
  self._pushError(error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._end" id="apidoc.element.rethinkdbdash.connection.prototype._end">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_end
        <span class="apidocSignatureSpan">(token, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_end = function (token, resolve, reject) {
  var query = [protodef.Query.QueryType.STOP];
  this._send(query, token, resolve, reject, undefined, undefined, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var endCallback = function() {
      if (self._eventEmitter &amp;&amp; (self._emittedEnd === false)) {
        self._emittedEnd = true;
        self._eventEmitter.emit('end');
      }
      resolve();
    }
    self.connection.<span class="apidocCodeKeywordSpan">_end</span>(self.token, endCallback, reject);
  }
}).nodeify(callback);
return self._closingPromise;
}
Cursor.prototype._each = function(callback, onFinish) {
if (this._closed === true) {
  return callback(new Err.ReqlDriverError('You cannot retrieve data from a cursor that is closed').setOperational());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._flush" id="apidoc.element.rethinkdbdash.connection.prototype._flush">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function () {
  helper.loopKeys(this.metadata, function(metadata, key) {
    if (typeof metadata[key].reject === 'function') {
      metadata[key].reject(new Err.ReqlServerError(
            'The connection was closed before the query could be completed.',
            metadata[key].query));
    }
    if (typeof metadata[key].endReject === 'function') {
      metadata[key].endReject(new Err.ReqlServerError(
            'The connection was closed before the query could be completed.',
            metadata[key].query));
    }
  });
  this.metadata = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+' in less than '+
self.timeoutConnect+'s').setOperational());
}, self.timeoutConnect*1000);

self.connection.on('end', function() {
  self.open = false;
  self.emit('end');
  // We got a FIN packet, so we'll just flush
  self.<span class="apidocCodeKeywordSpan">_flush</span>();
});
self.connection.on('close', function() {
  // We emit end or close just once
  clearTimeout(self.timeoutOpen)
  clearInterval(self.pingIntervalId);
  self.connection.removeAllListeners();
  self.open = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._getToken" id="apidoc.element.rethinkdbdash.connection.prototype._getToken">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_getToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getToken = function () {
  return this.token++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.db = db;
}

Connection.prototype.server = function(callback) {
  var self = this;
  return new Promise(function(resolve, reject) {
    var query = [protodef.Query.QueryType.SERVER_INFO];
    self._send(query, self.<span class="apidocCodeKeywordSpan">_getToken</span>(), resolve, reject, undefined, undefined, true);
  }).nodeify(callback);
}

// Return the next token and update it.
Connection.prototype._getToken = function() {
  return this.token++;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._isConnection" id="apidoc.element.rethinkdbdash.connection.prototype._isConnection">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_isConnection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isConnection = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this;

if (self._error != null) {
  var error = new Error.ReqlRuntimeError(self._error, self._query, {b: self._frames});
  return Promise.reject(error);
}

if (helper.isPlainObject(connection) &amp;&amp; (typeof connection._isConnection === 'function') &amp;&amp; (connection
.<span class="apidocCodeKeywordSpan">_isConnection</span>() === true)) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  else {
    if (!helper.isPlainObject(options)) options = {};
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._isOpen" id="apidoc.element.rethinkdbdash.connection.prototype._isOpen">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_isOpen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isOpen = function () {
  return this.open;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    clearTimeout(connection.timeout);
    self._decreaseNumConnections();
    self._expandBuffer();
  });
  connection.on('release', function() {
    if (this.<span class="apidocCodeKeywordSpan">_isOpen</span>()) self.putConnection(this);
  });
  self.putConnection(connection);
  return null;
}).error(function(error) {
  // We failed to create a connection, we are now going to create connections one by one
  self._openingConnections--;
  self._decreaseNumConnections();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._processResponse" id="apidoc.element.rethinkdbdash.connection.prototype._processResponse">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_processResponse
        <span class="apidocSignatureSpan">(response, token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processResponse = function (response, token) {
  //console.log('Connection.prototype._processResponse: '+token);
  //console.log(JSON.stringify(response, null, 2));
  var self = this;

  var type = response.t;
  var result;
  var cursor;
  var stream;
  var currentResolve, currentReject;
  var datum;
  var options;

  if (type === responseTypes.COMPILE_ERROR) {
    self.emit('release');
    if (typeof self.metadata[token].reject === 'function') {
      self.metadata[token].reject(new Err.ReqlCompileError(helper.makeAtom(response), self.metadata[token].query, response));
    }

    delete self.metadata[token]
  }
  else if (type === responseTypes.CLIENT_ERROR) {
    self.emit('release');

    if (typeof self.metadata[token].reject === 'function') {
      currentResolve = self.metadata[token].resolve;
      currentReject = self.metadata[token].reject;
      self.metadata[token].removeCallbacks();
      currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));
      if (typeof self.metadata[token].endReject !== 'function') {
        // No pending STOP query, we can delete
        delete self.metadata[token]
      }
    }
    else if (typeof self.metadata[token].endResolve === 'function') {
      currentResolve = self.metadata[token].endResolve;
      currentReject = self.metadata[token].endReject;
      self.metadata[token].removeEndCallbacks();
      currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));
      delete self.metadata[token]
    }
    else if (token === -1) { // This should not happen now since 1.13 took the token out of the query
      var error = new Err.ReqlClientError(helper.makeAtom(response)+'\nClosing all outstanding queries...');
      self.emit('error', error);
      // We don't want a function to yield forever, so we just reject everything
      helper.loopKeys(self.rejectMap, function(rejectMap, key) {
        rejectMap[key](error);
      });
      self.close();
      delete self.metadata[token]
    }
  }
  else if (type === responseTypes.RUNTIME_ERROR) {
    var errorValue = helper.makeAtom(response);
    var error;
    // We don't want to release a connection if we just pinged it.
    if (self.pendingPing === false || (errorValue !== PING_VALUE)) {
      self.emit('release');
      error = new Err.ReqlRuntimeError(errorValue, self.metadata[token].query, response);
    } else {
      error = new Err.ReqlRuntimeError(errorValue);
    }

    if (typeof self.metadata[token].reject === 'function') {
      currentResolve = self.metadata[token].resolve;
      currentReject = self.metadata[token].reject;
      self.metadata[token].removeCallbacks();
      error.setName(response.e);
      currentReject(error);
      if (typeof self.metadata[token].endReject !== 'function') {
        // No pending STOP query, we can delete
        delete self.metadata[token]
      }
    }
    else if (typeof self.metadata[token].endResolve === 'function') {
      currentResolve = self.metadata[token].endResolve;
      currentReject = self.metadata[token].endReject;
      self.metadata[token].removeEndCallbacks();
      delete self.metadata[token]
    }
  }
  else if (type === responseTypes.SUCCESS_ATOM) {
    self.emit('release');
    // self.metadata[token].resolve is always a function
    datum = helper.makeAtom(response, self.metadata[token].options);

    if ((Array.isArray(datum)) &amp;&amp;
        ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) &amp;&amp; (self.r._options
.cursor === true)))) {
      cursor = new Cursor(self, token, self.metadata[token].options, 'cursor');
      if (self.metadata[token].options.profile === true) {
        self.metadata[token].resolve({
          profile: response.p,
          result: cursor
        });
      }
      else {
        self.metadata[token].resolve(cursor);
      }

      cursor._push({done: true, response: { r: datum }});
    }
    else if ((Array.isArray(datum)) &amp;&amp;
        ((self.metadata[token].options.stream === true || self.r._options.stream === true) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var responseLength = self.buffer.readUInt32LE(8);

      if (self.buffer.length &lt; 12+responseLength) break;

      var responseBuffer = self.buffer.slice(12, 12+responseLength);
      var response = JSON.parse(responseBuffer);

      self.<span class="apidocCodeKeywordSpan">_processResponse</span>(response, token);

      self.buffer = self.buffer.slice(12+responseLength);
    }
  }
});

self.connection.on('timeout', function(buffer) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._send" id="apidoc.element.rethinkdbdash.connection.prototype._send">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_send
        <span class="apidocSignatureSpan">(query, token, resolve, reject, originalQuery, options, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_send = function (query, token, resolve, reject, originalQuery, options, end) {
  //console.log('Connection.prototype._send: '+token);
  //console.log(JSON.stringify(query, null, 2));

  var self = this;
  if (self.open === false) {
    var err = new Err.ReqlDriverError('The connection was closed by the other party');
    err.setOperational();
    reject(err);
    return;
  }

  var queryStr = JSON.stringify(query);
  var querySize = Buffer.byteLength(queryStr);

  var buffer = new Buffer(8+4+querySize);
  buffer.writeUInt32LE(token &amp; 0xFFFFFFFF, 0)
  buffer.writeUInt32LE(Math.floor(token / 0xFFFFFFFF), 4)

  buffer.writeUInt32LE(querySize, 8);

  buffer.write(queryStr, 12);

  // noreply instead of noReply because the otpions are translated for the server
  if ((!helper.isPlainObject(options)) || (options.noreply != true)) {
    if (!self.metadata[token]) {
      self.metadata[token] = new Metadata(resolve, reject, originalQuery, options);
    }
    else if (end === true) {
      self.metadata[token].setEnd(resolve, reject);
    }
    else {
      self.metadata[token].setCallbacks(resolve, reject);
    }
  }
  else {
    if (typeof resolve === 'function') resolve();
    this.emit('release');
  }

  // This will emit an error if the connection is closed
  helper.tryCatch(function() {
    self.connection.write(buffer);
  }, function(err) {
    self.metadata[token].reject(err);
    delete self.metadata[token]
  });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    delete self.metadata[token]
  });

};

Connection.prototype._continue = function(token, resolve, reject) {
  var query = [protodef.Query.QueryType.CONTINUE];
  this.<span class="apidocCodeKeywordSpan">_send</span>(query, token, resolve, reject);
}
Connection.prototype._end = function(token, resolve, reject) {
  var query = [protodef.Query.QueryType.STOP];
  this._send(query, token, resolve, reject, undefined, undefined, true);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._sendProof" id="apidoc.element.rethinkdbdash.connection.prototype._sendProof">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_sendProof
        <span class="apidocSignatureSpan">(authentication, randomNonce, saltedPassword)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendProof = function (authentication, randomNonce, saltedPassword) {
  var clientFinalMessageWithoutProof = "c=biws,r=" + randomNonce;
  var clientKey = crypto.createHmac("sha256", saltedPassword).update("Client Key").digest()
  var storedKey = crypto.createHash("sha256").update(clientKey).digest()

  var authMessage =
      "n=" + this.user + ",r=" + this.randomString + "," +
      authentication + "," +
      clientFinalMessageWithoutProof

  var clientSignature = crypto.createHmac("sha256", storedKey).update(authMessage).digest()
  var clientProof = helper.xorBuffer(clientKey, clientSignature)

  var serverKey = crypto.createHmac("sha256", saltedPassword).update("Server Key").digest()
  this.serverSignature = crypto.createHmac("sha256", serverKey).update(authMessage).digest()

  this.state = 2
  var message = JSON.stringify({
    authentication: clientFinalMessageWithoutProof + ",p=" + clientProof.toString("base64")
  })
  this.connection.write(Buffer.concat([new Buffer(message.toString()), NULL_BUFFER]))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  reject(new Err.ReqlDriverError('Invalid nonce from server').setOperational());
}

// The salt is constant, so we can cache the salted password.
var cacheKey = self.password.toString("base64")+','+salt.toString("base64")+','+iterations
;
if (CACHE_PBKDF2.hasOwnProperty(cacheKey)) {
  helper.tryCatch(function() {
    self.<span class="apidocCodeKeywordSpan">_sendProof</span>(messageServer.authentication, randomNonce, CACHE_PBKDF2[cacheKey]);
  }, function(err) {
    // The TCP connection is open, but the ReQL connection wasn't established.
    // We can just abort the whole thing
    self.open = false;
    reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational
());
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype.close" id="apidoc.element.rethinkdbdash.connection.prototype.close">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>close
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  var self = this;

  var p = new Promise(function(resolve, reject) {
    if (!helper.isPlainObject(options)) options = {};
    if (options.noreplyWait === true) {
      self.noreplyWait().then(function(r) {
        self.open = false;
        self.connection.end()
        resolve(r);
      }).error(function(e) {
        reject(e)
      });
    }
    else{
      self.open = false;
      self.connection.end();
      resolve();
    }
  }).nodeify(callback);
  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
2. Remove everything related to a connection:

```js
r.connect({host: ..., port: ...}).then(function(connection) {
  connection.on('error', handleError);
  query.run(connection).then(function(result) {
    // console.log(result);
    connection.<span class="apidocCodeKeywordSpan">close</span>();
  });
});
```

Becomes:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype.noReplyWait" id="apidoc.element.rethinkdbdash.connection.prototype.noReplyWait">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>noReplyWait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noReplyWait = function () {
  throw new Err.ReqlDriverError('Did you mean to use `noreplyWait` instead of `noReplyWait`?')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype.noreplyWait" id="apidoc.element.rethinkdbdash.connection.prototype.noreplyWait">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>noreplyWait
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noreplyWait = function (callback) {
  var self = this;
  var token = self._getToken();

  var p = new Promise(function(resolve, reject) {
    var query = [protodef.Query.QueryType.NOREPLY_WAIT];

    self._send(query, token, resolve, reject);
  }).nodeify(callback);
  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  options = {};
}
var self = this;

var p = new Promise(function(resolve, reject) {
  if (!helper.isPlainObject(options)) options = {};
  if (options.noreplyWait === true) {
    self.<span class="apidocCodeKeywordSpan">noreplyWait</span>().then(function(r) {
      self.open = false;
      self.connection.end()
      resolve(r);
    }).error(function(e) {
      reject(e)
    });
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype.reconnect" id="apidoc.element.rethinkdbdash.connection.prototype.reconnect">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>reconnect
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconnect = function (options, callback) {
  var self = this;

  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  if (!helper.isPlainObject(options)) options = {};

  if (options.noreplyWait === true) {
    var p = new Promise(function(resolve, reject) {
      self.close(options).then(function() {
        self.r.connect({
          host: self.host,
          port: self.port,
          authKey: self.authKey,
          db: self.db
        }).then(function(c) {
          resolve(c);
        }).error(function(e) {
          reject(e);
        });
      }).error(function(e) {
        reject(e)
      })
    }).nodeify(callback);
  }
  else {
    return self.r.connect({
      host: self.host,
      port: self.port,
      authKey: self.authKey,
      db: self.db
    }, callback);
  }

  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype.server" id="apidoc.element.rethinkdbdash.connection.prototype.server">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>server
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">server = function (callback) {
  var self = this;
  return new Promise(function(resolve, reject) {
    var query = [protodef.Query.QueryType.SERVER_INFO];
    self._send(query, self._getToken(), resolve, reject, undefined, undefined, true);
  }).nodeify(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype.use" id="apidoc.element.rethinkdbdash.connection.prototype.use">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>use
        <span class="apidocSignatureSpan">(db)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (db) {
  if (typeof db !== 'string') throw new Err.ReqlDriverError('First argument of `use` must be a string')
  this.db = db;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.cursor" id="apidoc.module.rethinkdbdash.cursor">module rethinkdbdash.cursor</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.cursor" id="apidoc.element.rethinkdbdash.cursor.cursor">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>cursor
        <span class="apidocSignatureSpan">(connection, token, options, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cursor(connection, token, options, type) {
  this.connection = connection;
  this.token = token;

  this._stackSize = 0; // Estimation of our call stack.
  this._index = 0; // Position in this._data[0]
  this._data = []; // Array of non empty arrays
  this._fetching = false; // Are we fetching data
  this._canFetch = true; // Can we fetch more data?
  this._pendingPromises = []; // Pending promises' resolve/reject
  this.options = options || {};
  this._closed = false;
  this._closingPromise = null; // Promise returned by close
  this._type = type;
  this._setIncludesStates = false;
  if ((type === 'feed') || (type === 'atomFeed')) {
    this.toArray = _unsupportedToArray;
  }
  this._emittedEnd = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.cursor.prototype" id="apidoc.module.rethinkdbdash.cursor.prototype">module rethinkdbdash.cursor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._done" id="apidoc.element.rethinkdbdash.cursor.prototype._done">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_done
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_done = function () {
  this._canFetch = false;
  if (this._eventEmitter) {
    this._eventEmitter.emit('end');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self._canFetch = false;
  self._pushError(error);
})
}

Cursor.prototype._push = function(data) {
var couldfetch = this._canFetch;
if (data.done) this.<span class="apidocCodeKeywordSpan">_done</span>();
var response = data.response;
this._fetching = false;
// If the cursor was closed, we ignore all following response
if ((response.r.length &gt; 0) &amp;&amp; (couldfetch === true)) {
  this._data.push(helper.makeSequence(response, this.options));
}
// this._fetching = false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._each" id="apidoc.element.rethinkdbdash.cursor.prototype._each">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_each
        <span class="apidocSignatureSpan">(callback, onFinish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_each = function (callback, onFinish) {
  if (this._closed === true) {
    return callback(new Err.ReqlDriverError('You cannot retrieve data from a cursor that is closed').setOperational());
  }
  var self = this;

  var reject = function(err) {
    if (err.message === 'No more rows in the '+self._type.toLowerCase()+'.') {
      if (typeof onFinish === 'function') {
        onFinish();
      }
    }
    else {
      callback(err);
    }
    return null;
  }
  var resolve = function(data) {
    self._stackSize++;
    var keepGoing = callback(null, data);
    if (keepGoing === false) {
      if (typeof onFinish === 'function') {
        onFinish();
      }
    }
    else {
      if (self._closed === false) {
        if (self._stackSize &lt;= MAX_CALL_STACK) {
          self._next().then(resolve).error(function(error) {
            if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &amp;&amp;
                (error.message.match(/You cannot call `next` on a closed/) === null)) {
              reject(error);
            }
          });
        }
        else {
          setTimeout(function() {
            self._stackSize = 0;
            self._next().then(resolve).error(function(error) {
              if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &amp;&amp;
                  (error.message.match(/You cannot call `next` on a closed/) === null)) {
                reject(error);
              }
            });
          }, 0);
        }
      }
    }
    return null;
  }

  self._next().then(resolve).error(function(error) {
    // We can silence error when the cursor is closed as this
    if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &amp;&amp;
        (error.message.match(/You cannot call `next` on a closed/) === null)) {
      reject(error);
    }
  });
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
throw new Error('The `hasNext` command has been removed in 1.13, please use `next`.')
}
Cursor.prototype.toArray = function(callback) {
var self = this;
var p = new Promise(function(resolve, reject) {
  var result = [];
  var i =0;
  self.<span class="apidocCodeKeywordSpan">_each</span>(function(err, data) {
    if (err) {
      reject(err);
    }
    else {
      result.push(data);
    }
  }, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._eachAsync" id="apidoc.element.rethinkdbdash.cursor.prototype._eachAsync">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_eachAsync
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_eachAsync = function (callback) {
  var self = this;
  return new Promise(function(resolve, reject) {
    self._eachAsyncInternal(callback, resolve, reject)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._eachAsyncInternal" id="apidoc.element.rethinkdbdash.cursor.prototype._eachAsyncInternal">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_eachAsyncInternal
        <span class="apidocSignatureSpan">(callback, finalResolve, finalReject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_eachAsyncInternal = function (callback, finalResolve, finalReject) {
  if (this._closed === true) {
    finalReject(new Err.ReqlDriverError('You cannot retrieve data from a cursor that is closed').setOperational());
    return;
  }
  var self = this;

  var nextCb = function() {
    self._stackSize++;
    self._next().then(function(row) {
      if (self._stackSize &lt;= MAX_CALL_STACK) {
        if (callback.length &lt;= 1) {
          Promise.resolve(callback(row)).then(nextCb)
          return null;
        }
        else {
          new Promise(function(resolve, reject) {
            return callback(row, resolve)
          }).then(nextCb);
          return null;
        }
      }
      else {
        new Promise(function(resolve, reject) {
          setTimeout(function() {
            self._stackSize = 0;
            if (callback.length &lt;= 1) {
              Promise.resolve(callback(row)).then(resolve).catch(reject);
            }
            else {
              new Promise(function(resolve, reject) {
                return callback(row, resolve)
              }).then(resolve).catch(reject);
              return null;
            }
          }, 0)
        }).then(nextCb);
        return null;
      }
    }).error(function(error) {
      if ((error.message === 'No more rows in the '+self._type.toLowerCase()+'.') ||
          (error.message === 'You cannot retrieve data from a cursor that is closed.') ||
          (error.message.match(/You cannot call `next` on a closed/) !== null)) {
        return finalResolve();
      }
      return finalReject(Err.setOperational(error));
    });
  }
  nextCb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});
return null;
}
Cursor.prototype._eachAsync = function(callback) {
var self = this;
return new Promise(function(resolve, reject) {
  self.<span class="apidocCodeKeywordSpan">_eachAsyncInternal</span>(callback, resolve, reject)
});
}
Cursor.prototype._eachAsyncInternal = function(callback, finalResolve, finalReject) {
if (this._closed === true) {
  finalReject(new Err.ReqlDriverError('You cannot retrieve data from a cursor that is closed').setOperational());
  return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._eachCb" id="apidoc.element.rethinkdbdash.cursor.prototype._eachCb">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_eachCb
        <span class="apidocSignatureSpan">(err, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_eachCb = function (err, data) {
  // We should silent things if the cursor/feed is closed
  if (this._closed === false) {
    if (err) {
      this._eventEmitter.emit('error', err);
    }
    else {
      this._eventEmitter.emit('data', data);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._fetch" id="apidoc.element.rethinkdbdash.cursor.prototype._fetch">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fetch = function () {
  var self = this;
  this._fetching = true;

  var p = new Promise(function(resolve, reject) {
    self.connection._continue(self.token, resolve, reject);
  }).then(function(response) {
    self._push(response);
    return null;
  }).error(function(error) {
    self._fetching = false;
    self._canFetch = false;
    self._pushError(error);
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (self._data[0].length === self._index) {
      self._index = 0;
      self._data.shift();
      if ((self._data.length === 1)
        &amp;&amp; (self._canFetch === true)
        &amp;&amp; (self._closed === false)
        &amp;&amp; (self._fetching === false)) {
          self.<span class="apidocCodeKeywordSpan">_fetch</span>();
      }
    }
    return Promise.resolve(result).nodeify(callback);
  }
}
else {
  return new Promise(function(resolve, reject) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._flush" id="apidoc.element.rethinkdbdash.cursor.prototype._flush">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function () {
  while ((this._pendingPromises.length &gt; 0) &amp;&amp; ((this._data.length &gt; 0) || ((this._fetching === false) &amp;&amp; (this._canFetch === false
)))) {
    var fullfiller = this._pendingPromises.shift();
    var resolve = fullfiller.resolve;
    var reject = fullfiller.reject;

    if (this._data.length &gt; 0) {
      var result = this._data[0][this._index++];
      if (result instanceof Error) {
        reject(result);
      }
      else {
        resolve(result);
      }

      if (this._data[0].length === this._index) {
        this._index = 0;
        this._data.shift();
        if ((this._data.length &lt;= 1)
          &amp;&amp; (this._canFetch === true)
          &amp;&amp; (this._closed === false)
          &amp;&amp; (this._fetching === false)) {
            this._fetch();
        }
      }
    }
    else {
      reject(new Err.ReqlDriverError('No more rows in the '+this._type.toLowerCase()).setOperational())
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+' in less than '+
self.timeoutConnect+'s').setOperational());
}, self.timeoutConnect*1000);

self.connection.on('end', function() {
  self.open = false;
  self.emit('end');
  // We got a FIN packet, so we'll just flush
  self.<span class="apidocCodeKeywordSpan">_flush</span>();
});
self.connection.on('close', function() {
  // We emit end or close just once
  clearTimeout(self.timeoutOpen)
  clearInterval(self.pingIntervalId);
  self.connection.removeAllListeners();
  self.open = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._makeEmitter" id="apidoc.element.rethinkdbdash.cursor.prototype._makeEmitter">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_makeEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_makeEmitter = function () {
  this.next = function() {
    throw new Err.ReqlDriverError('You cannot call `next` once you have bound listeners on the '+this._type)
  }
  this.each = function() {
    throw new Err.ReqlDriverError('You cannot call `each` once you have bound listeners on the '+this._type)
  }
  this.eachAsync = function() {
    throw new Err.ReqlDriverError('You cannot call `eachAsync` once you have bound listeners on the '+this._type)
  }
  this.toArray = function() {
    throw new Err.ReqlDriverError('You cannot call `toArray` once you have bound listeners on the '+this._type)
  }
  this._eventEmitter = new EventEmitter();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

for(var i=0; i&lt;methods.length; i++) {
(function(n) {
  var method = methods[n];
  Cursor.prototype[method] = function() {
    var self = this;
    if (self._eventEmitter == null) {
      self.<span class="apidocCodeKeywordSpan">_makeEmitter</span>();
      setImmediate(function() {
        self._each(self._eachCb.bind(self), function() {
          if (self._emittedEnd === false) {
            self._emittedEnd = true;
            self._eventEmitter.emit('end');
          }
        });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._next" id="apidoc.element.rethinkdbdash.cursor.prototype._next">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_next
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_next = function (callback) {
  var self = this;
  if (self._closed === true) {
    return Promise.reject(new Err.ReqlDriverError(
      'You cannot call `next` on a closed '+self._type).setOperational()
    ).nodeify(callback);
  }
  else if ((self._data.length === 0) &amp;&amp; (self._canFetch === false)) {
    return Promise.reject(new Err.ReqlDriverError(
      'No more rows in the '+self._type.toLowerCase()).setOperational()
    ).nodeify(callback);
  }
  else {
    if ((self._data.length &gt; 0) &amp;&amp; (self._data[0].length &gt; self._index)) {
      var result = self._data[0][self._index++];
      if (result instanceof Error) {
        return Promise.reject(result).nodeify(callback);
      }
      else {
        // This could be possible if we get back batch with just one document?
        if (self._data[0].length === self._index) {
          self._index = 0;
          self._data.shift();
          if ((self._data.length === 1)
            &amp;&amp; (self._canFetch === true)
            &amp;&amp; (self._closed === false)
            &amp;&amp; (self._fetching === false)) {
              self._fetch();
          }
        }
        return Promise.resolve(result).nodeify(callback);
      }
    }
    else {
      return new Promise(function(resolve, reject) {
        self._pendingPromises.push({resolve: resolve, reject: reject});
      }).nodeify(callback);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (typeof onFinish === 'function') {
    onFinish();
  }
}
else {
  if (self._closed === false) {
    if (self._stackSize &lt;= MAX_CALL_STACK) {
      self.<span class="apidocCodeKeywordSpan">_next</span>().then(resolve).error(function(error) {
        if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &amp;&amp;
            (error.message.match(/You cannot call `next` on a closed/) === null)) {
          reject(error);
        }
      });
    }
    else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._push" id="apidoc.element.rethinkdbdash.cursor.prototype._push">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_push
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_push = function (data) {
  var couldfetch = this._canFetch;
  if (data.done) this._done();
  var response = data.response;
  this._fetching = false;
  // If the cursor was closed, we ignore all following response
  if ((response.r.length &gt; 0) &amp;&amp; (couldfetch === true)) {
    this._data.push(helper.makeSequence(response, this.options));
  }
  // this._fetching = false
  if ((this._closed === false) &amp;&amp; (this._canFetch) &amp;&amp; (this._data.length &lt;= 1)) this._fetch();
  this._flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      result: cursor
    });
  }
  else {
    self.metadata[token].resolve(cursor);
  }

  cursor.<span class="apidocCodeKeywordSpan">_push</span>({done: true, response: { r: datum }});
}
else if ((Array.isArray(datum)) &amp;&amp;
    ((self.metadata[token].options.stream === true || self.r._options.stream === true))) {
  cursor = new Cursor(self, token, self.metadata[token].options, 'cursor');
  stream = new ReadableStream({}, cursor);
  if (self.metadata[token].options.profile === true) {
    self.metadata[token].resolve({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._pushError" id="apidoc.element.rethinkdbdash.cursor.prototype._pushError">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_pushError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_pushError = function (error) {
  this._data.push([error]);
  this._flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.connection._continue(self.token, resolve, reject);
}).then(function(response) {
  self._push(response);
  return null;
}).error(function(error) {
  self._fetching = false;
  self._canFetch = false;
  self.<span class="apidocCodeKeywordSpan">_pushError</span>(error);
})
}

Cursor.prototype._push = function(data) {
var couldfetch = this._canFetch;
if (data.done) this._done();
var response = data.response;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._set" id="apidoc.element.rethinkdbdash.cursor.prototype._set">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_set
        <span class="apidocSignatureSpan">(ar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_set = function (ar) {
  this._fetching = false;
  this._canFetch = false;
  if (ar.length &gt; 0) {
    this._data.push(ar);
  }
  this._flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._unsupportedToArray" id="apidoc.element.rethinkdbdash.cursor.prototype._unsupportedToArray">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_unsupportedToArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_unsupportedToArray = function () {
  throw new Error('The `toArray` method is not available on feeds.')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.addListener" id="apidoc.element.rethinkdbdash.cursor.prototype.addListener">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit('end');
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.close" id="apidoc.element.rethinkdbdash.cursor.prototype.close">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
  var self = this;
  if (self._closed === true) {
    return self._closingPromise.nodeify(callback);
  }
  self._closed = true;

  self._closingPromise = new Promise(function(resolve, reject) {
    if ((self._canFetch === false) &amp;&amp; (self._fetching === false)) {
      resolve()
    }
    else { // since v0_4 (RethinkDB 2.0) we can (must) force a STOP request even if a CONTINUE query is pending
      var endCallback = function() {
        if (self._eventEmitter &amp;&amp; (self._emittedEnd === false)) {
          self._emittedEnd = true;
          self._eventEmitter.emit('end');
        }
        resolve();
      }
      self.connection._end(self.token, endCallback, reject);
    }
  }).nodeify(callback);
  return self._closingPromise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
2. Remove everything related to a connection:

```js
r.connect({host: ..., port: ...}).then(function(connection) {
  connection.on('error', handleError);
  query.run(connection).then(function(result) {
    // console.log(result);
    connection.<span class="apidocCodeKeywordSpan">close</span>();
  });
});
```

Becomes:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.each" id="apidoc.element.rethinkdbdash.cursor.prototype.each">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>each
        <span class="apidocSignatureSpan">(callback, onFinish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">each = function (callback, onFinish) {
  if (this._closed === true) {
    return callback(new Err.ReqlDriverError('You cannot retrieve data from a cursor that is closed').setOperational());
  }
  var self = this;

  var reject = function(err) {
    if (err.message === 'No more rows in the '+self._type.toLowerCase()+'.') {
      if (typeof onFinish === 'function') {
        onFinish();
      }
    }
    else {
      callback(err);
    }
    return null;
  }
  var resolve = function(data) {
    self._stackSize++;
    var keepGoing = callback(null, data);
    if (keepGoing === false) {
      if (typeof onFinish === 'function') {
        onFinish();
      }
    }
    else {
      if (self._closed === false) {
        if (self._stackSize &lt;= MAX_CALL_STACK) {
          self._next().then(resolve).error(function(error) {
            if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &amp;&amp;
                (error.message.match(/You cannot call `next` on a closed/) === null)) {
              reject(error);
            }
          });
        }
        else {
          setTimeout(function() {
            self._stackSize = 0;
            self._next().then(resolve).error(function(error) {
              if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &amp;&amp;
                  (error.message.match(/You cannot call `next` on a closed/) === null)) {
                reject(error);
              }
            });
          }, 0);
        }
      }
    }
    return null;
  }

  self._next().then(resolve).error(function(error) {
    // We can silence error when the cursor is closed as this
    if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &amp;&amp;
        (error.message.match(/You cannot call `next` on a closed/) === null)) {
      reject(error);
    }
  });
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (self._draining === true) {
  // There is no need to close the feed here as we'll close the connections
  return feed.close();
}
self._feed = feed;
var initializing = true;
var servers = [];
feed.<span class="apidocCodeKeywordSpan">each</span>(function(err, change) {
  if (err) {
    self._log('The changefeed on server_status returned an error: '+err.toString());
    // We have to refetch everything as the server that was serving the feed may
    // have died.
    if (!self._draining) {
      setTimeout(function() {
        self.fetchServers();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.eachAsync" id="apidoc.element.rethinkdbdash.cursor.prototype.eachAsync">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>eachAsync
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachAsync = function (callback) {
  var self = this;
  return new Promise(function(resolve, reject) {
    self._eachAsyncInternal(callback, resolve, reject)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.emit" id="apidoc.element.rethinkdbdash.cursor.prototype.emit">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit('end');
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.timeoutOpen = setTimeout(function() {
  self.connection.end(); // Send a FIN packet
  reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+' in less than '+
self.timeoutConnect+'s').setOperational());
}, self.timeoutConnect*1000);

self.connection.on('end', function() {
  self.open = false;
  self.<span class="apidocCodeKeywordSpan">emit</span>('end');
  // We got a FIN packet, so we'll just flush
  self._flush();
});
self.connection.on('close', function() {
  // We emit end or close just once
  clearTimeout(self.timeoutOpen)
  clearInterval(self.pingIntervalId);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.getType" id="apidoc.element.rethinkdbdash.cursor.prototype.getType">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>getType
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getType = function () {
  return this._type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.hasNext" id="apidoc.element.rethinkdbdash.cursor.prototype.hasNext">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>hasNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasNext = function () {
  throw new Error('The `hasNext` command has been removed in 1.13, please use `next`.')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.includesStates" id="apidoc.element.rethinkdbdash.cursor.prototype.includesStates">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>includesStates
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includesStates = function () {
  return this._setIncludesStates;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.listeners" id="apidoc.element.rethinkdbdash.cursor.prototype.listeners">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit('end');
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.next" id="apidoc.element.rethinkdbdash.cursor.prototype.next">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>next
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (callback) {
  var self = this;
  if (self._closed === true) {
    return Promise.reject(new Err.ReqlDriverError(
      'You cannot call `next` on a closed '+self._type).setOperational()
    ).nodeify(callback);
  }
  else if ((self._data.length === 0) &amp;&amp; (self._canFetch === false)) {
    return Promise.reject(new Err.ReqlDriverError(
      'No more rows in the '+self._type.toLowerCase()).setOperational()
    ).nodeify(callback);
  }
  else {
    if ((self._data.length &gt; 0) &amp;&amp; (self._data[0].length &gt; self._index)) {
      var result = self._data[0][self._index++];
      if (result instanceof Error) {
        return Promise.reject(result).nodeify(callback);
      }
      else {
        // This could be possible if we get back batch with just one document?
        if (self._data[0].length === self._index) {
          self._index = 0;
          self._data.shift();
          if ((self._data.length === 1)
            &amp;&amp; (self._canFetch === true)
            &amp;&amp; (self._closed === false)
            &amp;&amp; (self._fetching === false)) {
              self._fetch();
          }
        }
        return Promise.resolve(result).nodeify(callback);
      }
    }
    else {
      return new Promise(function(resolve, reject) {
        self._pendingPromises.push({resolve: resolve, reject: reject});
      }).nodeify(callback);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.on" id="apidoc.element.rethinkdbdash.cursor.prototype.on">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit('end');
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// var r = require('rethinkdbdash')({servers: [{host: ..., port: ...}]});
```

2. Remove everything related to a connection:

```js
r.connect({host: ..., port: ...}).then(function(connection) {
  connection.<span class="apidocCodeKeywordSpan">on</span>('error', handleError);
  query.run(connection).then(function(result) {
    // console.log(result);
    connection.close();
  });
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.once" id="apidoc.element.rethinkdbdash.cursor.prototype.once">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit('end');
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.connection.removeAllListeners();
  self.open = false;
  self.emit('closed');
  // The connection is fully closed, flush (in case 'end' was not triggered)
  self._flush();
});
self.connection.setNoDelay();
self.connection.<span class="apidocCodeKeywordSpan">once</span>('error', function(error) {
  reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+'\nFull error:\n'+
JSON.stringify(error)).setOperational());
});
self.connection.on('connect', function() {
  self.connection.removeAllListeners('error');
  self.connection.on('error', function(error) {
    self.emit('error', error);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.removeAllListeners" id="apidoc.element.rethinkdbdash.cursor.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit('end');
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // We got a FIN packet, so we'll just flush
  self._flush();
});
self.connection.on('close', function() {
  // We emit end or close just once
  clearTimeout(self.timeoutOpen)
  clearInterval(self.pingIntervalId);
  self.connection.<span class="apidocCodeKeywordSpan">removeAllListeners</span>();
  self.open = false;
  self.emit('closed');
  // The connection is fully closed, flush (in case 'end' was not triggered)
  self._flush();
});
self.connection.setNoDelay();
self.connection.once('error', function(error) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.removeListener" id="apidoc.element.rethinkdbdash.cursor.prototype.removeListener">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit('end');
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.setIncludesStates" id="apidoc.element.rethinkdbdash.cursor.prototype.setIncludesStates">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>setIncludesStates
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setIncludesStates = function () {
  this._setIncludesStates = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      currentReject(new Err.ReqlDriverError('Unknown ResponseNote '+response.n[i]+', the driver is probably out of
 date.').setOperational());
      return;
    }
  }
}
cursor = new Cursor(self, token, self.metadata[token].options, typeResult);
if (includesStates === true) {
  cursor.<span class="apidocCodeKeywordSpan">setIncludesStates</span>();
}
if ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) &amp;&amp; (self.r.
_options.cursor === true))) {
  // Return a cursor
  if (self.metadata[token].options.profile === true) {
    currentResolve({
      profile: response.p,
      result: cursor
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.setMaxListeners" id="apidoc.element.rethinkdbdash.cursor.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit('end');
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.toArray" id="apidoc.element.rethinkdbdash.cursor.prototype.toArray">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>toArray
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function (callback) {
  var self = this;
  var p = new Promise(function(resolve, reject) {
    var result = [];
    var i =0;
    self._each(function(err, data) {
      if (err) {
        reject(err);
      }
      else {
        result.push(data);
      }
    }, function() {
      resolve(result);
    });
  }).nodeify(callback);
  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Cursors are coerced to arrays by default

```js
var r = require('rethinkdbdash')();
r.table('data').run().then(function(result) {
  assert(Array.isArray(result)) // true
  // With the official driver you need to call
  // result.<span class="apidocCodeKeywordSpan">toArray</span>().then(function(result2) {
  //   assert(Array.isArray(result2))
  // })
});
```

#### Drop in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.toJSON" id="apidoc.element.rethinkdbdash.cursor.prototype.toJSON">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  if (this._type === 'Cursor') {
    throw new Err.ReqlDriverError('You cannot serialize a Cursor to JSON. Retrieve data from the cursor with `toArray` or `next`');
  }
  else {
    throw new Err.ReqlDriverError('You cannot serialize a '+this._type+' to JSON. Retrieve data from the cursor with `each` or `
next`');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.toString" id="apidoc.element.rethinkdbdash.cursor.prototype.toString">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return '[object '+this._type+']';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.connection.on('error', function(error) {
  self.emit('error', error);
});

var versionBuffer = new Buffer(4)
versionBuffer.writeUInt32LE(protodef.VersionDummy.Version.V1_0, 0)

self.randomString = new Buffer(crypto.randomBytes(18)).<span class="apidocCodeKeywordSpan">toString</span>('base64')
var authBuffer = new Buffer(JSON.stringify({
  protocol_version: PROTOCOL_VERSION,
  authentication_method: AUTHENTIFICATION_METHOD,
  authentication: "n,,n=" + self.user + ",r=" + self.randomString
}));

helper.tryCatch(function() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.dequeue" id="apidoc.module.rethinkdbdash.dequeue">module rethinkdbdash.dequeue</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.dequeue" id="apidoc.element.rethinkdbdash.dequeue.dequeue">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>dequeue
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Dequeue(size) {
  this.start = 0;
  this.end = 0;

  size = size || 50;
  this.buffer = new Array(size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.dequeue.prototype" id="apidoc.module.rethinkdbdash.dequeue.prototype">module rethinkdbdash.dequeue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.delete" id="apidoc.element.rethinkdbdash.dequeue.prototype.delete">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>delete
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (index) {
  var current, next;
  if (this.start+index &gt;= this.buffer.length) {
    current = this.start+index-this.buffer.length;
    next = this.start+index-this.buffer.length+1;
  }
  else {
    current = this.start+index;
    next = this.start+index+1;
  }

  for(var i=index; i&lt;(this.buffer.length-index); i++) {
    if (next === this.buffer.length) next = 0;
    if (current === this.buffer.length) current = 0;

    this.buffer[current] = this.buffer[next];
    current++;
    next++;
  }

  this.end--;
  if (this.end &lt; 0) this.end = this.buffer.length-1
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    connection.on('error', function(error) {
// We are going to close connection, but we don't want another process to use it before
// So we remove it from the pool now (if it's inside)
self._log('Error emitted by a connection: '+JSON.stringify(error));
for(var i=0; i&lt;self.getAvailableLength(); i++) {
  if (self._pool.get(i) === this) {
    self._pool.<span class="apidocCodeKeywordSpan">delete</span>(i);
    self.emit('available-size', self._pool.getLength());
    self.emit('available-size-diff', -1);
    break;
  }
}
// We want to make sure that it's not going to try to reconnect
clearTimeout(connection.timeout);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.get" id="apidoc.element.rethinkdbdash.dequeue.prototype.get">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>get
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index) {
  if (this.start+index &gt; this.buffer.length) {
    return this.buffer[this.start+index-this.buffer.length]
  }
  else {
    return this.buffer[this.start+index]
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Connections are managed by the driver with an efficient connection pool.
Once you have imported the driver, you can immediately run queries,
you don't need to call `r.connect`, or pass a connection to `run`.

```js
var r = require('rethinkdbdash')();
r.table('users').<span class="apidocCodeKeywordSpan">get</span>('orphee@gmail.com').run().then(function(user
) {
  // ...
}).error(handleError)
```

- Cursors are coerced to arrays by default

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.getLength" id="apidoc.element.rethinkdbdash.dequeue.prototype.getLength">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>getLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLength = function () {
  if (this.start &lt;= this.end) {
    return this.end-this.start;
  }
  else {
    return this.buffer.length-(this.start-this.end);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- `draining`: when `drain` is called
- `queueing`: when a query is added/removed from the queue (queries waiting for a connection), the size of the queue is provided
- `size`: when the number of connections changes, the number of connections is provided
- `available-size`: when the number of available connections changes, the number of available connections is provided

You can get the number of connections (opened or being opened).
```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">getLength</span>();
```

You can also get the number of available connections (idle connections, without
a query running on it).

```js
r.getPoolMaster().getAvailableLength();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.pop" id="apidoc.element.rethinkdbdash.dequeue.prototype.pop">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>pop
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function (element) {
  //TODO: Decrease size when possible/needed? This may not be
  //something we really need/want
  // Return the element in this.end-1
  if (this.getLength() &gt; 0) {
    var pos = this.end-1;
    if (pos &lt; 0) pos = this.buffer.length-1;
    this.end = pos;
    var result = this.buffer[pos];
    this.buffer[pos] = undefined;
    return result;
  }
  else {
    return undefined
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Pool.prototype.getConnection = function() {
  var self = this;
  var p = new Promise(function(resolve, reject) {
if (self._draining === true) {
  return reject(new Err.ReqlDriverError('The pool is being drained').setOperational());
}

var connection = self._pool.<span class="apidocCodeKeywordSpan">pop</span>();
self.emit('available-size', self._pool.getLength());
self.emit('available-size-diff', -1);

if (connection) {
  clearTimeout(connection.timeout);
  resolve(connection);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.push" id="apidoc.element.rethinkdbdash.dequeue.prototype.push">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>push
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (element) {
  // push on this.end and then increase this.end
  // this.end should NEVER be equal to this.buffer.length
  this.buffer[this.end] = element;
  this.end++;
  if (this.end === this.buffer.length) this.end = 0;

  if (this.start === this.end) {
    // Resize
    var previousBuffer = this.buffer;

    this.buffer = new Array(previousBuffer.length*2);

    var i, k = 0;
    for(i=this.start; i&lt;previousBuffer.length; i++) {
      this.buffer[k++] = previousBuffer[i];
    }
    for(i=0; i&lt;this.start; i++) {
      this.buffer[k++] = previousBuffer[i];
    }
    this.start = 0;
    this.end = previousBuffer.length;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          }
        }
        return Promise.resolve(result).nodeify(callback);
      }
    }
    else {
      return new Promise(function(resolve, reject) {
        self._pendingPromises.<span class="apidocCodeKeywordSpan">push</span>({resolve: resolve, reject: reject});
      }).nodeify(callback);
    }
  }
}
Cursor.prototype.hasNext = function() {
  throw new Error('The `hasNext` command has been removed in 1.13, please use `next`.')
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.shift" id="apidoc.element.rethinkdbdash.dequeue.prototype.shift">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>shift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function () {
  // Return the element in this.start

  if (this.getLength() &gt; 0) {
    var result = this.buffer[this.start];
    this.buffer[this.start] = undefined;
    this.start++;
    if (this.start === this.buffer.length) this.start = 0;
    return result;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (result instanceof Error) {
  return Promise.reject(result).nodeify(callback);
}
else {
  // This could be possible if we get back batch with just one document?
  if (self._data[0].length === self._index) {
    self._index = 0;
    self._data.<span class="apidocCodeKeywordSpan">shift</span>();
    if ((self._data.length === 1)
      &amp;&amp; (self._canFetch === true)
      &amp;&amp; (self._closed === false)
      &amp;&amp; (self._fetching === false)) {
        self._fetch();
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.toArray" id="apidoc.element.rethinkdbdash.dequeue.prototype.toArray">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>toArray
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function (index) {
  var result = [];
  for(var i=0; i&lt;this.getLength(); i++) {
    result.push(this.get(i));
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Cursors are coerced to arrays by default

```js
var r = require('rethinkdbdash')();
r.table('data').run().then(function(result) {
  assert(Array.isArray(result)) // true
  // With the official driver you need to call
  // result.<span class="apidocCodeKeywordSpan">toArray</span>().then(function(result2) {
  //   assert(Array.isArray(result2))
  // })
});
```

#### Drop in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.unshift" id="apidoc.element.rethinkdbdash.dequeue.prototype.unshift">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>unshift
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function (element) {
  // push on this.start-1 and then decrease this.start.
  // this.end should NEVER be equal to this.buffer.length

  var pos = this.start-1;
  if (pos &lt; 0) pos = this.buffer.length-1;

  this.buffer[pos] = element;
  this.start = pos;

  if (this.start === this.end) {
    //Resize
    var previousBuffer = this.buffer;

    this.buffer = new Array(previousBuffer.length*2);

    var i, k = 0;
    for(i=this.start; i&lt;previousBuffer.length; i++) {
      this.buffer[k++] = previousBuffer[i];
    }
    for(i=0; i&lt;this.start; i++) {
      this.buffer[k++] = previousBuffer[i];
    }
    this.start = 0;
    this.end = previousBuffer.length;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var result = {
str: '',
car: ''
  }
  var backtrace, currentFrame, underline;

  if (helper.isPlainObject(term[2])) {
//if ((currentFrame != null) &amp;&amp; (frames != null)) frames.<span class="apidocCodeKeywordSpan">unshift</span>(currentFrame
);

//underline = Array.isArray(frames) &amp;&amp; (frames.length === 0);
var underline = false;
//if (Array.isArray(frames)) currentFrame = frames.shift();

// This works before there is no prefix term than can be called with no normal argument but with an optarg
if (Array.isArray(term[1]) &amp;&amp; (term[1].length &gt; 1)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.error" id="apidoc.module.rethinkdbdash.error">module rethinkdbdash.error</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.ReqlClientError" id="apidoc.element.rethinkdbdash.error.ReqlClientError">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlClientError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReqlClientError(message) {
  Error.captureStackTrace(this, ReqlClientError);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  else if (type === responseTypes.CLIENT_ERROR) {
self.emit('release');

if (typeof self.metadata[token].reject === 'function') {
  currentResolve = self.metadata[token].resolve;
  currentReject = self.metadata[token].reject;
  self.metadata[token].removeCallbacks();
  currentReject(new Err.<span class="apidocCodeKeywordSpan">ReqlClientError</span>(helper.makeAtom(response), self.metadata[token
].query, response));
  if (typeof self.metadata[token].endReject !== 'function') {
    // No pending STOP query, we can delete
    delete self.metadata[token]
  }
}
else if (typeof self.metadata[token].endResolve === 'function') {
  currentResolve = self.metadata[token].endResolve;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.ReqlCompileError" id="apidoc.element.rethinkdbdash.error.ReqlCompileError">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlCompileError
        <span class="apidocSignatureSpan">(message, query, frames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReqlCompileError(message, query, frames) {
  Error.captureStackTrace(this, ReqlCompileError);
  this.message = message;

  if ((query != null) &amp;&amp; (frames)) {
    if ((this.message.length &gt; 0) &amp;&amp; (this.message[this.message.length-1] === '.')) {
      this.message = this.message.slice(0, this.message.length-1);
    }

    this.message += ' in:\n';

    frames = frames.b;
    if (frames) this.frames = frames.slice(0);
    //this.frames = JSON.stringify(frames, null, 2);

    var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});

    var queryLines = backtrace.str.split('\n');
    var carrotLines = backtrace.car.split('\n');

    for(var i=0; i&lt;queryLines.length; i++) {
      this.message += queryLines[i]+'\n';
      if (carrotLines[i].match(/\^/)) {
        var pos = queryLines[i].match(/[^\s]/);
        if ((pos) &amp;&amp; (pos.index)) {
          this.message += space(pos.index)+carrotLines[i].slice(pos.index)+'\n';
        }
        else {
          this.message += carrotLines[i]+'\n';
        }
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var currentResolve, currentReject;
var datum;
var options;

if (type === responseTypes.COMPILE_ERROR) {
  self.emit('release');
  if (typeof self.metadata[token].reject === 'function') {
    self.metadata[token].reject(new Err.<span class="apidocCodeKeywordSpan">ReqlCompileError</span>(helper.makeAtom(response), self
.metadata[token].query, response));
  }

  delete self.metadata[token]
}
else if (type === responseTypes.CLIENT_ERROR) {
  self.emit('release');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.ReqlDriverError" id="apidoc.element.rethinkdbdash.error.ReqlDriverError">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlDriverError
        <span class="apidocSignatureSpan">(message, query, secondMessage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReqlDriverError(message, query, secondMessage) {
  Error.captureStackTrace(this, ReqlDriverError);
  this.message = this.msg = message;

  if ((Array.isArray(query) &amp;&amp; (query.length &gt; 0)) || (!Array.isArray(query) &amp;&amp; query != null)) {
    if ((this.message.length &gt; 0) &amp;&amp; (this.message[this.message.length-1] === '.')) {
      this.message = this.message.slice(0, this.message.length-1);
    }

    this.message += ' after:\n';

    var backtrace = generateBacktrace(query, 0, null, [], {indent: 0, extra: 0});

    this.message += backtrace.str;
  }
  else {
    if (this.message[this.message.length-1] !== '?') this.message += '.';
  }
  if (secondMessage) this.message += '\n'+secondMessage;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Set default options - We have to save them in case the user tries to reconnect
if (!helper.isPlainObject(options)) options = {};
this.host = options.host || r._host;
this.port = options.port || r._port;
if (options.authKey != null) {
  if (options.user != null || options.password != null) {
    throw new Err.<span class="apidocCodeKeywordSpan">ReqlDriverError</span>('Cannot use both authKey and password');
  }
  this.user = r._user;
  this.password = options.authKey;
} else {
  if (options.user === undefined) {
    this.user = r._user;
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.ReqlRuntimeError" id="apidoc.element.rethinkdbdash.error.ReqlRuntimeError">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlRuntimeError
        <span class="apidocSignatureSpan">(message, query, frames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReqlRuntimeError(message, query, frames) {
  Error.captureStackTrace(this, ReqlRuntimeError);
  this.message = this.msg = message;

  if ((query != null) &amp;&amp; (frames)) {
    if ((this.message.length &gt; 0) &amp;&amp; (this.message[this.message.length-1] === '.')) {
      this.message = this.message.slice(0, this.message.length-1);
    }

    this.message += ' in:\n';

    frames = frames.b;
    if (frames) this.frames = frames.slice(0);
    //this.frames = JSON.stringify(frames, null, 2);

    var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});

    var queryLines = backtrace.str.split('\n');
    var carrotLines = backtrace.car.split('\n');

    for(var i=0; i&lt;queryLines.length; i++) {
      this.message += queryLines[i]+'\n';
      if (carrotLines[i].match(/\^/)) {
        var pos = queryLines[i].match(/[^\s]/);
        if ((pos) &amp;&amp; (pos.index)) {
          this.message += space(pos.index)+carrotLines[i].slice(pos.index)+'\n';
        }
        else {
          this.message += carrotLines[i]+'\n';
        }
      }
    }
  }
  //this.query = JSON.stringify(query, null, 2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  else if (type === responseTypes.RUNTIME_ERROR) {
var errorValue = helper.makeAtom(response);
var error;
// We don't want to release a connection if we just pinged it.
if (self.pendingPing === false || (errorValue !== PING_VALUE)) {
  self.emit('release');
  error = new Err.<span class="apidocCodeKeywordSpan">ReqlRuntimeError</span>(errorValue, self.metadata[token].query, response);
} else {
  error = new Err.ReqlRuntimeError(errorValue);
}

if (typeof self.metadata[token].reject === 'function') {
  currentResolve = self.metadata[token].resolve;
  currentReject = self.metadata[token].reject;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.ReqlServerError" id="apidoc.element.rethinkdbdash.error.ReqlServerError">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlServerError
        <span class="apidocSignatureSpan">(message, query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReqlServerError(message, query) {
  Error.captureStackTrace(this, ReqlServerError);
  this.message = this.msg = message;

  if ((Array.isArray(query) &amp;&amp; (query.length &gt; 0)) || (!Array.isArray(query) &amp;&amp; query != null)) {
    if ((this.message.length &gt; 0) &amp;&amp; (this.message[this.message.length-1] === '.')) {
      this.message = this.message.slice(0, this.message.length-1);
    }

    this.message += ' for:\n';

    var backtrace = generateBacktrace(query, 0, null, [], {indent: 0, extra: 0});

    this.message += backtrace.str;
  }
  else {
    if (this.message[this.message.length-1] !== '?') this.message += '.';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Connection.prototype._isOpen = function() {
return this.open;
}

Connection.prototype._flush = function() {
helper.loopKeys(this.metadata, function(metadata, key) {
  if (typeof metadata[key].reject === 'function') {
    metadata[key].reject(new Err.<span class="apidocCodeKeywordSpan">ReqlServerError</span>(
          'The connection was closed before the query could be completed.',
          metadata[key].query));
  }
  if (typeof metadata[key].endReject === 'function') {
    metadata[key].endReject(new Err.ReqlServerError(
          'The connection was closed before the query could be completed.',
          metadata[key].query));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.generateBacktrace" id="apidoc.element.rethinkdbdash.error.generateBacktrace">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>generateBacktrace
        <span class="apidocSignatureSpan">(term, index, father, frames, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateBacktrace(term, index, father, frames, options) {
  var result = {
    str: '',
    car: ''
  }
  var backtrace, currentFrame, underline;

  // frames = null -&gt; do not underline
  // frames = [] -&gt; underline

  if (Array.isArray(term)) {
    if (term.length === 0) {
      var underline = Array.isArray(frames) &amp;&amp; (frames.length === 0);
      carify(result, 'undefined', underline);
    }
    else if (specialType[term[0]]) {
      backtrace = specialType[term[0]](term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
    else if (nonPrefix[term[0]]) {
      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
    else { // normal type -- this.&lt;method&gt;( this.args... )
      backtrace = generateNormalBacktrace(term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
  }
  else if (term !== undefined) {
    backtrace = specialType[termTypes.DATUM](term, index, father, frames, options);

    result.str = backtrace.str;
    result.car = backtrace.car;
  }
  else {
    //throw new Error('The driver should never enter this condition. Please report the query to the developers -- End 2')
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return this.run().finally(handler);
}
Term.prototype.delay = function(msecs) {
return this.run().delay(msecs);
}

Term.prototype.toString = function() {
return Error.<span class="apidocCodeKeywordSpan">generateBacktrace</span>(this._query, 0, null, [], {indent: 0, extra: 0}).str;
}

Term.prototype._wrap = function() {
var self = this;
if (helper.hasImplicit(this._query)) {
  if (this._query[0] === termTypes.ARGS) {
    throw new Error.ReqlDriverError('Implicit variable `r.row` cannot be used inside `r.args`')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.setOperational" id="apidoc.element.rethinkdbdash.error.setOperational">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>setOperational
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOperational = function (error) {
  error[IS_OPERATIONAL] = true;
  return error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

self.connection.setKeepAlive(true);

self.timeoutOpen = setTimeout(function() {
  self.connection.end(); // Send a FIN packet
  reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+' in less than '+
self.timeoutConnect+'s').<span class="apidocCodeKeywordSpan">setOperational</span>());
}, self.timeoutConnect*1000);

self.connection.on('end', function() {
  self.open = false;
  self.emit('end');
  // We got a FIN packet, so we'll just flush
  self._flush();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.helper" id="apidoc.module.rethinkdbdash.helper">module rethinkdbdash.helper</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.changeProto" id="apidoc.element.rethinkdbdash.helper.changeProto">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>changeProto
        <span class="apidocSignatureSpan">(object, other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function changeProto(object, other) {
  object.__proto__ = other.__proto__;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var term = function(field) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, '(...)', self);
  }
  return term.bracket(field);
}
helper.<span class="apidocCodeKeywordSpan">changeProto</span>(term, self);

if (value === undefined) {
  term._query = [];
}
else {
  term._query = value;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.compareDigest" id="apidoc.element.rethinkdbdash.helper.compareDigest">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>compareDigest
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareDigest(a, b) {
  var left = undefined
  var right = b
  var result = undefined
  if (a.length === b.length) {
    left = a
    result = 0
  } else {
    left = b
    result = 1
  }
  var len = Math.min(a.length, b.length);
  for(var i=0; i&lt;len; i++) {
    result |= a[i] ^b[i]
  }
  return result === 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Connection.prototype._compareDigest = function(messageServer, resolve, reject) {
var self = this;
var firstEquals = messageServer.authentication.indexOf('=')
var serverSignatureValue = messageServer.authentication.slice(firstEquals+1)

if (!helper.<span class="apidocCodeKeywordSpan">compareDigest</span>(serverSignatureValue, self.serverSignature.toString("base64
"))) {
  reject(new Err.ReqlDriverError('Invalid server signature').setOperational());
}

self.state = 4
self.connection.removeAllListeners('error');
self.open = true;
self.connection.on('error', function(e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.createLogger" id="apidoc.element.rethinkdbdash.helper.createLogger">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>createLogger
        <span class="apidocSignatureSpan">(poolMaster, silent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLogger(poolMaster, silent) {
  return function(message) {
    if (silent !== true) {
      console.error(message);
    }
    poolMaster.emit('log', message);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self._index = 0; // next pool to used
self._indexUnknown =  0 // next unknown pool to used
self._discovery = (typeof options.discovery === 'boolean') ? options.discovery: false; // Whether the pool master is in
 discovery mode or not
//self._refresh = (typeof options.refresh === 'number') ? options.refresh: 1000*60*60; // Refresh rate for the list of
 servers
self._options = options;
self._options.buffer = options.buffer || 50;
self._options.max = options.max || 1000;
self._log = helper.<span class="apidocCodeKeywordSpan">createLogger</span>(self, options.silent || false);
self._draining = false;
self._numConnections = 0;
self._numAvailableConnections = 0;
self._hasPrintWarningLocalhost = false;
self._feed = null;
self._consecutiveFails = -1;
self._timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.getCanonicalAddress" id="apidoc.element.rethinkdbdash.helper.getCanonicalAddress">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>getCanonicalAddress
        <span class="apidocSignatureSpan">(addresses)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCanonicalAddress(addresses) {
  // We suppose that the addresses are all valid, and therefore use loose regex
  for(var i=0; i&lt;addresses.length; i++) {
    var addresse = addresses[i];
    if ((/^127(\.\d{1,3}){3}$/.test(addresse.host)) || (/0?:?0?:?0?:?0?:?0?:?0?:0?:1/.test(addresse.host))) {
      addresse.value = 0;
    }
    else if ((net.isIPv6(addresse.host)) &amp;&amp; (/^[fF]|[eE]80:.*\:.*\:/.test(addresse.host))) {
      addresse.value = 1;
    }
    else if (/^169\.254\.\d{1,3}\.\d{1,3}$/.test(addresse.host)) {
      addresse.value = 2;
    }
    else if (/^192\.168\.\d{1,3}\.\d{1,3}$/.test(addresse.host)) {
      addresse.value = 3;
    }
    else if (/^172\.(1\d|2\d|30|31)\.\d{1,3}\.\d{1,3}$/.test(addresse.host)) {
      addresse.value = 4;
    }
    else if (/^10(\.\d{1,3}){3}$/.test(addresse.host)) {
      addresse.value = 5;
    }
    else if ((net.isIPv6(addresse.host)) &amp;&amp; (/^[fF]|[cCdD].*\:.*\:/.test('addresse.host'))) {
      addresse.value = 6;
    }
    else {
      addresse.value = 7;
    }
  }
  var result = addresses[0];
  var max = addresses[0].value;
  for(var i=0; i&lt;addresses.length; i++) {
    if (addresses[i].value &gt; max) {
      result = addresses[i];
      max = addresses[i].value;
    }
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) &amp;&amp;
      helper.localhostAliases.hasOwnProperty(pool.options.connection.host))) &amp;&amp;
      (server.network.reql_port === pool.options.connection.port)) {

      self._pools[server.id] = self._pools[UNKNOWN_POOLS].splice(j, 1)[0];
      // We may assign the wrong pool to this server if it's maching on localhost
      if (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host)) {
        self._pools[server.id].options.connection.host = helper.<span class="apidocCodeKeywordSpan">getCanonicalAddress</span>(server
.network.canonical_addresses).host;
        self._pools[server.id].drainLocalhost();
      }
      found = true;
      break;
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.hasImplicit" id="apidoc.element.rethinkdbdash.helper.hasImplicit">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>hasImplicit
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasImplicit(arg) {
  if (Array.isArray(arg)) {
    if (arg[0] === termTypes.IMPLICIT_VAR) return true;

    if (Array.isArray(arg[1])) {
      for(var i=0; i&lt;arg[1].length; i++) {
        if (hasImplicit(arg[1][i])) return true;
      }
    }
    if (isPlainObject(arg[2])) {
      for(var key in arg[2]) {
        if (hasImplicit(arg[2][key])) return true;
      }
    }
  }
  else if (isPlainObject(arg)) {
    for(var key in arg) {
      if (hasImplicit(arg[key])) return true;
    }
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  car: ''
};
var backtrace, underline, currentFrame;

var underline = Array.isArray(frames) &amp;&amp; (frames.length === 0);
if (Array.isArray(frames)) currentFrame = frames.shift();

if ((term[1][0][1].length === 1) &amp;&amp; (helper.<span class="apidocCodeKeywordSpan">hasImplicit</span>(term[1][1]))) {
  if ((currentFrame != null) &amp;&amp; (currentFrame === 1)) {
    backtrace = generateBacktrace(term[1][1], 1, term, frames, options);
  }
  else {
    backtrace = generateBacktrace(term[1][1], 1, term, null, options);
  }
  result.str = backtrace.str;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.isPlainObject" id="apidoc.element.rethinkdbdash.helper.isPlainObject">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>isPlainObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function Connection(r, options, resolve, reject) {
var self = this;
this.r = r;
this.state = 0; // Track the progress of the handshake. -1 will be used for an error state.

// Set default options - We have to save them in case the user tries to reconnect
if (!helper.<span class="apidocCodeKeywordSpan">isPlainObject</span>(options)) options = {};
this.host = options.host || r._host;
this.port = options.port || r._port;
if (options.authKey != null) {
  if (options.user != null || options.password != null) {
    throw new Err.ReqlDriverError('Cannot use both authKey and password');
  }
  this.user = r._user;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.loopKeys" id="apidoc.element.rethinkdbdash.helper.loopKeys">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>loopKeys
        <span class="apidocSignatureSpan">(obj, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loopKeys(obj, fn) {
  var keys = Object.keys(obj);
  var result;
  var keysLength = keys.length;
  for(var i=0; i&lt;keysLength; i++) {
    result = fn(obj, keys[i]);
    if (result === false) return;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var tlsOptions = options.ssl || false;
  if (tlsOptions === false) {
    self.connection = net.connect(connectionArgs);
  } else {
    if (helper.isPlainObject(tlsOptions)) {
      // Copy the TLS options in connectionArgs
      helper.<span class="apidocCodeKeywordSpan">loopKeys</span>(tlsOptions, function(tlsOptions, key) {
        connectionArgs[key] = tlsOptions[key];
      });
    }
    self.connection = tls.connect(connectionArgs);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.makeAtom" id="apidoc.element.rethinkdbdash.helper.makeAtom">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>makeAtom
        <span class="apidocSignatureSpan">(response, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function makeAtom(response, options) {
  options = options || {};
  return recursivelyConvertPseudotype(response.r[0], options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var currentResolve, currentReject;
var datum;
var options;

if (type === responseTypes.COMPILE_ERROR) {
  self.emit('release');
  if (typeof self.metadata[token].reject === 'function') {
    self.metadata[token].reject(new Err.ReqlCompileError(helper.<span class="apidocCodeKeywordSpan">makeAtom</span>(response), self
.metadata[token].query, response));
  }

  delete self.metadata[token]
}
else if (type === responseTypes.CLIENT_ERROR) {
  self.emit('release');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.makeSequence" id="apidoc.element.rethinkdbdash.helper.makeSequence">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>makeSequence
        <span class="apidocSignatureSpan">(response, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function makeSequence(response, options) {
  options = options || {};
  return recursivelyConvertPseudotype(response.r, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Cursor.prototype._push = function(data) {
  var couldfetch = this._canFetch;
  if (data.done) this._done();
  var response = data.response;
  this._fetching = false;
  // If the cursor was closed, we ignore all following response
  if ((response.r.length &gt; 0) &amp;&amp; (couldfetch === true)) {
    this._data.push(helper.<span class="apidocCodeKeywordSpan">makeSequence</span>(response, this.options));
  }
  // this._fetching = false
  if ((this._closed === false) &amp;&amp; (this._canFetch) &amp;&amp; (this._data.length &lt;= 1)) this._fetch();
  this._flush();
}
// Try to solve as many pending promises as possible
Cursor.prototype._flush = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.splitCommaEqual" id="apidoc.element.rethinkdbdash.helper.splitCommaEqual">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>splitCommaEqual
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function splitCommaEqual(message) {
  var result = {};
  var messageParts = message.split(',');
  for(var i=0; i&lt;messageParts.length; i++) {
    var equalPosition = messageParts[i].indexOf("=")
    result[messageParts[i].slice(0, equalPosition)] = messageParts[i].slice(equalPosition+1);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  reject(new Err.ReqlDriverError('Unsupported protocol version: '+PROTOCOL_VERSION+', expected between '+minVersion
+' and '+ maxVersion).setOperational());
}
this.state = 1;
};

Connection.prototype._computeSaltedPassword = function(messageServer, reject) {
var self = this;
var authentication = helper.<span class="apidocCodeKeywordSpan">splitCommaEqual</span>(messageServer.authentication);

var randomNonce = authentication.r
var salt = new Buffer(authentication.s, 'base64')
var iterations = parseInt(authentication.i)

if (randomNonce.substr(0, self.randomString.length) !== self.randomString) {
  self._abort();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.toArray" id="apidoc.element.rethinkdbdash.helper.toArray">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>toArray
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toArray(args) {
  return Array.prototype.slice.call(args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Cursors are coerced to arrays by default

```js
var r = require('rethinkdbdash')();
r.table('data').run().then(function(result) {
  assert(Array.isArray(result)) // true
  // With the official driver you need to call
  // result.<span class="apidocCodeKeywordSpan">toArray</span>().then(function(result2) {
  //   assert(Array.isArray(result2))
  // })
});
```

#### Drop in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.tryCatch" id="apidoc.element.rethinkdbdash.helper.tryCatch">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>tryCatch
        <span class="apidocSignatureSpan">(toTry, handleError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryCatch(toTry, handleError) {
  try{
  toTry()
  }
  catch(err) {
  handleError(err)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.randomString = new Buffer(crypto.randomBytes(18)).toString('base64')
var authBuffer = new Buffer(JSON.stringify({
  protocol_version: PROTOCOL_VERSION,
  authentication_method: AUTHENTIFICATION_METHOD,
  authentication: "n,,n=" + self.user + ",r=" + self.randomString
}));

helper.<span class="apidocCodeKeywordSpan">tryCatch</span>(function() {
  self.connection.write(Buffer.concat([versionBuffer, authBuffer, NULL_BUFFER]));
}, function(err) {
  // The TCP connection is open, but the ReQL connection wasn't established.
  // We can just abort the whole thing
  self.open = false;
  reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational
());
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.xorBuffer" id="apidoc.element.rethinkdbdash.helper.xorBuffer">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>xorBuffer
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xorBuffer(a, b) {
  var result = [];
  var len = Math.min(a.length, b.length)
  for(var i=0; i&lt;len; i++) {
    result.push(a[i] ^ b[i]);
  }
  return new Buffer(result);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var authMessage =
    "n=" + this.user + ",r=" + this.randomString + "," +
    authentication + "," +
    clientFinalMessageWithoutProof

var clientSignature = crypto.createHmac("sha256", storedKey).update(authMessage).digest()
var clientProof = helper.<span class="apidocCodeKeywordSpan">xorBuffer</span>(clientKey, clientSignature)

var serverKey = crypto.createHmac("sha256", saltedPassword).update("Server Key").digest()
this.serverSignature = crypto.createHmac("sha256", serverKey).update(authMessage).digest()

this.state = 2
var message = JSON.stringify({
  authentication: clientFinalMessageWithoutProof + ",p=" + clientProof.toString("base64")
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.metadata" id="apidoc.module.rethinkdbdash.metadata">module rethinkdbdash.metadata</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata.metadata" id="apidoc.element.rethinkdbdash.metadata.metadata">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>metadata
        <span class="apidocSignatureSpan">(resolve, reject, query, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Metadata(resolve, reject, query, options) {
  this.resolve = resolve;
  this.reject = reject;
  this.query = query; // The query in case we have to build a backtrace
  this.options = options || {};
  this.cursor = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.metadata.prototype" id="apidoc.module.rethinkdbdash.metadata.prototype">module rethinkdbdash.metadata.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata.prototype.removeCallbacks" id="apidoc.element.rethinkdbdash.metadata.prototype.removeCallbacks">
        function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>removeCallbacks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeCallbacks = function () {
  this.resolve = null;
  this.reject = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  else if (type === responseTypes.CLIENT_ERROR) {
self.emit('release');

if (typeof self.metadata[token].reject === 'function') {
  currentResolve = self.metadata[token].resolve;
  currentReject = self.metadata[token].reject;
  self.metadata[token].<span class="apidocCodeKeywordSpan">removeCallbacks</span>();
  currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));
  if (typeof self.metadata[token].endReject !== 'function') {
    // No pending STOP query, we can delete
    delete self.metadata[token]
  }
}
else if (typeof self.metadata[token].endResolve === 'function') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata.prototype.removeEndCallbacks" id="apidoc.element.rethinkdbdash.metadata.prototype.removeEndCallbacks">
        function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>removeEndCallbacks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeEndCallbacks = function () {
  this.endResolve = null;
  this.endReject = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // No pending STOP query, we can delete
    delete self.metadata[token]
  }
}
else if (typeof self.metadata[token].endResolve === 'function') {
  currentResolve = self.metadata[token].endResolve;
  currentReject = self.metadata[token].endReject;
  self.metadata[token].<span class="apidocCodeKeywordSpan">removeEndCallbacks</span>();
  currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));
  delete self.metadata[token]
}
else if (token === -1) { // This should not happen now since 1.13 took the token out of the query
  var error = new Err.ReqlClientError(helper.makeAtom(response)+'\nClosing all outstanding queries...');
  self.emit('error', error);
  // We don't want a function to yield forever, so we just reject everything
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata.prototype.setCallbacks" id="apidoc.element.rethinkdbdash.metadata.prototype.setCallbacks">
        function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>setCallbacks
        <span class="apidocSignatureSpan">(resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setCallbacks = function (resolve, reject) {
  this.resolve = resolve;
  this.reject = reject;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!self.metadata[token]) {
    self.metadata[token] = new Metadata(resolve, reject, originalQuery, options);
  }
  else if (end === true) {
    self.metadata[token].setEnd(resolve, reject);
  }
  else {
    self.metadata[token].<span class="apidocCodeKeywordSpan">setCallbacks</span>(resolve, reject);
  }
}
else {
  if (typeof resolve === 'function') resolve();
  this.emit('release');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata.prototype.setCursor" id="apidoc.element.rethinkdbdash.metadata.prototype.setCursor">
        function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>setCursor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setCursor = function () {
  this.cursor = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata.prototype.setEnd" id="apidoc.element.rethinkdbdash.metadata.prototype.setEnd">
        function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>setEnd
        <span class="apidocSignatureSpan">(resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEnd = function (resolve, reject) {
  this.endResolve = resolve;
  this.endReject = reject;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// noreply instead of noReply because the otpions are translated for the server
if ((!helper.isPlainObject(options)) || (options.noreply != true)) {
  if (!self.metadata[token]) {
    self.metadata[token] = new Metadata(resolve, reject, originalQuery, options);
  }
  else if (end === true) {
    self.metadata[token].<span class="apidocCodeKeywordSpan">setEnd</span>(resolve, reject);
  }
  else {
    self.metadata[token].setCallbacks(resolve, reject);
  }
}
else {
  if (typeof resolve === 'function') resolve();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.pool" id="apidoc.module.rethinkdbdash.pool">module rethinkdbdash.pool</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.pool" id="apidoc.element.rethinkdbdash.pool.pool">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool
        <span class="apidocSignatureSpan">(r, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pool(r, options) {
  this._r = r;

  if (!helper.isPlainObject(options)) options = {};
  this.options = {};
  this.options.max = options.max || 1000; // 4000 is about the maximum the kernel can take
  var buffer = (typeof options.buffer === 'number') ? options.buffer : 50;
  this.options.buffer = (buffer &lt; this.options.max) ? buffer : this.options.max;
  this.options.timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed
?
  this.options.timeoutGb = options.timeoutGb || 60*60*1000; // Default timeout for TCP connection is 2 hours on Linux, we time out
 after one hour.
  this.options.maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError

  this.options.silent = options.silent || false;

  this.options.connection = {
    host: options.host || this._r._host,
    port: options.port || this._r._port,
    db: options.db || this._r._db,
    timeout: options.timeout || this._r._timeoutConnect,
    authKey: options.authKey,
    user: options.user,
    password: options.password,
    cursor: options.cursor || false,
    stream: options.stream || false,
    ssl: options.ssl || false,
    pingInterval: options.pingInterval || this._r._pingInterval
  }
  this._log = options._log;

  this._pool = new Dequeue(this.options.buffer+1);
  this._draining = false;
  this._drainingHandlers = null; // Store the resolve/reject methods once draining is called
  this._localhostToDrain = 0; // number of connections to "localhost" to remove
  this._connectionToReplace = 0; // number of connections to "localhost" to remove

  this._numConnections = 0;
  this._openingConnections = 0; // Number of connections being opened
  this._consecutiveFails = 0;   // In slow growth, the number of consecutive failures to open a connection
  this._slowGrowth = false;     // Opening one connection at a time
  this._slowlyGrowing = false;  // The next connection to be returned is one opened in slowGrowth mode
  this._extraConnections = 0; // Number of extra connections being opened that we should eventually close

  this._empty = true;

  var self = this;
  // So we can let the pool master bind listeners
  setTimeout(function() {
    if (self._draining === false) {
      for(var i=0; i&lt;self.options.buffer; i++) {
        if (self.getLength() &lt; self.options.max) {
          self.createConnection();
        }
      }
    }
  }, 0);
  this.id = Math.floor(Math.random()*100000);
  this._log('Creating a pool connected to '+this.getAddress());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.super_" id="apidoc.element.rethinkdbdash.pool.super_">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.pool.prototype" id="apidoc.module.rethinkdbdash.pool.prototype">module rethinkdbdash.pool.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype._aggressivelyExpandBuffer" id="apidoc.element.rethinkdbdash.pool.prototype._aggressivelyExpandBuffer">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_aggressivelyExpandBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_aggressivelyExpandBuffer = function () {
  for(var i=0; i&lt;this.options.buffer; i++) {
    this._expandBuffer();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
// Need another flag
else if ((self._slowlyGrowing === true) &amp;&amp; (self._slowGrowth === true) &amp;&amp; (self._consecutiveFails &gt; 0)) {
  self._log('Exiting slow growth mode');
  self._consecutiveFails = 0;
  self._slowGrowth = false;
  self._slowlyGrowing = false;
  self.<span class="apidocCodeKeywordSpan">_aggressivelyExpandBuffer</span>();
}



connection.on('error', function(error) {
  // We are going to close connection, but we don't want another process to use it before
  // So we remove it from the pool now (if it's inside)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype._decreaseNumConnections" id="apidoc.element.rethinkdbdash.pool.prototype._decreaseNumConnections">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_decreaseNumConnections
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_decreaseNumConnections = function () {
  this._numConnections--;
  this.emit('size', this._numConnections)
  this.emit('size-diff', -1)
  if ((this._drainingHandlers !== null) &amp;&amp; (this._numConnections === 0)) {
    this._drainingHandlers.resolve();
  }
  // We do not check for this._empty === false because we want to emit empty if the pool
  // tries to connect to an unavailable server (such that the master can remove it from the
  // healthy pool
  if (this._numConnections === 0) {
    this._empty = true;
    this.emit('empty');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      self.emit('available-size', self._pool.getLength());
      self.emit('available-size-diff', -1);
      break;
    }
  }

  clearTimeout(connection.timeout);
  self.<span class="apidocCodeKeywordSpan">_decreaseNumConnections</span>();
  self._expandBuffer();
});
connection.on('timeout', function() {
  for(var i=0; i&lt;self.getAvailableLength(); i++) {
    if (self._pool.get(i) === this) {
      self._pool.delete(i);
      self.emit('available-size', self._pool.getLength());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype._expandBuffer" id="apidoc.element.rethinkdbdash.pool.prototype._expandBuffer">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_expandBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_expandBuffer = function () {
  if ((this._draining === false) &amp;&amp;
      (this._pool.getLength() &lt; this.options.buffer+this._localhostToDrain) &amp;&amp;
      (this._numConnections &lt; this.options.max+this._localhostToDrain)) {
    this.createConnection();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if ((self._numConnections === 0) &amp;&amp; (self._slowGrowth === true)) {
        // If the server is down we do not want to buffer the queries
        return reject(new Err.ReqlDriverError('The pool does not have any opened connections and failed to open a new one&amp;#
x27;).setOperational());
      }
    }

    if (self._slowGrowth === false) {
      self.<span class="apidocCodeKeywordSpan">_expandBuffer</span>();
    }

  });
  return p;
};

Pool.prototype._decreaseNumConnections = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype._increaseNumConnections" id="apidoc.element.rethinkdbdash.pool.prototype._increaseNumConnections">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_increaseNumConnections
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_increaseNumConnections = function () {
  this._numConnections++;
  this.emit('size', this._numConnections)
  this.emit('size-diff', 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
}
};

Pool.prototype.createConnection = function() {
var self = this;
self.<span class="apidocCodeKeywordSpan">_increaseNumConnections</span>();
self._openingConnections++;

self.emit('creating-connection', self);
if (self._draining === true) {
  return; // Do not create a new connection if we are draining the pool.
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.createConnection" id="apidoc.element.rethinkdbdash.pool.prototype.createConnection">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>createConnection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createConnection = function () {
  var self = this;
  self._increaseNumConnections();
  self._openingConnections++;

  self.emit('creating-connection', self);
  if (self._draining === true) {
    return; // Do not create a new connection if we are draining the pool.
  }

  return self._r.connect(self.options.connection).then(function(connection) {
    self.emit('created-connection', self);

    self._openingConnections--;

    if ((self._slowlyGrowing === false) &amp;&amp; (self._slowGrowth === true) &amp;&amp; (self._openingConnections === 0)) {
      self._consecutiveFails++;
      self._slowlyGrowing = true;
      self.timeoutReconnect = setTimeout(function() {
        self.createConnection();
        //self._expandBuffer();
      }, (1&lt;&lt;Math.min(self.options.maxExponent, self._consecutiveFails))*self.options.timeoutError);
    }
    // Need another flag
    else if ((self._slowlyGrowing === true) &amp;&amp; (self._slowGrowth === true) &amp;&amp; (self._consecutiveFails &gt; 0)) {
      self._log('Exiting slow growth mode');
      self._consecutiveFails = 0;
      self._slowGrowth = false;
      self._slowlyGrowing = false;
      self._aggressivelyExpandBuffer();
    }



    connection.on('error', function(error) {
      // We are going to close connection, but we don't want another process to use it before
      // So we remove it from the pool now (if it's inside)
      self._log('Error emitted by a connection: '+JSON.stringify(error));
      for(var i=0; i&lt;self.getAvailableLength(); i++) {
        if (self._pool.get(i) === this) {
          self._pool.delete(i);
          self.emit('available-size', self._pool.getLength());
          self.emit('available-size-diff', -1);
          break;
        }
      }
      // We want to make sure that it's not going to try to reconnect
      clearTimeout(connection.timeout);

      // Not sure what happened here, so let's be safe and close this connection.
      connection.close().then(function() {
        return self._expandBuffer();
      }).error(function(e) {
        // We failed to close this connection, but we removed it from the pool... so err, let's just ignore that.
        self._expandBuffer();
      });
    });
    connection.on('end', function(e) {
      // The connection was closed by the server, let's clean...
      for(var i=0; i&lt;self.getAvailableLength(); i++) {
        if (self._pool.get(i) === this) {
          self._pool.delete(i);
          self.emit('available-size', self._pool.getLength());
          self.emit('available-size-diff', -1);
          break;
        }
      }

      clearTimeout(connection.timeout);
      self._decreaseNumConnections();
      self._expandBuffer();
    });
    connection.on('timeout', function() {
      for(var i=0; i&lt;self.getAvailableLength(); i++) {
        if (self._pool.get(i) === this) {
          self._pool.delete(i);
          self.emit('available-size', self._pool.getLength());
          self.emit('available-size-diff', -1);
          break;
        }
      }

      clearTimeout(connection.timeout);
      self._decreaseNumConnections();
      self._expandBuffer();
    });
    connection.on('release', function() {
      if (this._isOpen()) self.putConnection(this);
    });
    self.putConnection(connection);
    return null;
  }).error(function(error) {
    // We failed to create a connection, we are now going to create connections one by one
    self._openingConnections--;
    self._decreaseNumConnections();

    self._slowGrowth = true;
    if (self._slowlyGrowing === false) {
      self._log('Entering slow growth mode');
    }
    self._slowlyGrowing = true;

    // Log an error
    self._log('Fail to create a new connection for the connection pool. Error:'+JSON.stringify(error));

    if (self._openingConnections === 0) {
      self._consecutiveFails++;
      self.timeoutReconnect = setTimeout(function() {
        //self._expandBuffer();
        self.createConnection();
      }, (1&lt;&lt;Math.min(self.options.maxExponent, self._consecutiveFails))*self.options.timeoutError);
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var self = this;
  // So we can let the pool master bind listeners
  setTimeout(function() {
    if (self._draining === false) {
      for(var i=0; i&lt;self.options.buffer; i++) {
        if (self.getLength() &lt; self.options.max) {
          self.<span class="apidocCodeKeywordSpan">createConnection</span>();
        }
      }
    }
  }, 0);
  this.id = Math.floor(Math.random()*100000);
  this._log('Creating a pool connected to '+this.getAddress());
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.drain" id="apidoc.element.rethinkdbdash.pool.prototype.drain">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>drain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drain = function () {
  var self = this;
  self._draining = true;
  self._log('Draining the pool connected to '+this.getAddress());
  self.emit('draining');
  var p = new Promise(function(resolve, reject) {
    var connection = self._pool.pop();
    self.emit('available-size', self._pool.getLength());
    self.emit('available-size-diff', -1);
    while(connection) {
      connection.close();
      clearTimeout(connection.timeout);
      connection = self._pool.pop();
    }
    if (self.timeoutReconnect !== undefined) {
      clearTimeout(self.timeoutReconnect);
      self.timeoutReconnect = null;
    }
    if (self.getLength() === 0) {
      resolve();
    }
    else {
      self._drainingHandlers = {
        resolve: resolve,
        reject: reject
      }
    }
  });
  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
is solved, this behavior may be changed in the future.

Because the connection pool will keep some connections available, a script will not
terminate. If you have finished executing your queries and want your Node.js script
to exit, you need to drain the pool with:

```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">drain</span>();
```

The pool master by default will log all errors/new states on `stderr`. If you do not
want to pollute `stderr`, pass `silent: true` when you import the driver. You can retrieve the
logs by binding a listener for the `log` event on the pool master.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.drainLocalhost" id="apidoc.element.rethinkdbdash.pool.prototype.drainLocalhost">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>drainLocalhost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drainLocalhost = function () {
  var self = this;
  // All the connections are to localhost, let's create new ones (not to localhost)
  self._connectionToReplace = self._numConnections;
  ;
  for(var i=0, numConnections=self._numConnections; i&lt;numConnections; i++) {
    self.createConnection().finally(function() {
      self._localhostToDrain++;
      self._connectionToReplace--;
      if ((self._connectionToReplace === 0) &amp;&amp; (self._localhostToDrain &gt; 0)) {
        var len = self._pool.getLength();
        for(var j=0; j&lt;len; j++) {
          if (self._localhostToDrain === 0) {
            break;
          }
          var _connection = self._pool.shift();
          if (helper.localhostAliases.hasOwnProperty(_connection.host)) {
            self._localhostToDrain--;
            _connection.close();
            clearTimeout(_connection.timeout);
          }
          else {
            self._pool.push(_connection);
          }
        }
      }

    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      helper.localhostAliases.hasOwnProperty(pool.options.connection.host))) &amp;&amp;
      (server.network.reql_port === pool.options.connection.port)) {

      self._pools[server.id] = self._pools[UNKNOWN_POOLS].splice(j, 1)[0];
      // We may assign the wrong pool to this server if it's maching on localhost
      if (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host)) {
        self._pools[server.id].options.connection.host = helper.getCanonicalAddress(server.network.canonical_addresses).host;
        self._pools[server.id].<span class="apidocCodeKeywordSpan">drainLocalhost</span>();
      }
      found = true;
      break;
    }
  }
}
if (found === false) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.getAddress" id="apidoc.element.rethinkdbdash.pool.prototype.getAddress">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getAddress
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAddress = function () {
  return this.options.connection.host+':'+this.options.connection.port;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       if (self.getLength() &lt; self.options.max) {
         self.createConnection();
       }
     }
   }
 }, 0);
 this.id = Math.floor(Math.random()*100000);
 this._log('Creating a pool connected to '+this.<span class="apidocCodeKeywordSpan">getAddress</span>());
}

util.inherits(Pool, events.EventEmitter);
/*
* Events:
*  - draining // when `drain` is called
*  - queueing(size of the queue) // the number of queries being beffered changed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.getAvailableLength" id="apidoc.element.rethinkdbdash.pool.prototype.getAvailableLength">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getAvailableLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableLength = function () {
  return this._pool.getLength();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
r.getPoolMaster().getLength();
```

You can also get the number of available connections (idle connections, without
a query running on it).

```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">getAvailableLength</span>();
```

You can also drain the pool as mentionned earlier with;

```js
r.getPoolMaster().drain();
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.getConnection" id="apidoc.element.rethinkdbdash.pool.prototype.getConnection">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getConnection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConnection = function () {
  var self = this;
  var p = new Promise(function(resolve, reject) {
    if (self._draining === true) {
      return reject(new Err.ReqlDriverError('The pool is being drained').setOperational());
    }

    var connection = self._pool.pop();
    self.emit('available-size', self._pool.getLength());
    self.emit('available-size-diff', -1);

    if (connection) {
      clearTimeout(connection.timeout);
      resolve(connection);
    }
    else {
      if ((self._numConnections === 0) &amp;&amp; (self._slowGrowth === true)) {
        // If the server is down we do not want to buffer the queries
        return reject(new Err.ReqlDriverError('The pool does not have any opened connections and failed to open a new one').setOperational
());
      }
    }

    if (self._slowGrowth === false) {
      self._expandBuffer();
    }

  });
  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Find a pool with available connections
var result;
for(var i=0; i&lt;self._healthyPools.length; i++) {
  if (self._index &gt;= self._healthyPools.length) {
    self._index = 0;
  }
  if (self._healthyPools[self._index].getAvailableLength() &gt; 0) {
    result = self._healthyPools[self._index].<span class="apidocCodeKeywordSpan">getConnection</span>();
  }
  self._index++;
  if (self._index === self._healthyPools.length) {
    self._index = 0;
  }
  if (result) {
    return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.getLength" id="apidoc.element.rethinkdbdash.pool.prototype.getLength">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLength = function () {
  return this._numConnections;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- `draining`: when `drain` is called
- `queueing`: when a query is added/removed from the queue (queries waiting for a connection), the size of the queue is provided
- `size`: when the number of connections changes, the number of connections is provided
- `available-size`: when the number of available connections changes, the number of available connections is provided

You can get the number of connections (opened or being opened).
```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">getLength</span>();
```

You can also get the number of available connections (idle connections, without
a query running on it).

```js
r.getPoolMaster().getAvailableLength();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.putConnection" id="apidoc.element.rethinkdbdash.pool.prototype.putConnection">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>putConnection
        <span class="apidocSignatureSpan">(connection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putConnection = function (connection) {
  var self = this;
  if (connection.end === false) {
    // Temporary attempt to fix #192 - this should not happen.
    return;
  }
  if (self._empty === true) {
    self._empty = false;
    // We emit not-empty only we have at least one opened connection
    self.emit('not-empty');
  }
  if ((self._localhostToDrain &gt; 0) &amp;&amp; (helper.localhostAliases.hasOwnProperty(connection.host))) {
    self._localhostToDrain--;
    connection.close();
    clearTimeout(connection.timeout);
    self.createConnection();
  }
  else if (self._drainingHandlers !== null) {
    connection.close();
    clearTimeout(connection.timeout);
    if (self.getLength() === 0) {
      self._drainingHandlers.resolve();
    }
  }
  else if (self._extraConnections &gt; 0) {
    self._extraConnections--;
    connection.close().error(function(error) {
      self._log('Fail to properly close a connection. Error:'+JSON.stringify(error));
    });
    clearTimeout(connection.timeout);
  }
<span class="apidocCodeCommentSpan">  /*
  // We let the pool garbage collect these connections
  else if (self.getAvailableLength()+1 &gt; self.options.buffer) { // +1 for the connection we may put back
    // Note that because we have available connections here, the pool master has no pending
    // queries.
    connection.close().error(function(error) {
      self._log('Fail to properly close a connection. Error:'+JSON.stringify(error));
    });
    clearTimeout(connection.timeout);
  }
  */
</span>  else {
    self._pool.push(connection);
    self.emit('available-size', self._pool.getLength());
    self.emit('available-size-diff', 1);
    self.emit('new-connection', connection);

    clearTimeout(connection.timeout);
    var timeoutCb = function() {
      if (self._pool.get(0) === connection) {
        if (self._pool.getLength() &gt; self.options.buffer) {
          self._pool.shift().close();
          self.emit('available-size', self._pool.getLength());
          self.emit('available-size-diff', -1);
        }
        else {
          connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
        }
      }
      else {
        // This should technically never happens
        connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
      }
    }
    connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    clearTimeout(connection.timeout);
    self._decreaseNumConnections();
    self._expandBuffer();
  });
  connection.on('release', function() {
    if (this._isOpen()) self.<span class="apidocCodeKeywordSpan">putConnection</span>(this);
  });
  self.putConnection(connection);
  return null;
}).error(function(error) {
  // We failed to create a connection, we are now going to create connections one by one
  self._openingConnections--;
  self._decreaseNumConnections();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.setOptions" id="apidoc.element.rethinkdbdash.pool.prototype.setOptions">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>setOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOptions = function (options) {
  if (helper.isPlainObject(options)) {
    for(var key in options) {
      this.options[key] = options[key];
    }
  }
  return this.options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.pool_master" id="apidoc.module.rethinkdbdash.pool_master">module rethinkdbdash.pool_master</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.pool_master" id="apidoc.element.rethinkdbdash.pool_master.pool_master">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool_master
        <span class="apidocSignatureSpan">(r, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PoolMaster(r, options) {
  var self = this;
  var options = options || {};
  var lineLength = options.buffer || 50;

  self._r = r;
  self._line = new Dequeue(lineLength);
  self._pools = {};
  self._pools[UNKNOWN_POOLS] = []; // pools for which we do not know the server'id
  self._healthyPools = [];
  self._healthy = false;
  self._init = false;
  self._index = 0; // next pool to used
  self._indexUnknown =  0 // next unknown pool to used
  self._discovery = (typeof options.discovery === 'boolean') ? options.discovery: false; // Whether the pool master is in discovery
 mode or not
  //self._refresh = (typeof options.refresh === 'number') ? options.refresh: 1000*60*60; // Refresh rate for the list of servers
  self._options = options;
  self._options.buffer = options.buffer || 50;
  self._options.max = options.max || 1000;
  self._log = helper.createLogger(self, options.silent || false);
  self._draining = false;
  self._numConnections = 0;
  self._numAvailableConnections = 0;
  self._hasPrintWarningLocalhost = false;
  self._feed = null;
  self._consecutiveFails = -1;
  self._timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?
  self._maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError

  //TODO
  //self._usingPool = true; // If we have used the pool
  self._seed = 0;

  var pool;
  if (Array.isArray(options.servers)) {
    if (options.servers.length &gt; 0) {
      self._servers = options.servers;
      for(var i=0; i&lt;options.servers.length; i++) {
        var settings = self.createPoolSettings(options, options.servers[i], self._log);
        pool = new Pool(self._r, settings);
        self._pools[UNKNOWN_POOLS].push(pool);
        // A pool is considered healthy by default such that people can do
        // var = require(...)(); query.run();
        self._healthyPools.push(pool);
        self.emitStatus()
      }
    }
    else {
      throw new Err.ReqlDriverError("If `servers` is an array, it must contain at least one server")
    }
  }
  else {
    self._servers = [{
      host: options.host || 'localhost',
      port: options.port || 28015
    }]
    var settings = self.createPoolSettings(options, {}, self._log);
    pool = new Pool(self._r, settings);
    self._pools[UNKNOWN_POOLS].push(pool);
    self._healthyPools.push(pool);
    self.emitStatus()
  }

  // Initialize all the pools - bind listeners
  for(var i=0; i&lt;self._pools[UNKNOWN_POOLS].length; i++) {
    self.initPool(self._pools[UNKNOWN_POOLS][i]);
  }
  if ((self._discovery === true)) {
    self._timeout = setTimeout(function() { self.fetchServers() }, 0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.super_" id="apidoc.element.rethinkdbdash.pool_master.super_">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.pool_master.prototype" id="apidoc.module.rethinkdbdash.pool_master.prototype">module rethinkdbdash.pool_master.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype._expandAll" id="apidoc.element.rethinkdbdash.pool_master.prototype._expandAll">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>_expandAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_expandAll = function () {
  for(var i=0; i&lt;this._healthyPools.length; i++) {
    this._healthyPools[i]._expandBuffer();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self._line.push({
      resolve: resolve,
      reject: reject
    });

    self.emit('queueing', self._line.getLength())
    // We could add a condition to be less greedy (for early start)
    self.<span class="apidocCodeKeywordSpan">_expandAll</span>();
  });

}
}
PoolMaster.prototype._expandAll = function() {
for(var i=0; i&lt;this._healthyPools.length; i++) {
  this._healthyPools[i]._expandBuffer();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype._flushErrors" id="apidoc.element.rethinkdbdash.pool_master.prototype._flushErrors">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>_flushErrors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flushErrors = function () {
  while(this._line.getLength() &gt; 0) {
    this._line.shift().reject(new Err.ReqlDriverError('None of the pools have an opened connection and failed to open a new one').
setOperational());
    this.emit('queueing', this._line.getLength())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (self._healthyPools[i] === this) {
      self._healthyPools.splice(i, 1);
      self.emitStatus()
      break;
    }
  }
  if (self._healthyPools.length === 0) {
    self.<span class="apidocCodeKeywordSpan">_flushErrors</span>();
  }

  self.resetBufferParameters();
});
pool.on('draining', function() {
  for(var i=0; i&lt;self._healthyPools.length; i++) {
    if (self._healthyPools[i] === this) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.createPool" id="apidoc.element.rethinkdbdash.pool_master.prototype.createPool">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>createPool
        <span class="apidocSignatureSpan">(server)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createPool = function (server) {
  var self = this;
  var address = helper.getCanonicalAddress(server.network.canonical_addresses);
  var settings = self.createPoolSettings(self._options, {
    port: server.network.reql_port,
    host: address.host
  }, self._log);
  var pool = new Pool(self._r, settings);
  self._pools[server.id] = pool
  self.initPool(pool);
  self._healthyPools.push(pool);
  self.emitStatus()
  self.resetBufferParameters();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          found = true;
          break;
        }
      }
    }
    if (found === false) {
      // We just found a new server, let's extract the canonical address and connect to it
      self.<span class="apidocCodeKeywordSpan">createPool</span>(server);
    }
  }
} // Each server know has a pool

// Check if we need to remove pools
helper.loopKeys(self._pools, function(pools, key) { // among the pools with a server id
  if (key !== UNKNOWN_POOLS) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.createPoolSettings" id="apidoc.element.rethinkdbdash.pool_master.prototype.createPoolSettings">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>createPoolSettings
        <span class="apidocSignatureSpan">(globalOptions, serverOptions, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createPoolSettings = function (globalOptions, serverOptions, log) {
  var settings = {};
  var numServers = Array.isArray(globalOptions.servers) ? globalOptions.servers.length: 1;
  helper.loopKeys(globalOptions, function(options, key) {
    if ((key === 'buffer') || (key === 'max')) {
      settings[key] = Math.ceil(options[key]/numServers);
      settings[key] = Math.ceil(options[key]/numServers);
    }
    else if (key !== 'servers') {
      settings[key] = options[key];
    }
  });
  if (serverOptions) {
    helper.loopKeys(serverOptions, function(options, key) {
      settings[key] = options[key];
    });
  }
  settings._log = log;
  return settings;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self._seed = 0;

var pool;
if (Array.isArray(options.servers)) {
  if (options.servers.length &gt; 0) {
    self._servers = options.servers;
    for(var i=0; i&lt;options.servers.length; i++) {
      var settings = self.<span class="apidocCodeKeywordSpan">createPoolSettings</span>(options, options.servers[i], self._log);
      pool = new Pool(self._r, settings);
      self._pools[UNKNOWN_POOLS].push(pool);
      // A pool is considered healthy by default such that people can do
      // var = require(...)(); query.run();
      self._healthyPools.push(pool);
      self.emitStatus()
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.deletePool" id="apidoc.element.rethinkdbdash.pool_master.prototype.deletePool">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>deletePool
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deletePool = function (key) {
  var self = this;
  var pool = self._pools[key];
  self._log('Removing pool connected to: '+pool.getAddress())
  pool.drain().then(function() {
    pool.removeAllListeners();
  }).error(function(error) {
    self._log('Pool connected to: '+self._pools[key].getAddress()+' could not be properly drained.')
    self._log(error.message);
    self._log(error.stack);
  });
  delete self._pools[key];
  self.resetBufferParameters();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
} // Each server know has a pool

// Check if we need to remove pools
helper.loopKeys(self._pools, function(pools, key) { // among the pools with a server id
  if (key !== UNKNOWN_POOLS) {
    if (knownServer.hasOwnProperty(key) === false) {
      self.<span class="apidocCodeKeywordSpan">deletePool</span>(key); // We just found a pool that doesn't map to any known
 RethinkDB server
    }
    else {
      knownServer[key].count++;
    }
  }
});
for(var i=0;i&lt;self._pools[UNKNOWN_POOLS].length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.drain" id="apidoc.element.rethinkdbdash.pool_master.prototype.drain">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>drain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drain = function () {
  this.emit('draining');
  if (this._discovery === true) {
    this._discovery = false;
    if (this._feed != null) {
      this._feed.close();
    }
  }
  this._draining = true;
  var promises = [];
  var pools = this.getPools();
  for(var i=0; i&lt;pools.length; i++) {
    promises.push(pools[i].drain());
  }
  this._healthyPools = [];
  var self = this;
  return Promise.all(promises).then(function() {
    for(var i=0; i&lt;pools.length; i++) {
      pools[i].removeAllListeners();
    }
  }).error(function(error) {
    if (self._options.silent !== true) {
      self._log('Failed to drain all the pools:');
      self._log(error.message);
      self._log(error.stack);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
is solved, this behavior may be changed in the future.

Because the connection pool will keep some connections available, a script will not
terminate. If you have finished executing your queries and want your Node.js script
to exit, you need to drain the pool with:

```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">drain</span>();
```

The pool master by default will log all errors/new states on `stderr`. If you do not
want to pollute `stderr`, pass `silent: true` when you import the driver. You can retrieve the
logs by binding a listener for the `log` event on the pool master.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.emitStatus" id="apidoc.element.rethinkdbdash.pool_master.prototype.emitStatus">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>emitStatus
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emitStatus = function () {
  var healthy = this._healthyPools.length !== 0;
  if (this._healthy !== healthy) {
    this._healthy = healthy;
    this.emit('healthy', healthy)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for(var i=0; i&lt;options.servers.length; i++) {
      var settings = self.createPoolSettings(options, options.servers[i], self._log);
      pool = new Pool(self._r, settings);
      self._pools[UNKNOWN_POOLS].push(pool);
      // A pool is considered healthy by default such that people can do
      // var = require(...)(); query.run();
      self._healthyPools.push(pool);
      self.<span class="apidocCodeKeywordSpan">emitStatus</span>()
    }
  }
  else {
    throw new Err.ReqlDriverError("If `servers` is an array, it must contain at least one server")
  }
}
else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.fetchServers" id="apidoc.element.rethinkdbdash.pool_master.prototype.fetchServers">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>fetchServers
        <span class="apidocSignatureSpan">(useSeeds)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchServers = function (useSeeds) {
  var self = this;
  var query = self._r.db('rethinkdb').table('server_status')
      .union([SEPARATOR])
      .union(self._r.db('rethinkdb').table('server_status').changes())
  // In case useSeeds is true, we rotate through all the seeds + the pool master
  if (!useSeeds || self._seed === self._servers.length) {
    if (useSeeds &amp;&amp; self._seed === self._servers.length) {
      // We increase the back off only when we went through all the seeds
      self._consecutiveFails++;
    }

    self._seed = 0;
    var promise = query.run({cursor: true})
  }
  else {
    var settings = self._servers[self._seed];
    self._seed++;
    var promise = self._r.connect(settings).then(function(connection) {
      return query.run(connection, {cursor: true})
    });
  }
  promise.then(function(feed) {
    if (self._draining === true) {
      // There is no need to close the feed here as we'll close the connections
      return feed.close();
    }
    self._feed = feed;
    var initializing = true;
    var servers = [];
    feed.each(function(err, change) {
      if (err) {
        self._log('The changefeed on server_status returned an error: '+err.toString());
        // We have to refetch everything as the server that was serving the feed may
        // have died.
        if (!self._draining) {
          setTimeout(function() {
            self.fetchServers();
          }, 0); // Give a timeout to let the driver clean the pools
        }
        return;
      }
      if (initializing === true) {
        if (change === SEPARATOR) {
          initializing = false;
          self.handleAllServersResponse(servers);
          // Rerun the whole query after to make sure that a change did not skip/sneak between the union. As long
          // as RethinkDB does not provide initial results
          setTimeout(function() {
            self._r.db('rethinkdb').table('server_status').run({cursor: false}).then(function(servers) {
              self.handleAllServersResponse(servers);
            }).error(function(error) {
              self._log('Fail to retrieve a second copy of server_status');
              //TODO Retry
            });
          }, 1000);
        }
        else {
          servers.push(change);
        }
        return;
      }

      if (change.new_val !== null &amp;&amp; change.old_val === null) {
        // New server
        self.createPool(change.new_val);
      }
      else if (change.new_val === null &amp;&amp; change.old_val !== null) {
        // A server was removed
        var server = change.old_val;
        if (self._pools[server.id] != null) {
          self.deletePool(server.id);
        }
        else {
          var found = false;
          for(var i=0; i&lt;self._pools[UNKNOWN_POOLS].length; i++) {
            if (((server.network.canonical_addresses[k].host === self._pools[UNKNOWN_POOLS][i].options.connection.host) ||
              (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) &amp;&amp; (helper.localhostAliases.hasOwnProperty
(self._pools[UNKNOWN_POOLS][i].options.connection.host)))) &amp;&amp;
              (server.network.reql_port === self._pools[UNKNOWN_POOLS][i].options.connection.port)) {
              found = true;

              (function (pool) {
                self._log('Removing pool connected to: '+pool.getAddress())
                var pool = self._pools[UNKNOWN_POOLS].splice(i, 1)[0];
                pool.drain().then(function() {
                  pool.removeAllListeners();
                }).error(function(error) {
                  if (self._options.silent !== true) {
                    self._log('Pool connected to: '+pool.getAddress()+' could not be properly drained.')
                    self._log(error.message);
                    self._log(error.stack);
                  }
                });
              })(self._pools[UNKNOWN_POOLS][i]);
              break;
            }
          }
        }
        if (found === false) {
          self._log('A server was removed but no pool for this server exists...')
        }
      }
      // We ignore this change since t ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Initialize all the pools - bind listeners
for(var i=0; i&lt;self._pools[UNKNOWN_POOLS].length; i++) {
  self.initPool(self._pools[UNKNOWN_POOLS][i]);
}
if ((self._discovery === true)) {
  self._timeout = setTimeout(function() { self.<span class="apidocCodeKeywordSpan">fetchServers</span>() }, 0);
}
}
util.inherits(PoolMaster, events.EventEmitter);

PoolMaster.prototype.getPools = function() {
var result = [];
helper.loopKeys(this._pools, function(pools, key) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.getAvailableLength" id="apidoc.element.rethinkdbdash.pool_master.prototype.getAvailableLength">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getAvailableLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableLength = function () {
  return this._numAvailableConnections;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
r.getPoolMaster().getLength();
```

You can also get the number of available connections (idle connections, without
a query running on it).

```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">getAvailableLength</span>();
```

You can also drain the pool as mentionned earlier with;

```js
r.getPoolMaster().drain();
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.getConnection" id="apidoc.element.rethinkdbdash.pool_master.prototype.getConnection">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getConnection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConnection = function () {
  var self = this;
  // Find a pool with available connections
  var result;
  for(var i=0; i&lt;self._healthyPools.length; i++) {
    if (self._index &gt;= self._healthyPools.length) {
      self._index = 0;
    }
    if (self._healthyPools[self._index].getAvailableLength() &gt; 0) {
      result = self._healthyPools[self._index].getConnection();
    }
    self._index++;
    if (self._index === self._healthyPools.length) {
      self._index = 0;
    }
    if (result) {
      return result;
    }
  }
  if (self._healthyPools.length === 0) {
    return new Promise(function(resolve, reject) {
      reject(new Err.ReqlDriverError('None of the pools have an opened connection and failed to open a new one').setOperational());
    });
  }
  else {
    // All pool are busy, buffer the request
    return new Promise(function(resolve, reject) {
      self._line.push({
        resolve: resolve,
        reject: reject
      });

      self.emit('queueing', self._line.getLength())
      // We could add a condition to be less greedy (for early start)
      self._expandAll();
    });

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Find a pool with available connections
var result;
for(var i=0; i&lt;self._healthyPools.length; i++) {
  if (self._index &gt;= self._healthyPools.length) {
    self._index = 0;
  }
  if (self._healthyPools[self._index].getAvailableLength() &gt; 0) {
    result = self._healthyPools[self._index].<span class="apidocCodeKeywordSpan">getConnection</span>();
  }
  self._index++;
  if (self._index === self._healthyPools.length) {
    self._index = 0;
  }
  if (result) {
    return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.getLength" id="apidoc.element.rethinkdbdash.pool_master.prototype.getLength">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLength = function () {
  return this._numConnections;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- `draining`: when `drain` is called
- `queueing`: when a query is added/removed from the queue (queries waiting for a connection), the size of the queue is provided
- `size`: when the number of connections changes, the number of connections is provided
- `available-size`: when the number of available connections changes, the number of available connections is provided

You can get the number of connections (opened or being opened).
```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">getLength</span>();
```

You can also get the number of available connections (idle connections, without
a query running on it).

```js
r.getPoolMaster().getAvailableLength();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.getNumAvailableConnections" id="apidoc.element.rethinkdbdash.pool_master.prototype.getNumAvailableConnections">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getNumAvailableConnections
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNumAvailableConnections = function () {
  var sum = 0;
  for(var i=0; i&lt;this._healthyPools.length; i++) {
    sum += this._healthyPools[i].getAvailableLength();
  }
  return sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.getNumConnections" id="apidoc.element.rethinkdbdash.pool_master.prototype.getNumConnections">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getNumConnections
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNumConnections = function () {
  var sum = 0;
  for(var i=0; i&lt;this._healthyPools.length; i++) {
    sum += this._healthyPools[i].getLength();
  }
  return sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.getPools" id="apidoc.element.rethinkdbdash.pool_master.prototype.getPools">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getPools
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPools = function () {
  var result = [];
  helper.loopKeys(this._pools, function(pools, key) {
    if (key === UNKNOWN_POOLS) {
      for(var i=0;i&lt;pools[key].length; i++) {
        result.push(pools[key][i]);
      }
    }
    else {
      result.push(pools[key]);
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
r.getPoolMaster().drain();
```

You can access all the pools with:
```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">getPools</span>();
```

The pool master emits the `healthy` when its state change. Its state is defined as:
- healthy when at least one pool is healthy: Queries can be immediately executed or will be queued.
- not healthy when no pool is healthy: Queries will immediately fail.

A pool being healthy is it has at least one available connection, or it was just
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.handleAllServersResponse" id="apidoc.element.rethinkdbdash.pool_master.prototype.handleAllServersResponse">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>handleAllServersResponse
        <span class="apidocSignatureSpan">(servers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleAllServersResponse = function (servers) {
  var self = this;
  if (self._draining === true) {
    return;
  }
  // Fill all the known server from RethinkDB
  var knownServer = {};
  for(var i=0; i&lt;servers.length; i++) {
    var server = servers[i];
    knownServer[server.id] = {count: 0, server: server};
    if (self._pools[server.id] === undefined) {
      // We potentially have a new server in the cluster, or we already have a pool for this server
      // in one of the UNKNOWN_POOLS
      var found = false;
      for(var j=0; j&lt;self._pools[UNKNOWN_POOLS].length; j++) {
        if (found) break;
        var pool = self._pools[UNKNOWN_POOLS][j];
        // If a pool is created with localhost, it will probably match the first server even though it may not the the one
        // So it gets an id
        for(var k=0; k&lt;server.network.canonical_addresses.length; k++) {
          // Check for the same host (or if they are both localhost) and port
          if (((server.network.canonical_addresses[k].host === pool.options.connection.host) ||
               (server.network.hostname === pool.options.connection.host) ||
            (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) &amp;&amp;
            helper.localhostAliases.hasOwnProperty(pool.options.connection.host))) &amp;&amp;
            (server.network.reql_port === pool.options.connection.port)) {

            self._pools[server.id] = self._pools[UNKNOWN_POOLS].splice(j, 1)[0];
            // We may assign the wrong pool to this server if it's maching on localhost
            if (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host)) {
              self._pools[server.id].options.connection.host = helper.getCanonicalAddress(server.network.canonical_addresses).host
;
              self._pools[server.id].drainLocalhost();
            }
            found = true;
            break;
          }
        }
      }
      if (found === false) {
        // We just found a new server, let's extract the canonical address and connect to it
        self.createPool(server);
      }
    }
  } // Each server know has a pool

  // Check if we need to remove pools
  helper.loopKeys(self._pools, function(pools, key) { // among the pools with a server id
    if (key !== UNKNOWN_POOLS) {
      if (knownServer.hasOwnProperty(key) === false) {
        self.deletePool(key); // We just found a pool that doesn't map to any known RethinkDB server
      }
      else {
        knownServer[key].count++;
      }
    }
  });
  for(var i=0;i&lt;self._pools[UNKNOWN_POOLS].length; i++) {
    // These pools does not match any server returned by RethinkDB.
    var pool = self._pools[UNKNOWN_POOLS].splice(i, 1)[0];
    self._log('Removing pool connected to: '+pool.getAddress())
    pool.drain().then(function() {
      pool.removeAllListeners();
    }).error(function(error) {
      self._log('Pool connected to: '+self._pools[UNKNOWN_POOLS][i].getAddress()+' could not be properly drained.')
      self._log(error.message);
      self._log(error.stack);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }, 0); // Give a timeout to let the driver clean the pools
  }
  return;
}
if (initializing === true) {
  if (change === SEPARATOR) {
    initializing = false;
    self.<span class="apidocCodeKeywordSpan">handleAllServersResponse</span>(servers);
    // Rerun the whole query after to make sure that a change did not skip/sneak between the union. As long
    // as RethinkDB does not provide initial results
    setTimeout(function() {
      self._r.db('rethinkdb').table('server_status').run({cursor: false}).then(function(servers) {
        self.handleAllServersResponse(servers);
      }).error(function(error) {
        self._log('Fail to retrieve a second copy of server_status');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.initPool" id="apidoc.element.rethinkdbdash.pool_master.prototype.initPool">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>initPool
        <span class="apidocSignatureSpan">(pool)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initPool = function (pool) {
  var self = this;

  pool.on('size-diff', function(diff) {
    self._numConnections += diff;
    self.emit('size', self._numConnections)
  });
  pool.on('available-size-diff', function(diff) {
    self._numAvailableConnections += diff;
    self.emit('available-size', self._numAvailableConnections)
  });

  pool.on('new-connection', function() {
    if (self._line.getLength() &gt; 0) {
      var p = self._line.shift();
      this.getConnection().then(p.resolve).error(p.reject);
      self.emit('queueing', self._line.getLength())
    }
  });
  pool.on('not-empty', function() {
    if (self._draining === false) {
      var found = false;
      for(var i=0; i&lt;self._healthyPools.length; i++) {
        if (self._healthyPools[i] === this) {
          self._healthyPools.length;
          found = true;
          break;
        }
      }
      if (found === false) {
        self._healthyPools.push(this);
        self.emitStatus()
        self.resetBufferParameters();
      }
    }
  });
  pool.on('empty', function() {
    // A pool that become empty is considered unhealthy
    for(var i=0; i&lt;self._healthyPools.length; i++) {
      if (self._healthyPools[i] === this) {
        self._healthyPools.splice(i, 1);
        self.emitStatus()
        break;
      }
    }
    if (self._healthyPools.length === 0) {
      self._flushErrors();
    }

    self.resetBufferParameters();
  });
  pool.on('draining', function() {
    for(var i=0; i&lt;self._healthyPools.length; i++) {
      if (self._healthyPools[i] === this) {
        self._healthyPools.splice(i, 1);
        self.emitStatus()
        break;
      }
    }

    if (self._healthyPools === 0) {
      self._flushErrors();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self._pools[UNKNOWN_POOLS].push(pool);
    self._healthyPools.push(pool);
    self.emitStatus()
  }

  // Initialize all the pools - bind listeners
  for(var i=0; i&lt;self._pools[UNKNOWN_POOLS].length; i++) {
    self.<span class="apidocCodeKeywordSpan">initPool</span>(self._pools[UNKNOWN_POOLS][i]);
  }
  if ((self._discovery === true)) {
    self._timeout = setTimeout(function() { self.fetchServers() }, 0);
  }
}
util.inherits(PoolMaster, events.EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.resetBufferParameters" id="apidoc.element.rethinkdbdash.pool_master.prototype.resetBufferParameters">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>resetBufferParameters
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetBufferParameters = function () {
  var max = Math.floor(this._options.max/this._healthyPools.length)
  var buffer = Math.floor(this._options.buffer/this._healthyPools.length)
  for(var i=0; i&lt;this._healthyPools.length; i++) {
    if (this._healthyPools[i].getLength() &gt; max) {
      this._healthyPools[i]._extraConnections = this._healthyPools[i].getLength()-max;
    }
    else {
      this._healthyPools[i]._extraConnections = 0;
    }
    this._healthyPools[i].options.max = max
    this._healthyPools[i].options.buffer = buffer;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  host: address.host
}, self._log);
var pool = new Pool(self._r, settings);
self._pools[server.id] = pool
self.initPool(pool);
self._healthyPools.push(pool);
self.emitStatus()
self.<span class="apidocCodeKeywordSpan">resetBufferParameters</span>();
}

// Delete a known pool
PoolMaster.prototype.deletePool = function(key) {
var self = this;
var pool = self._pools[key];
self._log('Removing pool connected to: '+pool.getAddress())
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.stream" id="apidoc.module.rethinkdbdash.stream">module rethinkdbdash.stream</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.stream" id="apidoc.element.rethinkdbdash.stream.stream">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>stream
        <span class="apidocSignatureSpan">(options, cursor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadableStream(options, cursor) {
  if (cursor) this._cursor = cursor;
  this._pending = 0; // How many time we called _read while no cursor was available
  this._index = 0;
  this._maxRecursion = 1000; // Hardcoded
  this._highWaterMark = options.highWaterMark;
  this._closed = false;

  Readable.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.super_" id="apidoc.element.rethinkdbdash.stream.super_">
        function <span class="apidocSignatureSpan">rethinkdbdash.stream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options &amp;&amp; typeof options.read === 'function')
    this._read = options.read;

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.stream.prototype" id="apidoc.module.rethinkdbdash.stream.prototype">module rethinkdbdash.stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.prototype._fetch" id="apidoc.element.rethinkdbdash.stream.prototype._fetch">
        function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fetch = function () {
  var self = this;
  if (self._closed === true) {
    return;
  }
  if (self._cursor._closed === true) {
    self.push(null);
  }
  else {
    self._cursor._next().then(function(data) {
      if (self._closed === true) {
        return;
      }
      // Silently drop null values for now
      if (data === null) {
        if (self._recursion++ === self._maxRecursion) {
          process.nextTick(function() {
            self._fetch();
          });
        }
        else {
          self._fetch();
        }
      }
      else {
        if (self.push(data) !== false) {
          if (self._recursion++ === self._maxRecursion) {
            process.nextTick(function() {
              self._fetch();
            });
          }
          else {
            self._fetch();
          }
        }
      }
      return null;
    }).error(function(error) {
      if (error.message.match(/No more rows in the/)) {
        self.push(null);
      }
      else if (error.message === 'You cannot retrieve data from a cursor that is closed.') {
        // if the user call `close`, the cursor may reject pending requests. We just
        // ignore them here.
      }
      else {
        self.emit('error', error);
        self.push(null);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (self._data[0].length === self._index) {
      self._index = 0;
      self._data.shift();
      if ((self._data.length === 1)
        &amp;&amp; (self._canFetch === true)
        &amp;&amp; (self._closed === false)
        &amp;&amp; (self._fetching === false)) {
          self.<span class="apidocCodeKeywordSpan">_fetch</span>();
      }
    }
    return Promise.resolve(result).nodeify(callback);
  }
}
else {
  return new Promise(function(resolve, reject) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.prototype._fetchAndDecrement" id="apidoc.element.rethinkdbdash.stream.prototype._fetchAndDecrement">
        function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_fetchAndDecrement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fetchAndDecrement = function () {
  var self = this;
  self._pending--;
  if (self._pending &lt; 0 || self._closed === true) {
    return;
  }

  if (self._cursor._closed === true) {
    self.push(null);
  }
  else {
    self._cursor._next().then(function(data) {
      // Silently drop null values for now
      if (data === null) {
        if (self._recursion++ === self._maxRecursion) {
          //Avoid maximum call stack errors
          process.nextTick(function() {
            self._fetchAndDecrement();
          });
        }
        else {
          self._fetchAndDecrement();
        }
      }
      else {
        if (self.push(data) !== false) {
          if (self._recursion++ === self._maxRecursion) {
            process.nextTick(function() {
              self._fetchAndDecrement();
            });
          }
          else {
            self._fetchAndDecrement();
          }
        }
      }
      return null;
    }).error(function(error) {
      if (error.message.match(/No more rows in the/)) {
        self.push(null);
      }
      else if (error.message === 'You cannot retrieve data from a cursor that is closed.') {
        // if the user call `close`, the cursor may reject pending requests. We just
        // ignore them here.
      }
      else {
        self.emit('error', error);
        self.push(null);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ReadableStream.prototype._setCursor = function(cursor) {
if (cursor instanceof Cursor === false) {
  this.emit('error', new Error('Cannot create a stream on a single value.'));
  this.push(null);
  return this;
}
this._cursor = cursor;
this.<span class="apidocCodeKeywordSpan">_fetchAndDecrement</span>();
}
ReadableStream.prototype._read = function(size) {
this._count++;
if (this._cursor === undefined) {
  this._pending++;
  return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.prototype._read" id="apidoc.element.rethinkdbdash.stream.prototype._read">
        function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_read
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function (size) {
  this._count++;
  if (this._cursor === undefined) {
    this._pending++;
    return;
  }

  this._recursion = 0;
  this._fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.prototype._setCursor" id="apidoc.element.rethinkdbdash.stream.prototype._setCursor">
        function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_setCursor
        <span class="apidocSignatureSpan">(cursor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setCursor = function (cursor) {
  if (cursor instanceof Cursor === false) {
    this.emit('error', new Error('Cannot create a stream on a single value.'));
    this.push(null);
    return this;
  }
  this._cursor = cursor;
  this._fetchAndDecrement();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //toStream make sure that options is an object
  helper.loopKeys(options, function(obj, key) {
    _options[key] = obj[key];
  });
  _options.cursor = true;
  stream = new ReadableStream(_options);
  this.run(connection, _options).then(function(cursor) {
    stream.<span class="apidocCodeKeywordSpan">_setCursor</span>(cursor);
    return null;
  }).error(function(error) {
    stream.emit('error', error);
  });
}
else {
  helper.loopKeys(connection, function(obj, key) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.prototype.close" id="apidoc.element.rethinkdbdash.stream.prototype.close">
        function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
  this._closed = true;
  this.push(null);
  return this._cursor.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
2. Remove everything related to a connection:

```js
r.connect({host: ..., port: ...}).then(function(connection) {
  connection.on('error', handleError);
  query.run(connection).then(function(result) {
    // console.log(result);
    connection.<span class="apidocCodeKeywordSpan">close</span>();
  });
});
```

Becomes:

```js
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.term" id="apidoc.module.rethinkdbdash.term">module rethinkdbdash.term</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.term" id="apidoc.element.rethinkdbdash.term.term">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>term
        <span class="apidocSignatureSpan">(r, value, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Term(r, value, error) {
  var self = this;
  var term = function(field) {
    if (Term.prototype._fastArity(arguments.length, 1) === false) {
      var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
      Term.prototype._arity(_args, 1, '(...)', self);
    }
    return term.bracket(field);
  }
  helper.changeProto(term, self);

  if (value === undefined) {
    term._query = [];
  }
  else {
    term._query = value;
  }
  term._r = r; // Keep a reference to r for global settings

  if (error !== undefined) {
    term._error = error;
    term._frames = [];
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.term.prototype" id="apidoc.module.rethinkdbdash.term.prototype">module rethinkdbdash.term.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.ISO8601" id="apidoc.element.rethinkdbdash.term.prototype.ISO8601">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ISO8601
        <span class="apidocSignatureSpan">(isoTime, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ISO8601 = function (isoTime, options) {
  this._noPrefix(this, 'ISO8601');
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'ISO8601', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.ISO8601)
  var args = [new Term(this._r).expr(isoTime)._query];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== 'defaultTimezone') {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `ISO8601`. Available options are primaryKey &lt;string&gt;,
durability &lt;string&gt;, datancenter &lt;string&gt;');
      }
    });
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (expression instanceof Term) {
return expression;
  }
  else if (expression instanceof Function) {
return new Func(self._r, expression);
  }
  else if (expression instanceof Date) {
return new Term(self._r).<span class="apidocCodeKeywordSpan">ISO8601</span>(expression.toISOString())
  }
  else if (Array.isArray(expression)) {
var term = new Term(self._r);
term._query.push(termTypes.MAKE_ARRAY);

var args = [];
for(var i=0; i&lt;expression.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._arity" id="apidoc.element.rethinkdbdash.term.prototype._arity">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_arity
        <span class="apidocSignatureSpan">(args, num, method, term)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_arity = function (args, num, method, term) {
  var foundArgs = false;
  for(var i=0; i&lt;args.length; i++) {
    if ((args[i] instanceof Term) &amp;&amp; (args[i]._query[0] === termTypes.ARGS)) {
      foundArgs = true;
      break;
    }
  }
  if (foundArgs === false) {
    throw new Error.ReqlDriverError('`'+method+'` takes '+num+' argument'+((num&gt;1)?'s':'')+', '+args.length+' provided', term._query
);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var TransformStream = require(__dirname+'/transform_stream.js');

function Term(r, value, error) {
var self = this;
var term = function(field) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype.<span class="apidocCodeKeywordSpan">_arity</span>(_args, 1, '(...)', self);
  }
  return term.bracket(field);
}
helper.changeProto(term, self);

if (value === undefined) {
  term._query = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._arityRange" id="apidoc.element.rethinkdbdash.term.prototype._arityRange">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_arityRange
        <span class="apidocSignatureSpan">(args, min, max, method, term)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_arityRange = function (args, min, max, method, term) {
  var foundArgs = false;
  if (args.length &lt; min) {
    for(var i=0; i&lt;args.length; i++) {
      if ((args[i] instanceof Term) &amp;&amp; (args[i]._query[0] === termTypes.ARGS)) {
        foundArgs = true;
        break;
      }
    }
    if (foundArgs === false) {
      throw new Error.ReqlDriverError('`'+method+'` takes at least '+min+' argument'+((min&gt;1)?'s':'')+', '+args.length+' provided
', term._query);
    }
  }
  else if (args.length &gt; max) {
    for(var i=0; i&lt;args.length; i++) {
      if ((args[i] instanceof Term) &amp;&amp; (args[i]._query[0] === termTypes.ARGS)) {
        foundArgs = true;
        break;
      }
    }
    if (foundArgs === false) {
      throw new Error.ReqlDriverError('`'+method+'` takes at most '+max+' argument'+((max&gt;1)?'s':'')+', '+args.length+' provided
', term._query);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Manipulating Tables
Term.prototype.tableCreate = function(table, options) {
var self = this;
if (self._fastArityRange(arguments.length, 1, 2) === false) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  self.<span class="apidocCodeKeywordSpan">_arityRange</span>(_args, 1, 2, 'tableCreate', self);
}


var term = new Term(self._r);
term._query.push(termTypes.TABLE_CREATE)

var args = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._fastArity" id="apidoc.element.rethinkdbdash.term.prototype._fastArity">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_fastArity
        <span class="apidocSignatureSpan">(len, num)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fastArity = function (len, num) {
  return (len === num);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ReadableStream = require(__dirname+'/stream.js');
var WritableStream = require(__dirname+'/writable_stream.js');
var TransformStream = require(__dirname+'/transform_stream.js');

function Term(r, value, error) {
var self = this;
var term = function(field) {
  if (Term.prototype.<span class="apidocCodeKeywordSpan">_fastArity</span>(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, '(...)', self);
  }
  return term.bracket(field);
}
helper.changeProto(term, self);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._fastArityRange" id="apidoc.element.rethinkdbdash.term.prototype._fastArityRange">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_fastArityRange
        <span class="apidocSignatureSpan">(len, min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fastArityRange = function (len, min, max) {
  return ((len &gt;= min) &amp;&amp; (len &lt;= max));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
term._query.push(termTypes.DB_LIST)
return term;
}

// Manipulating Tables
Term.prototype.tableCreate = function(table, options) {
var self = this;
if (self.<span class="apidocCodeKeywordSpan">_fastArityRange</span>(arguments.length, 1, 2) === false) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  self._arityRange(_args, 1, 2, 'tableCreate', self);
}


var term = new Term(self._r);
term._query.push(termTypes.TABLE_CREATE)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._fillArgs" id="apidoc.element.rethinkdbdash.term.prototype._fillArgs">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_fillArgs
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fillArgs = function (args) {
  var foundError = false;
  var internalArgs = [];
  for(var i=0; i&lt;args.length; i++) {
  if (args[i] instanceof Term) {
    internalArgs.push(args[i]._query);
    if (!foundError &amp;&amp; (args[i]._error != null)) {
    this._error = args[i]._error;
    this._frames = args[i]._frames;
    this._frames.unshift(i);
    foundError = true;
    }
  }
  else {
    internalArgs.push(args[i]);
  }
  }
  this._query.push(internalArgs);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Term.prototype.dbCreate = function(db) {
// Check for arity is done in r.prototype.dbCreate
this._noPrefix(this, 'dbCreate');

var term = new Term(this._r);
term._query.push(termTypes.DB_CREATE);
var args = [new Term(this._r).expr(db)._query]
term.<span class="apidocCodeKeywordSpan">_fillArgs</span>(args);
return term;
}
Term.prototype.dbDrop = function(db) {
this._noPrefix(this, 'dbDrop');

var term = new Term(this._r);
term._query.push(termTypes.DB_DROP);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._noPrefix" id="apidoc.element.rethinkdbdash.term.prototype._noPrefix">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_noPrefix
        <span class="apidocSignatureSpan">(term, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_noPrefix = function (term, method) {
  if ((!Array.isArray(term._query)) || (term._query.length &gt; 0)) {
    throw new Error.ReqlDriverError('`'+method+'` is not defined', term._query);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}


// Manipulating databases
Term.prototype.dbCreate = function(db) {
  // Check for arity is done in r.prototype.dbCreate
  this.<span class="apidocCodeKeywordSpan">_noPrefix</span>(this, 'dbCreate');

  var term = new Term(this._r);
  term._query.push(termTypes.DB_CREATE);
  var args = [new Term(this._r).expr(db)._query]
  term._fillArgs(args);
  return term;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._setArrayLimit" id="apidoc.element.rethinkdbdash.term.prototype._setArrayLimit">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_setArrayLimit
        <span class="apidocSignatureSpan">(arrayLimit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setArrayLimit = function (arrayLimit) {
  Term.prototype._arrayLimit = arrayLimit;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._setNestingLevel" id="apidoc.element.rethinkdbdash.term.prototype._setNestingLevel">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_setNestingLevel
        <span class="apidocSignatureSpan">(nestingLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setNestingLevel = function (nestingLevel) {
  Term.prototype._nestingLevel = nestingLevel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._toReadableStream" id="apidoc.element.rethinkdbdash.term.prototype._toReadableStream">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_toReadableStream
        <span class="apidocSignatureSpan">(connection, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toReadableStream = function (connection, options) {
  var stream;

  var _options = {};
  if (helper.isPlainObject(connection) &amp;&amp; (typeof connection._isConnection === 'function') &amp;&amp; (connection._isConnection() === true
)) {
    //toStream make sure that options is an object
    helper.loopKeys(options, function(obj, key) {
      _options[key] = obj[key];
    });
    _options.cursor = true;
    stream = new ReadableStream(_options);
    this.run(connection, _options).then(function(cursor) {
      stream._setCursor(cursor);
      return null;
    }).error(function(error) {
      stream.emit('error', error);
    });
  }
  else {
    helper.loopKeys(connection, function(obj, key) {
      _options[key] = obj[key];
    });
    _options.cursor = true;
    stream = new ReadableStream(_options);
    this.run(_options).then(function(cursor) {
      stream._setCursor(cursor);
      return null;
    }).error(function(error) {
      stream.emit('error', error);
    });
  }
  return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Term.prototype.toStream = function(connection, options) {
if (helper.isPlainObject(connection) &amp;&amp; (typeof connection._isConnection === 'function') &amp;&amp; (connection
._isConnection() === true)) {
  if (helper.isPlainObject(options) === false) {
    options = {};
  }
  if (options.readable === true) {
    return this.<span class="apidocCodeKeywordSpan">_toReadableStream</span>(connection, options);
  }
  else if (options.writable === true) {
    return this._toWritableStream(connection, options);
  }
  else if (options.transform === true) {
    return this._toTransformStream(connection, options);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._toTransformStream" id="apidoc.element.rethinkdbdash.term.prototype._toTransformStream">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_toTransformStream
        <span class="apidocSignatureSpan">(connection, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTransformStream = function (connection, options) {
  if (this._query[0] !== termTypes.TABLE) {
    throw new Error.ReqlDriverError('Cannot create a writable stream on something else than a table.');
  }

  if (helper.isPlainObject(connection) &amp;&amp; (typeof connection._isConnection === 'function') &amp;&amp; (connection._isConnection() === true
)) {
    return new TransformStream(this, options, connection);
  }
  else {
    return new TransformStream(this, connection);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (options.readable === true) {
    return this._toReadableStream(connection, options);
  }
  else if (options.writable === true) {
    return this._toWritableStream(connection, options);
  }
  else if (options.transform === true) {
    return this.<span class="apidocCodeKeywordSpan">_toTransformStream</span>(connection, options);
  }
  else {
    return this._toReadableStream(connection, options);
  }
}
else {
  options = connection;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._toWritableStream" id="apidoc.element.rethinkdbdash.term.prototype._toWritableStream">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_toWritableStream
        <span class="apidocSignatureSpan">(connection, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toWritableStream = function (connection, options) {
  if (this._query[0] !== termTypes.TABLE) {
    throw new Error.ReqlDriverError('Cannot create a writable stream on something else than a table.');
  }

  if (helper.isPlainObject(connection) &amp;&amp; (typeof connection._isConnection === 'function') &amp;&amp; (connection._isConnection() === true
)) {
    return new WritableStream(this, options, connection);
  }
  else {
    return new WritableStream(this, connection);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (helper.isPlainObject(options) === false) {
  options = {};
}
if (options.readable === true) {
  return this._toReadableStream(connection, options);
}
else if (options.writable === true) {
  return this.<span class="apidocCodeKeywordSpan">_toWritableStream</span>(connection, options);
}
else if (options.transform === true) {
  return this._toTransformStream(connection, options);
}
else {
  return this._toReadableStream(connection, options);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._wrap" id="apidoc.element.rethinkdbdash.term.prototype._wrap">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_wrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_wrap = function () {
  var self = this;
  if (helper.hasImplicit(this._query)) {
    if (this._query[0] === termTypes.ARGS) {
      throw new Error.ReqlDriverError('Implicit variable `r.row` cannot be used inside `r.args`')
    }
    //Must pass at least one variable to the function or it won't accept r.row
    return new Term(this._r).expr(function(doc) { return self; })
  }
  else {
    return self;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fn = undefined;
}

var term = new Term(this._r);
term._query.push(termTypes.INDEX_CREATE);
var args = [this];
args.push(new Term(this._r).expr(name));
if (typeof fn !== 'undefined') args.push(new Term(this._r).expr(fn).<span class="apidocCodeKeywordSpan">_wrap</span>());
term._fillArgs(args);

if (helper.isPlainObject(options)) {
  // There is no need to translate here
  helper.loopKeys(options, function(obj, key) {
    if ((key !== 'multi') &amp;&amp; (key !== 'geo')) {
      throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `indexCreate`', self._query, 'Available
 option is multi &lt;bool&gt; and geo &lt;bool&gt;');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.add" id="apidoc.element.rethinkdbdash.term.prototype.add">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>add
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'add', this);

  var term = new Term(this._r);
  term._query.push(termTypes.ADD)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
'stream.js',
'term.js',
'transform_stream.js',
'writable_stream.js'
];

var b = browserify('./lib/')
b.<span class="apidocCodeKeywordSpan">add</span>('./lib/index.js')
for(var i=0; i&lt;REQUIRE_FILES.length; i++) {
b.require('./lib/'+REQUIRE_FILES[i], {expose: './lib/'+REQUIRE_FILES[i]})
}
b.require('./lib/index.js', {expose: 'rethinkdbdash'})
b.bundle(function(err, result) {
if (err) {
  console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.and" id="apidoc.element.rethinkdbdash.term.prototype.and">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>and
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">and = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.AND)
  var args = [];
  if (!Array.isArray(this._query) || (this._query.length &gt; 0)) {
    args.push(this);
  }
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.append" id="apidoc.element.rethinkdbdash.term.prototype.append">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>append
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'append', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.APPEND)
  var args = [this, new Term(this._r).expr(value)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.april" id="apidoc.element.rethinkdbdash.term.prototype.april">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>april
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">april = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.APRIL);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.args" id="apidoc.element.rethinkdbdash.term.prototype.args">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>args
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">args = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._noPrefix(this, 'args');

  var term = new Term(this._r);
  term._query.push(termTypes.ARGS);
  var args = [];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.asc" id="apidoc.element.rethinkdbdash.term.prototype.asc">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>asc
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asc = function (field) {
  this._noPrefix(this, 'asc');
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'asc', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.ASC)
  var args = [new Term(this._r).expr(field)._wrap()];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.august" id="apidoc.element.rethinkdbdash.term.prototype.august">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>august
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">august = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.AUGUST);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.avg" id="apidoc.element.rethinkdbdash.term.prototype.avg">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>avg
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">avg = function (field) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'avg', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.AVG)
  var args = [this];
  if (field !== undefined) {
    args.push(new Term(this._r).expr(field)._wrap())
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.between" id="apidoc.element.rethinkdbdash.term.prototype.between">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>between
        <span class="apidocSignatureSpan">(start, end, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">between = function (start, end, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 2, 3, 'between', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.BETWEEN);
  var args = [self, new Term(self._r).expr(start), new Term(self._r).expr(end)]
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'index') &amp;&amp; (key !== 'leftBound') &amp;&amp; (key !== 'rightBound')){
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `between`', self._query, 'Available options are index &lt;
string&gt;, leftBound &lt;string&gt;, rightBound &lt;string&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.binary" id="apidoc.element.rethinkdbdash.term.prototype.binary">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>binary
        <span class="apidocSignatureSpan">(bin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binary = function (bin) {
  this._noPrefix(this, 'binary');
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'binary', this);
  }

  var term;
  if (bin instanceof Buffer) {
    // We could use BINARY, and coerce `bin` to an ASCII string, but that
    // will break if there is a null char
    term = new Term(this._r, {
      $reql_type$: 'BINARY',
      data: bin.toString('base64')
    });
  }
  else {
    term = new Term(this._r);
    term._query.push(termTypes.BINARY)
    var args = [new Term(this._r).expr(bin)];
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var result = {
  str: '',
  car: ''
}

if ((helper.isPlainObject(term)) &amp;&amp; (term.$reql_type$ === 'BINARY')) {
  carify(result, 'r.<span class="apidocCodeKeywordSpan">binary</span>(&lt;Buffer&gt;)', underline);
  return result;
}

if ((index === 0) &amp;&amp; ((father == null) || (!nonPrefix[father[0]]))) carify(result, 'r.expr(', underline)

if (typeof term === 'string' ) {
  carify(result, '"'+term+'"', underline);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.bracket" id="apidoc.element.rethinkdbdash.term.prototype.bracket">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>bracket
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bracket = function (field) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, '(...)', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.BRACKET)
  var args = [this, new Term(this._r).expr(field)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function Term(r, value, error) {
var self = this;
var term = function(field) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, '(...)', self);
  }
  return term.<span class="apidocCodeKeywordSpan">bracket</span>(field);
}
helper.changeProto(term, self);

if (value === undefined) {
  term._query = [];
}
else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.branch" id="apidoc.element.rethinkdbdash.term.prototype.branch">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>branch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">branch = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 2, Infinity, '', this);

  var term = new Term(this._r);
  term._query.push(termTypes.BRANCH)
  var args = [];
  args.push(this);
  for(var i=0; i&lt;_len; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof pendingCallback === 'function') {
  pendingCallback();
}

var query = self._table.insert(cache, self._insertOptions);
if (self._options.format === 'primaryKey') {
  query = query.do(function(result) {
    return self._r.<span class="apidocCodeKeywordSpan">branch</span>(
      result('errors').eq(0),
      self._table.config()('primary_key').do(function(primaryKey) {
        return result('changes')('new_val')(primaryKey)
      }),
      result(self._r.error(result('errors').coerceTo('STRING').add(' errors returned. First error:\n'
;).add(result('first_error'))))
    )
  })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.catch" id="apidoc.element.rethinkdbdash.term.prototype.catch">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>catch
        <span class="apidocSignatureSpan">(reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catch = function (reject) {
  return this.run().catch(reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```


#### Optional `run` with `yield`

The `then` and `catch` methods are implemented on a `Term` - returned by any methods
like `filter`, `update` etc. They are shortcut for `this.run().then(callback)` and
`this.run().<span class="apidocCodeKeywordSpan">catch</span>(callback)`.

This means that you can `yield` any query without calling `run.`

```js
var bluebird = require('bluebird');
var r = require('rethinkdbdash')();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.ceil" id="apidoc.element.rethinkdbdash.term.prototype.ceil">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ceil
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ceil = function () {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'ceil', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.CEIL)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Create the settings for a given pool. Merge the global options + the servers's one.
PoolMaster.prototype.createPoolSettings = function(globalOptions, serverOptions, log) {
var settings = {};
var numServers = Array.isArray(globalOptions.servers) ? globalOptions.servers.length: 1;
helper.loopKeys(globalOptions, function(options, key) {
  if ((key === 'buffer') || (key === 'max')) {
    settings[key] = Math.<span class="apidocCodeKeywordSpan">ceil</span>(options[key]/numServers);
    settings[key] = Math.ceil(options[key]/numServers);
  }
  else if (key !== 'servers') {
    settings[key] = options[key];
  }
});
if (serverOptions) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.changeAt" id="apidoc.element.rethinkdbdash.term.prototype.changeAt">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>changeAt
        <span class="apidocSignatureSpan">(index, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changeAt = function (index, value) {
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'changeAt', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.CHANGE_AT);
  var args = [this];
  args.push(new Term(this._r).expr(index))
  args.push(new Term(this._r).expr(value))
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.changes" id="apidoc.element.rethinkdbdash.term.prototype.changes">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>changes
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 0, 1, 'changes', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.CHANGES);
  var args = [self];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'squash') &amp;&amp; (key !== 'includeStates') &amp;&amp; (key !== 'includeTypes')
          &amp;&amp; (key !== 'includeInitial') &amp;&amp; (key !== 'includeOffsets')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `changes`', self._query,
            'Available options are squash &lt;bool&gt;, includeInitial &lt;bool&gt;, includeStates &lt;bool&gt;, includeOffsets &lt;bool&gt;, includeTypes
 &lt;bool&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

//  Create the feed on server_status and bind the listener to the feed
PoolMaster.prototype.fetchServers = function(useSeeds) {
var self = this;
var query = self._r.db('rethinkdb').table('server_status')
    .union([SEPARATOR])
    .union(self._r.db('rethinkdb').table('server_status').<span class="apidocCodeKeywordSpan">changes</span>())
// In case useSeeds is true, we rotate through all the seeds + the pool master
if (!useSeeds || self._seed === self._servers.length) {
  if (useSeeds &amp;&amp; self._seed === self._servers.length) {
    // We increase the back off only when we went through all the seeds
    self._consecutiveFails++;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.circle" id="apidoc.element.rethinkdbdash.term.prototype.circle">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>circle
        <span class="apidocSignatureSpan">(center, radius, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">circle = function (center, radius, options) {
  var self = this;

  // Arity check is done by r.circle
  self._noPrefix(self, 'circle');
  var term = new Term(self._r);
  term._query.push(termTypes.CIRCLE);
  var args = [new Term(self._r).expr(center), new Term(self._r).expr(radius)];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    // There is no need to translate here
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'numVertices') &amp;&amp; (key !== 'geoSystem') &amp;&amp; (key !== 'unit') &amp;&amp; (key !== 'fill')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `circle`', self._query, 'Available options are numVertices
 &lt;number&gt;, geoSsystem &lt;string&gt;, unit &lt;string&gt; and fill &lt;bool&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.coerceTo" id="apidoc.element.rethinkdbdash.term.prototype.coerceTo">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>coerceTo
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coerceTo = function (type) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'coerceTo', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.COERCE_TO)
  var args = [this, new Term(this._r).expr(type)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (self._options.format === 'primaryKey') {
  query = query.do(function(result) {
    return self._r.branch(
      result('errors').eq(0),
      self._table.config()('primary_key').do(function(primaryKey) {
        return result('changes')('new_val')(primaryKey)
      }),
      result(self._r.error(result('errors').<span class="apidocCodeKeywordSpan">coerceTo</span>('STRING').add
(' errors returned. First error:\n').add(result('first_error'))))
    )
  })
}

query.run(self._connection).then(function(result) {
  self._inserting = false;
  if (self._options.format === 'primaryKey') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.concatMap" id="apidoc.element.rethinkdbdash.term.prototype.concatMap">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>concatMap
        <span class="apidocSignatureSpan">(transformation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatMap = function (transformation) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'concatMap', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.CONCAT_MAP);
  var args = [this];
  args.push(new Term(this._r).expr(transformation)._wrap())
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.config" id="apidoc.element.rethinkdbdash.term.prototype.config">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>config
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'config', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.CONFIG);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var query = self._table.insert(cache, self._insertOptions);
if (self._options.format === 'primaryKey') {
  query = query.do(function(result) {
    return self._r.branch(
      result('errors').eq(0),
      self._table.<span class="apidocCodeKeywordSpan">config</span>()('primary_key').do(function(primaryKey) {
        return result('changes')('new_val')(primaryKey)
      }),
      result(self._r.error(result('errors').coerceTo('STRING').add(' errors returned. First error:\n'
;).add(result('first_error'))))
    )
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.contains" id="apidoc.element.rethinkdbdash.term.prototype.contains">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>contains
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'contains', this);

  var term = new Term(this._r);
  term._query.push(termTypes.CONTAINS)
  var args = [this._query];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i])._wrap())
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.count" id="apidoc.element.rethinkdbdash.term.prototype.count">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>count
        <span class="apidocSignatureSpan">(filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (filter) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'count', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.COUNT);
  var args = [];
  args.push(this);
  if (filter !== undefined) {
    args.push(new Term(this._r).expr(filter)._wrap())
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.date" id="apidoc.element.rethinkdbdash.term.prototype.date">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>date
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">date = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'date', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DATE)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.day" id="apidoc.element.rethinkdbdash.term.prototype.day">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>day
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">day = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'day', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DAY)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.dayOfWeek" id="apidoc.element.rethinkdbdash.term.prototype.dayOfWeek">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dayOfWeek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dayOfWeek = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'dayOfWeek', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DAY_OF_WEEK)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.dayOfYear" id="apidoc.element.rethinkdbdash.term.prototype.dayOfYear">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dayOfYear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dayOfYear = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'dayOfYear', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DAY_OF_YEAR)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.db" id="apidoc.element.rethinkdbdash.term.prototype.db">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>db
        <span class="apidocSignatureSpan">(db)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">db = function (db) {
  this._noPrefix(this, 'db');
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'db', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DB)
  var args = [new Term(this._r).expr(db)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      carify(result, 'r.'+typeToString[term[0]]+'(', underline);
      if (Array.isArray(term[1])) {
        for(var i=0; i&lt;term[1].length; i++) {
if (i !==0) result.str += ', ';


if ((currentFrame != null) &amp;&amp; (currentFrame === 1)) {
  // +1 for index because it's like if there was a r.<span class="apidocCodeKeywordSpan">db</span>(...) before .table(...)
  backtrace = generateBacktrace(term[1][i], i+1, term, frames, options)
}
else {
  backtrace = generateBacktrace(term[1][i], i+1, term, null, options)
}
result.str += backtrace.str;
result.car += backtrace.car
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.dbCreate" id="apidoc.element.rethinkdbdash.term.prototype.dbCreate">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dbCreate
        <span class="apidocSignatureSpan">(db)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dbCreate = function (db) {
  // Check for arity is done in r.prototype.dbCreate
  this._noPrefix(this, 'dbCreate');

  var term = new Term(this._r);
  term._query.push(termTypes.DB_CREATE);
  var args = [new Term(this._r).expr(db)._query]
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tableName = util.uuid()

var query; // without `.run()`
//query = 'r.table("foo").add(1).add(1).add("hello-super-long-string").add("another-long-string"
;).add("one-last-string").map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test
) { return test("b").add("hello-super-long-string").add("another-long-string").add("one-last-
string").add("hello-super-long-string").add("another-long-string").add("one-last-string").add
("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello-super
-long-string").add("another-long-string").add("one-last-string").add("hello-super-long-string"
;).add("another-long-string").add("one-last-string").mul(test("b")).merge({ firstName: "xxxxxx
", lastName: "yyyy", email: "xxxxx@yyyy.com", phone: "xxx-xxx-xxxx" }); }).add(2).map(function
(doc) { return doc.add("hello-super-long-string").add("another-long-string").add("one-last-string").
add("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello-super
-long-string").add("another-long-string").add("one-last-string").add("hello-super-long-string"
;).add("another-long-string").add("one-last-string").add("hello-super-long-string").add("another
-long-string").add("one-last-string") }); })';
query = 'r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })';
Promise.coroutine(function* () {
try {
  yield r.<span class="apidocCodeKeywordSpan">dbCreate</span>(dbName).run();
  yield r.db(dbName).tableCreate(tableName).run();

  var result = yield eval(query).run();
  throw new Error("Should have thrown an error");
}
catch(e) {
  console.log(e.message);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.dbDrop" id="apidoc.element.rethinkdbdash.term.prototype.dbDrop">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dbDrop
        <span class="apidocSignatureSpan">(db)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dbDrop = function (db) {
  this._noPrefix(this, 'dbDrop');

  var term = new Term(this._r);
  term._query.push(termTypes.DB_DROP);
  var args = [new Term(this._r).expr(db)._query]
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.dbList" id="apidoc.element.rethinkdbdash.term.prototype.dbList">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dbList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dbList = function () {
  this._noPrefix(this, 'dbList');

  var term = new Term(this._r);
  term._query.push(termTypes.DB_LIST)
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.december" id="apidoc.element.rethinkdbdash.term.prototype.december">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>december
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">december = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.DECEMBER);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.default" id="apidoc.element.rethinkdbdash.term.prototype.default">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>default
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default = function (expression) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'default', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DEFAULT);
  var args = [this, new Term(this._r).expr(expression)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.delay" id="apidoc.element.rethinkdbdash.term.prototype.delay">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>delay
        <span class="apidocSignatureSpan">(msecs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function (msecs) {
  return this.run().delay(msecs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Term.prototype.catch = function(reject) {
  return this.run().catch(reject);
}
Term.prototype.finally = function(handler) {
  return this.run().finally(handler);
}
Term.prototype.delay = function(msecs) {
  return this.run().<span class="apidocCodeKeywordSpan">delay</span>(msecs);
}

Term.prototype.toString = function() {
  return Error.generateBacktrace(this._query, 0, null, [], {indent: 0, extra: 0}).str;
}

Term.prototype._wrap = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.delete" id="apidoc.element.rethinkdbdash.term.prototype.delete">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>delete
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 0, 1, 'delete', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.DELETE);
  var args = [self];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'returnChanges') &amp;&amp; (key !== 'durability')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `delete`', self._query, 'Available options are returnChanges
 &lt;bool&gt;, durability &lt;string&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    connection.on('error', function(error) {
// We are going to close connection, but we don't want another process to use it before
// So we remove it from the pool now (if it's inside)
self._log('Error emitted by a connection: '+JSON.stringify(error));
for(var i=0; i&lt;self.getAvailableLength(); i++) {
  if (self._pool.get(i) === this) {
    self._pool.<span class="apidocCodeKeywordSpan">delete</span>(i);
    self.emit('available-size', self._pool.getLength());
    self.emit('available-size-diff', -1);
    break;
  }
}
// We want to make sure that it's not going to try to reconnect
clearTimeout(connection.timeout);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.deleteAt" id="apidoc.element.rethinkdbdash.term.prototype.deleteAt">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>deleteAt
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteAt = function (start, end) {
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'deleteAt', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DELETE_AT);
  var args = [this, new Term(this._r).expr(start)];
  if (end !== undefined) {
    args.push(new Term(this._r).expr(end))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.desc" id="apidoc.element.rethinkdbdash.term.prototype.desc">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>desc
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">desc = function (field) {
  this._noPrefix(this, 'desc');
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'desc', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DESC)
  var args = [new Term(this._r).expr(field)._wrap()];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.difference" id="apidoc.element.rethinkdbdash.term.prototype.difference">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>difference
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">difference = function (other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'difference', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DIFFERENCE)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.distance" id="apidoc.element.rethinkdbdash.term.prototype.distance">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>distance
        <span class="apidocSignatureSpan">(geometry, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distance = function (geometry, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'distance', self);
  }
  var term = new Term(self._r);
  term._query.push(termTypes.DISTANCE);
  var args = [self, new Term(self._r).expr(geometry)];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'geoSystem') &amp;&amp; (key !== 'unit')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distance`', self._query, 'Available options are geoSystem
 &lt;string&gt;, unit &lt;string&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.distinct" id="apidoc.element.rethinkdbdash.term.prototype.distinct">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>distinct
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distinct = function (options) {
  var self= this;
  if (self._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 0, 1, 'distinct', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.DISTINCT)
  var args = [self];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    var keepGoing = true;
    helper.loopKeys(options, function(obj, key) {
      if ((keepGoing === true) &amp;&amp; (key !== 'index')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distinct`', self._query, 'Available option is index: &lt;
string&gt;');
        keepGoing = false;
      }
    });
    if (keepGoing === true) {
      term._query.push(new Term(self._r).expr(translateOptions(options))._query);
    }
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.div" id="apidoc.element.rethinkdbdash.term.prototype.div">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>div
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">div = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'div', this);

  var term = new Term(this._r);
  term._query.push(termTypes.DIV)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.do" id="apidoc.element.rethinkdbdash.term.prototype.do">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>do
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">do = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'do', this);

  var term = new Term(this._r);
  term._query.push(termTypes.FUNCALL);
  var args = [new Term(this._r).expr(_args[_args.length-1])._wrap()._query];
  args.push(this);
  for(var i=0; i&lt;_args.length-1; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

carify(result, 'var_'+term[1][0], underline);

if (underline) result.car = result.str.replace(/./g, '^');
return result;
  },
  FUNCALL: function(term, index, father, frames, options) {
// The syntax is args[1].<span class="apidocCodeKeywordSpan">do</span>(args[0])
var result = {
  str: '',
  car: ''
};
var backtrace, underline, currentFrame;

var underline = Array.isArray(frames) &amp;&amp; (frames.length === 0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.downcase" id="apidoc.element.rethinkdbdash.term.prototype.downcase">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>downcase
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">downcase = function (regex) {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'upcase', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DOWNCASE)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.during" id="apidoc.element.rethinkdbdash.term.prototype.during">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>during
        <span class="apidocSignatureSpan">(left, right, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">during = function (left, right, options) {
  if (this._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 2, 3, 'during', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DURING);
  var args = [];
  args.push(this);
  args.push(new Term(this._r).expr(left));
  args.push(new Term(this._r).expr(right));

  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.epochTime" id="apidoc.element.rethinkdbdash.term.prototype.epochTime">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>epochTime
        <span class="apidocSignatureSpan">(epochTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">epochTime = function (epochTime) {
  this._noPrefix(this, 'epochTime');

  var term = new Term(this._r);
  term._query.push(termTypes.EPOCH_TIME)
  var args = [new Term(this._r).expr(epochTime)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.eq" id="apidoc.element.rethinkdbdash.term.prototype.eq">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>eq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eq = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'eq', this);

  var term = new Term(this._r);
  term._query.push(termTypes.EQ)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  pendingCallback();
}

var query = self._table.insert(cache, self._insertOptions);
if (self._options.format === 'primaryKey') {
  query = query.do(function(result) {
    return self._r.branch(
      result('errors').<span class="apidocCodeKeywordSpan">eq</span>(0),
      self._table.config()('primary_key').do(function(primaryKey) {
        return result('changes')('new_val')(primaryKey)
      }),
      result(self._r.error(result('errors').coerceTo('STRING').add(' errors returned. First error:\n'
;).add(result('first_error'))))
    )
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.eqJoin" id="apidoc.element.rethinkdbdash.term.prototype.eqJoin">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>eqJoin
        <span class="apidocSignatureSpan">(rightKey, sequence, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eqJoin = function (rightKey, sequence, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 2, 3, 'eqJoin', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.EQ_JOIN);
  var args = [self];
  args.push(new Term(self._r).expr(rightKey)._wrap());
  args.push(new Term(self._r).expr(sequence));
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'index') &amp;&amp; (key !== 'ordered')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `eqJoin`', self._query, 'Available options are index &lt;
string&gt;, ordered &lt;boolean&gt;');
      }
    })
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.error" id="apidoc.element.rethinkdbdash.term.prototype.error">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>error
        <span class="apidocSignatureSpan">(reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (reject) {
  return this.run().error(reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Once you have imported the driver, you can immediately run queries,
you don't need to call `r.connect`, or pass a connection to `run`.

```js
var r = require('rethinkdbdash')();
r.table('users').get('orphee@gmail.com').run().then(function(user) {
  // ...
}).<span class="apidocCodeKeywordSpan">error</span>(handleError)
```

- Cursors are coerced to arrays by default

```js
var r = require('rethinkdbdash')();
r.table('data').run().then(function(result) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.expr" id="apidoc.element.rethinkdbdash.term.prototype.expr">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>expr
        <span class="apidocSignatureSpan">(expression, nestingLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expr = function (expression, nestingLevel) {
  var self = this;
  self._noPrefix(self, 'expr');
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'expr', self);
  }

  // undefined will be caught in the last else
  var ar, obj;

  if (expression === undefined) {
    var error = 'Cannot convert `undefined` with r.expr()';
    return new Term(self._r, expression, error);
  }

  var _nestingLevel = nestingLevel;
  if (_nestingLevel == null) {
    _nestingLevel = self._r.nestingLevel;
  }
  //if (nestingLevel == null) nestingLevel = self._r.nestingLevel;
  if (_nestingLevel &lt; 0) throw new Error.ReqlDriverError('Nesting depth limit exceeded.\nYou probably have a circular reference
somewhere')

  if (expression instanceof Term) {
    return expression;
  }
  else if (expression instanceof Function) {
    return new Func(self._r, expression);
  }
  else if (expression instanceof Date) {
    return new Term(self._r).ISO8601(expression.toISOString())
  }
  else if (Array.isArray(expression)) {
    var term = new Term(self._r);
    term._query.push(termTypes.MAKE_ARRAY);

    var args = [];
    for(var i=0; i&lt;expression.length; i++) {
      args.push(new Term(self._r).expr(expression[i], _nestingLevel-1))
    }
    term._fillArgs(args);
    return term;
  }
  else if (expression instanceof Buffer) {
    return self._r.binary(expression);
  }
  else if (helper.isPlainObject(expression)) {
    var term = new Term(self._r);
    var optArgs = {};
    var foundError = false;
    helper.loopKeys(expression, function(expression, key) {
      if (expression[key] !== undefined) {
        var optArg = new Term(self._r).expr(expression[key], _nestingLevel-1);
        if (optArg instanceof Term &amp;&amp; !foundError &amp;&amp; optArg._error != null) {
          foundError = true;
          term._error = optArg._error;
          term._frames = [key].concat(optArg._frames);
        }
        optArgs[key] = optArg._query;
      }
    });
    term._query = optArgs;
    return term;
  }
  else { // Primitive
    if (expression === null) {
      return new Term(self._r, null, expression);
    }
    else if (typeof expression === 'string') {
      return new Term(self._r, expression);
    }
    else if (typeof expression === 'number') {
      if (expression !== expression) {
        var error = 'Cannot convert `NaN` to JSON';
        return new Term(self._r, expression, error);
      }
      else if (!isFinite(expression)) {
        var error = 'Cannot convert `Infinity` to JSON';
        return new Term(self._r, expression, error);
      }
      return new Term(self._r, expression);
    }
    else if (typeof expression === 'boolean') {
      return new Term(self._r, expression);
    }
    else {
      self._error = new Error.ReqlDriverError('Cannot convert `'+expression+'` to datum.');
      self._frames = [];
    }
  }
  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Arrays by default, not cursors

Rethinkdbdash automatically coerce cursors to arrays. If you need a raw cursor,
you can call the `run` command with the option `{cursor: true}` or import the
driver with `{cursor: true}`.

```js
r.<span class="apidocCodeKeywordSpan">expr</span>([1, 2, 3]).run().then(function(result) {
console.log(JSON.stringify(result)) // print [1, 2, 3]
})
```

```js
r.expr([1, 2, 3]).run({cursor: true}).then(function(cursor) {
cursor.toArray().then(function(result) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.february" id="apidoc.element.rethinkdbdash.term.prototype.february">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>february
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">february = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.FEBRUARY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.fill" id="apidoc.element.rethinkdbdash.term.prototype.fill">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>fill
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fill = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'fill', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.FILL);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.filter" id="apidoc.element.rethinkdbdash.term.prototype.filter">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>filter
        <span class="apidocSignatureSpan">(filter, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (filter, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'filter', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.FILTER);
  var args = [self, new Term(self._r).expr(filter)._wrap()]
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== 'default') {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `filter`', self._query, 'Available option is filter');
      }
    })
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.finally" id="apidoc.element.rethinkdbdash.term.prototype.finally">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>finally
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finally = function (handler) {
  return this.run().finally(handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
Pool.prototype.drainLocalhost = function() {
var self = this;
// All the connections are to localhost, let's create new ones (not to localhost)
self._connectionToReplace = self._numConnections;
;
for(var i=0, numConnections=self._numConnections; i&lt;numConnections; i++) {
  self.createConnection().<span class="apidocCodeKeywordSpan">finally</span>(function() {
    self._localhostToDrain++;
    self._connectionToReplace--;
    if ((self._connectionToReplace === 0) &amp;&amp; (self._localhostToDrain &gt; 0)) {
      var len = self._pool.getLength();
      for(var j=0; j&lt;len; j++) {
        if (self._localhostToDrain === 0) {
          break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.floor" id="apidoc.element.rethinkdbdash.term.prototype.floor">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>floor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">floor = function () {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'floor', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.FLOOR)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var queryStr = JSON.stringify(query);
var querySize = Buffer.byteLength(queryStr);

var buffer = new Buffer(8+4+querySize);
buffer.writeUInt32LE(token &amp; 0xFFFFFFFF, 0)
buffer.writeUInt32LE(Math.<span class="apidocCodeKeywordSpan">floor</span>(token / 0xFFFFFFFF), 4)

buffer.writeUInt32LE(querySize, 8);

buffer.write(queryStr, 12);

// noreply instead of noReply because the otpions are translated for the server
if ((!helper.isPlainObject(options)) || (options.noreply != true)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.fold" id="apidoc.element.rethinkdbdash.term.prototype.fold">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>fold
        <span class="apidocSignatureSpan">(base, func, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fold = function (base, func, options) {
  if (this._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 2, 3, 'range', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.FOLD)
  var args = [this, new Term(this._r).expr(base), new Term(this._r).expr(func)._wrap()];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'emit') &amp;&amp; (key !== 'finalEmit')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `fold`. Available options are emit &lt;function&gt;, finalEmit
 &lt;function&gt;');
      }
    });
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.forEach" id="apidoc.element.rethinkdbdash.term.prototype.forEach">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>forEach
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (func) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'forEach', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.FOR_EACH);
  var args = [this, new Term(this._r).expr(func)._wrap()];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.friday" id="apidoc.element.rethinkdbdash.term.prototype.friday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>friday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">friday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.FRIDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.ge" id="apidoc.element.rethinkdbdash.term.prototype.ge">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ge
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ge = function (other) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'ge', this);

  var term = new Term(this._r);
  term._query.push(termTypes.GE)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.geojson" id="apidoc.element.rethinkdbdash.term.prototype.geojson">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>geojson
        <span class="apidocSignatureSpan">(geometry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">geojson = function (geometry) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'geojson', this);
  }
  this._noPrefix(this, 'geojson');
  var term = new Term(this._r);
  term._query.push(termTypes.GEOJSON);
  var args = [new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.get" id="apidoc.element.rethinkdbdash.term.prototype.get">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>get
        <span class="apidocSignatureSpan">(primaryKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (primaryKey) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'get', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.GET);
  var args = [this, new Term(this._r).expr(primaryKey)]
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Connections are managed by the driver with an efficient connection pool.
Once you have imported the driver, you can immediately run queries,
you don't need to call `r.connect`, or pass a connection to `run`.

```js
var r = require('rethinkdbdash')();
r.table('users').<span class="apidocCodeKeywordSpan">get</span>('orphee@gmail.com').run().then(function(user
) {
  // ...
}).error(handleError)
```

- Cursors are coerced to arrays by default

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.getAll" id="apidoc.element.rethinkdbdash.term.prototype.getAll">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAll = function () {
  // We explicitly _args here, so fastArityRange is not useful
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.GET_ALL);

  var args = [];
  args.push(this);
  for(var i=0; i&lt;_args.length-1; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  if ((_args.length &gt; 0) &amp;&amp; (helper.isPlainObject(_args[_args.length-1])) &amp;&amp; (_args[_args.length-1].index !== undefined)) {
    term._fillArgs(args);
    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);
  }
  else if (_args.length &gt; 0) {
    args.push(new Term(this._r).expr(_args[_args.length-1]))
    term._fillArgs(args);
  } else {
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.getField" id="apidoc.element.rethinkdbdash.term.prototype.getField">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getField
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getField = function (field) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, '(...)', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.GET_FIELD)
  var args = [this, new Term(this._r).expr(field)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.getIntersecting" id="apidoc.element.rethinkdbdash.term.prototype.getIntersecting">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getIntersecting
        <span class="apidocSignatureSpan">(geometry, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIntersecting = function (geometry, options) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, 'getIntersecting', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.GET_INTERSECTING);
  var args = [this, new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== 'index') {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distance`', self._query, 'Available options are index
 &lt;string&gt;');
      }
    });
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.getNearest" id="apidoc.element.rethinkdbdash.term.prototype.getNearest">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getNearest
        <span class="apidocSignatureSpan">(geometry, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNearest = function (geometry, options) {
  var self = this;
  if (self._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arity(_args, 2, 'getNearest', self);
  }
  var term = new Term(self._r);
  term._query.push(termTypes.GET_NEAREST);
  var args = [self, new Term(self._r).expr(geometry)];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'index') &amp;&amp; (key !== 'maxResults') &amp;&amp; (key !== 'maxDist') &amp;&amp; (key !== 'unit') &amp;&amp; (key !== 'geoSystem')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `getNearest`', self._query, 'Available options are index
 &lt;string&gt;, maxResults &lt;number&gt;, maxDist &lt;number&gt;, unit &lt;string&gt;, geoSystem &lt;string&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.grant" id="apidoc.element.rethinkdbdash.term.prototype.grant">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>grant
        <span class="apidocSignatureSpan">(name, access)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">grant = function (name, access) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, 'grant', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.GRANT)
  var args = [this, new Term(this._r).expr(name), new Term(this._r).expr(access)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.group" id="apidoc.element.rethinkdbdash.term.prototype.group">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>group
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">group = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  var self = this;
  self._arityRange(_args, 1, Infinity, 'group', self);

  var term = new Term(self._r);
  term._query.push(termTypes.GROUP);
  var args = [self];
  for(var i=0; i&lt;_args.length-1; i++) {
    args.push(new Term(self._r).expr(_args[i])._wrap())
  }
  if (_args.length &gt; 0) {
    if (helper.isPlainObject(_args[_args.length-1])) {
      helper.loopKeys(_args[_args.length-1], function(obj, key) {
         if ((key !== 'index')
        &amp;&amp; (key !==  'multi')) {
          throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `group`', self._query, 'Available options are index: &lt;
string&gt;, multi &lt;boolean&gt;');
        }
      });
      term._fillArgs(args);
      term._query.push(new Term(self._r).expr(translateOptions(_args[_args.length-1]))._query);
    }
    else {
      args.push(new Term(self._r).expr(_args[_args.length-1])._wrap())
      term._fillArgs(args);
    }
  }
  else {
    term._fillArgs(args);
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.gt" id="apidoc.element.rethinkdbdash.term.prototype.gt">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>gt
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gt = function (other) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'gt', this);

  var term = new Term(this._r);
  term._query.push(termTypes.GT)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.hasFields" id="apidoc.element.rethinkdbdash.term.prototype.hasFields">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>hasFields
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasFields = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'hasFields', this);

  var term = new Term(this._r);
  term._query.push(termTypes.HAS_FIELDS)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.hours" id="apidoc.element.rethinkdbdash.term.prototype.hours">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>hours
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hours = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'hours', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.HOURS)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.http" id="apidoc.element.rethinkdbdash.term.prototype.http">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>http
        <span class="apidocSignatureSpan">(url, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http = function (url, options) {
  this._noPrefix(this, 'http');
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'http', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.HTTP);
  var args = [new Term(this._r).expr(url)];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'timeout')
        &amp;&amp; (key !==  'attempts')
        &amp;&amp; (key !==  'redirects')
        &amp;&amp; (key !==  'verify')
        &amp;&amp; (key !==  'resultFormat')
        &amp;&amp; (key !==  'method')
        &amp;&amp; (key !==  'auth')
        &amp;&amp; (key !==  'params')
        &amp;&amp; (key !==  'header')
        &amp;&amp; (key !==  'data')
        &amp;&amp; (key !==  'page')
        &amp;&amp; (key !==  'pageLimit')
        &amp;&amp; (key !==  '')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `http`. Available options are attempts &lt;number&gt;, redirects
 &lt;number&gt;, verify &lt;boolean&gt;, resultFormat: &lt;string&gt;, method: &lt;string&gt;, auth: &lt;object&gt;, params: &lt;object&gt;, header: &lt;string&gt;, data: &lt;
string&gt;, page: &lt;string/function&gt;, pageLimit: &lt;number&gt;');
      }
    });

    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.inTimezone" id="apidoc.element.rethinkdbdash.term.prototype.inTimezone">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>inTimezone
        <span class="apidocSignatureSpan">(timezone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inTimezone = function (timezone) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'inTimezone', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.IN_TIMEZONE)
  var args = [this, new Term(this._r).expr(timezone)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.includes" id="apidoc.element.rethinkdbdash.term.prototype.includes">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>includes
        <span class="apidocSignatureSpan">(geometry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includes = function (geometry) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'includes', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.INCLUDES);
  var args = [this, new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexCreate" id="apidoc.element.rethinkdbdash.term.prototype.indexCreate">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexCreate
        <span class="apidocSignatureSpan">(name, fn, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexCreate = function (name, fn, options) {
  if (this._fastArityRange(arguments.length, 1, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 3, 'indexCreate', this);
  }

  if ((options == null) &amp;&amp; (helper.isPlainObject(fn))) {
    options = fn;
    fn = undefined;
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_CREATE);
  var args = [this];
  args.push(new Term(this._r).expr(name));
  if (typeof fn !== 'undefined') args.push(new Term(this._r).expr(fn)._wrap());
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    // There is no need to translate here
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'multi') &amp;&amp; (key !== 'geo')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `indexCreate`', self._query, 'Available option is multi
 &lt;bool&gt; and geo &lt;bool&gt;');
      }
    });
    term._query.push(new Term(this._r).expr(options)._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexDrop" id="apidoc.element.rethinkdbdash.term.prototype.indexDrop">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexDrop
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexDrop = function (name) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'indexDrop', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_DROP);
  var args = [this, new Term(this._r).expr(name)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexList" id="apidoc.element.rethinkdbdash.term.prototype.indexList">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexList = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'indexList', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_LIST);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexRename" id="apidoc.element.rethinkdbdash.term.prototype.indexRename">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexRename
        <span class="apidocSignatureSpan">(oldName, newName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexRename = function (oldName, newName, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 2, 3, 'indexRename', self);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_RENAME);
  var args = [this, new Term(this._r).expr(oldName), new Term(this._r).expr(newName)];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== 'overwrite') {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `indexRename`', self._query, 'Available options are overwrite
 &lt;bool&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }


  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexStatus" id="apidoc.element.rethinkdbdash.term.prototype.indexStatus">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexStatus
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexStatus = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_STATUS);
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexWait" id="apidoc.element.rethinkdbdash.term.prototype.indexWait">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexWait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexWait = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_WAIT);
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexesOf" id="apidoc.element.rethinkdbdash.term.prototype.indexesOf">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexesOf
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexesOf = function (predicate) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'indexesOf', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.OFFSETS_OF)
  var args = [this, new Term(this._r).expr(predicate)._wrap()];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.info" id="apidoc.element.rethinkdbdash.term.prototype.info">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>info
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">info = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'info', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INFO);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.innerJoin" id="apidoc.element.rethinkdbdash.term.prototype.innerJoin">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>innerJoin
        <span class="apidocSignatureSpan">(sequence, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">innerJoin = function (sequence, predicate) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, 'innerJoin', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INNER_JOIN);
  var args = [this._query];
  args.push(new Term(this._r).expr(sequence)._query);
  args.push(new Term(this._r).expr(predicate)._wrap()._query);
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.insert" id="apidoc.element.rethinkdbdash.term.prototype.insert">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>insert
        <span class="apidocSignatureSpan">(documents, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (documents, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'insert', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.INSERT);
  var args = [self, new Term(self._r).expr(documents)];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'returnChanges') &amp;&amp; (key !== 'durability') &amp;&amp; (key !== 'conflict')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `insert`', self._query, 'Available options are returnChanges
 &lt;bool&gt;, durability &lt;string&gt;, conflict &lt;string&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var pendingCallback = self._pendingCallback;
self._pendingCallback = null;
if (typeof pendingCallback === 'function') {
  pendingCallback();
}

var query = self._table.<span class="apidocCodeKeywordSpan">insert</span>(cache, self._insertOptions);
if (self._options.format === 'primaryKey') {
  query = query.do(function(result) {
    return self._r.branch(
      result('errors').eq(0),
      self._table.config()('primary_key').do(function(primaryKey) {
        return result('changes')('new_val')(primaryKey)
      }),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.insertAt" id="apidoc.element.rethinkdbdash.term.prototype.insertAt">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>insertAt
        <span class="apidocSignatureSpan">(index, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertAt = function (index, value) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, 'insertAt', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INSERT_AT)
  var args = [this, new Term(this._r).expr(index), new Term(this._r).expr(value)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.intersects" id="apidoc.element.rethinkdbdash.term.prototype.intersects">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>intersects
        <span class="apidocSignatureSpan">(geometry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersects = function (geometry) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'intersects', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.INTERSECTS);
  var args = [this, new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.isEmpty" id="apidoc.element.rethinkdbdash.term.prototype.isEmpty">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'isEmpty', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.IS_EMPTY)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.january" id="apidoc.element.rethinkdbdash.term.prototype.january">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>january
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">january = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.JANUARY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.js" id="apidoc.element.rethinkdbdash.term.prototype.js">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>js
        <span class="apidocSignatureSpan">(arg, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">js = function (arg, options) {
  this._noPrefix(this, 'js');
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'js', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.JAVASCRIPT)
  var args = [new Term(this._r).expr(arg)];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.json" id="apidoc.element.rethinkdbdash.term.prototype.json">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>json
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (json) {
  this._noPrefix(this, 'json');
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'info', this);
  }
<span class="apidocCodeCommentSpan">  /*
  if ((/\\u0000/.test(json)) || (/\0/.test(json))) {
    this._error = new Error.ReqlDriverError('The null character is currently not supported by RethinkDB');
  }
  */
</span>  var term = new Term(this._r);
  term._query.push(termTypes.JSON);

  var args = [new Term(this._r).expr(json)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.july" id="apidoc.element.rethinkdbdash.term.prototype.july">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>july
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">july = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.JULY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.june" id="apidoc.element.rethinkdbdash.term.prototype.june">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>june
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">june = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.JUNE);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.keys" id="apidoc.element.rethinkdbdash.term.prototype.keys">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keys = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'keys', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.KEYS)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if ((index === 0) &amp;&amp; ((father == null) || (!nonPrefix[father[0]]))) carify(result, 'r.expr(', underline)

if (typeof term === 'string' ) {
  carify(result, '"'+term+'"', underline);
}
else if (helper.isPlainObject(term)) {
  var totalKeys = Object.<span class="apidocCodeKeywordSpan">keys</span>(term).length;
  if (totalKeys === 0) {
    carify(result, '{}', underline);
  }
  else {
    carify(result, '{\n', underline);
    var countKeys = 0;
    var extraToRemove = options.extra;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.le" id="apidoc.element.rethinkdbdash.term.prototype.le">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>le
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">le = function (other) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'le', this);

  var term = new Term(this._r);
  term._query.push(termTypes.LE)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.limit" id="apidoc.element.rethinkdbdash.term.prototype.limit">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>limit
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">limit = function (value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'limit', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.LIMIT)
  var args = [this, new Term(this._r).expr(value)]
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.line" id="apidoc.element.rethinkdbdash.term.prototype.line">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">line = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  // Arity check is done by r.line
  this._noPrefix(this, 'line');

  var term = new Term(this._r);
  term._query.push(termTypes.LINE);

  var args = [];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.literal" id="apidoc.element.rethinkdbdash.term.prototype.literal">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>literal
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">literal = function (obj) {
  this._noPrefix(this, 'literal');
  // The test for arity is performed in r.literal

  var term = new Term(this._r);
  term._query.push(termTypes.LITERAL);
  if (arguments.length &gt; 0) {
    var args = [new Term(this._r).expr(obj)];
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.lt" id="apidoc.element.rethinkdbdash.term.prototype.lt">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>lt
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lt = function (other) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'lt', this);

  var term = new Term(this._r);
  term._query.push(termTypes.LT)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.map" id="apidoc.element.rethinkdbdash.term.prototype.map">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>map
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'map', this);

  var term = new Term(this._r);
  term._query.push(termTypes.MAP);
  var args = [];
  if (!Array.isArray(this._query) || (this._query.length &gt; 0)) {
    args.push(this);
  }
  for(var i=0; i&lt;_args.length-1; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  // Make sure that we don't push undefined if no argument is passed to map,
  // in which case the server will handle the case and return an error.
  if (_args.length&gt; 0) {
    args.push(new Term(this._r).expr(_args[_args.length-1])._wrap())
  }
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



var dbName = util.uuid()
var tableName = util.uuid()

var query; // without `.run()`
//query = 'r.table("foo").add(1).add(1).add("hello-super-long-string").add("another-long-string"
;).add("one-last-string").<span class="apidocCodeKeywordSpan">map</span>( function(doc) { return r.expr([1,2,3,4,5,6,7
,8,9,10,11,12,13,14,15,16]).map(function(test) { return test("b").add("hello-super-long-string").add("another
-long-string").add("one-last-string").add("hello-super-long-string").add("another-long-string"
;).add("one-last-string").add("hello-super-long-string").add("another-long-string").add("one-
last-string").add("hello-super-long-string").add("another-long-string").add("one-last-string").
add("hello-super-long-string").add("another-long-string").add("one-last-string").mul(test("b&amp;#
x22;)).merge({ firstName: "xxxxxx", lastName: "yyyy", email: "xxxxx@yyyy.com", phone: "xxx-xxx
-xxxx" }); }).add(2).map(function(doc) { return doc.add("hello-super-long-string").add("another-long-string&amp;#
x22;).add("one-last-string").add("hello-super-long-string").add("another-long-string").add("one
-last-string").add("hello-super-long-string").add("another-long-string").add("one-last-string"
;).add("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello
-super-long-string").add("another-long-string").add("one-last-string") }); })';
query = 'r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })';
Promise.coroutine(function* () {
  try {
yield r.dbCreate(dbName).run();
yield r.db(dbName).tableCreate(tableName).run();

var result = yield eval(query).run();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.march" id="apidoc.element.rethinkdbdash.term.prototype.march">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>march
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">march = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.MARCH);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.match" id="apidoc.element.rethinkdbdash.term.prototype.match">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>match
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (regex) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'match', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MATCH)
  var args = [this, new Term(this._r).expr(regex)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
else {
  if (self._closed === false) {
    if (self._stackSize &lt;= MAX_CALL_STACK) {
      self._next().then(resolve).error(function(error) {
        if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &amp;&amp;
            (error.message.<span class="apidocCodeKeywordSpan">match</span>(/You cannot call `next` on a closed/) === null)) {
          reject(error);
        }
      });
    }
    else {
      setTimeout(function() {
        self._stackSize = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.max" id="apidoc.element.rethinkdbdash.term.prototype.max">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>max
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function (field) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'max', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MAX)
  var args = [this];
  if (field !== undefined) {
    if (helper.isPlainObject(field)) {
      term._fillArgs(args);
      term._query.push(new Term(this._r).expr(translateOptions(field))._query);
    }
    else {
      args.push(new Term(this._r).expr(field)._wrap())
      term._fillArgs(args);
    }
  }
  else {
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.maxval" id="apidoc.element.rethinkdbdash.term.prototype.maxval">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>maxval
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxval = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.MAXVAL);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.may" id="apidoc.element.rethinkdbdash.term.prototype.may">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>may
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">may = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.MAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.merge" id="apidoc.element.rethinkdbdash.term.prototype.merge">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>merge
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (arg) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'merge', this);

  var term = new Term(this._r);
  term._query.push(termTypes.MERGE)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i])._wrap())
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



var dbName = util.uuid()
var tableName = util.uuid()

var query; // without `.run()`
//query = 'r.table("foo").add(1).add(1).add("hello-super-long-string").add("another-long-string"
;).add("one-last-string").map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test
) { return test("b").add("hello-super-long-string").add("another-long-string").add("one-last-
string").add("hello-super-long-string").add("another-long-string").add("one-last-string").add
("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello-super
-long-string").add("another-long-string").add("one-last-string").add("hello-super-long-string"
;).add("another-long-string").add("one-last-string").mul(test("b")).<span class="apidocCodeKeywordSpan
">merge</span>({ firstName: "xxxxxx", lastName: "yyyy", email: "xxxxx@yyyy.com", phone: "xxx-
xxx-xxxx" }); }).add(2).map(function(doc) { return doc.add("hello-super-long-string").add("another-long-string
").add("one-last-string").add("hello-super-long-string").add("another-long-string").add("
;one-last-string").add("hello-super-long-string").add("another-long-string").add("one-last-string&amp;#
x22;).add("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello
-super-long-string").add("another-long-string").add("one-last-string") }); })';
query = 'r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })';
Promise.coroutine(function* () {
  try {
yield r.dbCreate(dbName).run();
yield r.db(dbName).tableCreate(tableName).run();

var result = yield eval(query).run();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.min" id="apidoc.element.rethinkdbdash.term.prototype.min">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>min
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">min = function (field) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'min', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MIN)
  var args = [this];
  if (field !== undefined) {
    if (helper.isPlainObject(field)) {
      term._fillArgs(args);
      term._query.push(new Term(this._r).expr(translateOptions(field))._query);
    }
    else {
      args.push(new Term(this._r).expr(field)._wrap());
      term._fillArgs(args);
    }
  }
  else {
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return result;
}
module.exports.splitCommaEqual = splitCommaEqual;

function xorBuffer(a, b) {
  var result = [];
  var len = Math.<span class="apidocCodeKeywordSpan">min</span>(a.length, b.length)
  for(var i=0; i&lt;len; i++) {
    result.push(a[i] ^ b[i]);
  }
  return new Buffer(result);
}
module.exports.xorBuffer = xorBuffer;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.minutes" id="apidoc.element.rethinkdbdash.term.prototype.minutes">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>minutes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minutes = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'minutes', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MINUTES)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.minval" id="apidoc.element.rethinkdbdash.term.prototype.minval">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>minval
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minval = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.MINVAL);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.mod" id="apidoc.element.rethinkdbdash.term.prototype.mod">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>mod
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mod = function (b) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'mod', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MOD)
  var args = [this, new Term(this._r).expr(b)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.monday" id="apidoc.element.rethinkdbdash.term.prototype.monday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>monday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.MONDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.month" id="apidoc.element.rethinkdbdash.term.prototype.month">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>month
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">month = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'month', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MONTH)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.mul" id="apidoc.element.rethinkdbdash.term.prototype.mul">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>mul
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mul = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'mul', this);

  var term = new Term(this._r);
  term._query.push(termTypes.MUL)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



var dbName = util.uuid()
var tableName = util.uuid()

var query; // without `.run()`
//query = 'r.table("foo").add(1).add(1).add("hello-super-long-string").add("another-long-string"
;).add("one-last-string").map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test
) { return test("b").add("hello-super-long-string").add("another-long-string").add("one-last-
string").add("hello-super-long-string").add("another-long-string").add("one-last-string").add
("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello-super
-long-string").add("another-long-string").add("one-last-string").add("hello-super-long-string"
;).add("another-long-string").add("one-last-string").<span class="apidocCodeKeywordSpan">mul</span>(test("
;b")).merge({ firstName: "xxxxxx", lastName: "yyyy", email: "xxxxx@yyyy.com", phone: "xxx
-xxx-xxxx" }); }).add(2).map(function(doc) { return doc.add("hello-super-long-string").add("another-long-string
").add("one-last-string").add("hello-super-long-string").add("another-long-string").add("
;one-last-string").add("hello-super-long-string").add("another-long-string").add("one-last-string&amp;#
x22;).add("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello
-super-long-string").add("another-long-string").add("one-last-string") }); })';
query = 'r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })';
Promise.coroutine(function* () {
  try {
yield r.dbCreate(dbName).run();
yield r.db(dbName).tableCreate(tableName).run();

var result = yield eval(query).run();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.ne" id="apidoc.element.rethinkdbdash.term.prototype.ne">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ne
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ne = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'ne', this);

  var term = new Term(this._r);
  term._query.push(termTypes.NE)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.not" id="apidoc.element.rethinkdbdash.term.prototype.not">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">not = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'not', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.NOT)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.november" id="apidoc.element.rethinkdbdash.term.prototype.november">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>november
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">november = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.NOVEMBER);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.now" id="apidoc.element.rethinkdbdash.term.prototype.now">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>now
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">now = function () {
  this._noPrefix(this, 'now');

  var term = new Term(this._r);
  term._query.push(termTypes.NOW)
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.nth" id="apidoc.element.rethinkdbdash.term.prototype.nth">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>nth
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nth = function (value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'nth', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.NTH)
  var args = [this._query, new Term(this._r).expr(value)]
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.object" id="apidoc.element.rethinkdbdash.term.prototype.object">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>object
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">object = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._noPrefix(this, 'object');
  this._arityRange(_args, 0, Infinity, 'object', this);

  var term = new Term(this._r);
  term._query.push(termTypes.OBJECT)
  var args = [];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.october" id="apidoc.element.rethinkdbdash.term.prototype.october">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>october
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">october = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.OCTOBER);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.offsetsOf" id="apidoc.element.rethinkdbdash.term.prototype.offsetsOf">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>offsetsOf
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">offsetsOf = function (predicate) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'indexesOf', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.OFFSETS_OF)
  var args = [this, new Term(this._r).expr(predicate)._wrap()];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.or" id="apidoc.element.rethinkdbdash.term.prototype.or">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>or
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">or = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.OR)
  var args = [];
  if (!Array.isArray(this._query) || (this._query.length &gt; 0)) {
    args.push(this);
  }
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.orderBy" id="apidoc.element.rethinkdbdash.term.prototype.orderBy">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>orderBy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">orderBy = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'orderBy', this);

  var term = new Term(this._r);
  term._query.push(termTypes.ORDER_BY);

  var args = [this];
  for(var i=0; i&lt;_args.length-1; i++) {
    if ((_args[i] instanceof Term) &amp;&amp;
        ((_args[i]._query[0] === termTypes.DESC) || (_args[i]._query[0] === termTypes.ASC))) {
      args.push(new Term(this._r).expr(_args[i]))
    }
    else {
      args.push(new Term(this._r).expr(_args[i])._wrap())
    }
  }
  // We actually don't need to make the difference here, but...
  if ((_args.length &gt; 0) &amp;&amp; (helper.isPlainObject(_args[_args.length-1])) &amp;&amp; (_args[_args.length-1].index !== undefined)) {
    term._fillArgs(args);
    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);
  }
  else {
    if ((_args[_args.length-1] instanceof Term) &amp;&amp;
      ((_args[_args.length-1]._query[0] === termTypes.DESC) || (_args[_args.length-1]._query[0] === termTypes.ASC))) {
      args.push(new Term(this._r).expr(_args[_args.length-1]))
    }
    else {
      args.push(new Term(this._r).expr(_args[_args.length-1])._wrap())
    }
    term._fillArgs(args);
  }
  return term;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.outerJoin" id="apidoc.element.rethinkdbdash.term.prototype.outerJoin">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>outerJoin
        <span class="apidocSignatureSpan">(sequence, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outerJoin = function (sequence, predicate) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, 'outerJoin', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.OUTER_JOIN);
  var args = [this];
  args.push(new Term(this._r).expr(sequence));
  args.push(new Term(this._r).expr(predicate)._wrap());
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.pluck" id="apidoc.element.rethinkdbdash.term.prototype.pluck">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>pluck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pluck = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'pluck', this);

  var term = new Term(this._r);
  term._query.push(termTypes.PLUCK)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.point" id="apidoc.element.rethinkdbdash.term.prototype.point">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>point
        <span class="apidocSignatureSpan">(longitude, latitude)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">point = function (longitude, latitude) {
  // Arity check is done by r.point
  this._noPrefix(this, 'point');

  var term = new Term(this._r);
  term._query.push(termTypes.POINT);
  var args = [new Term(this._r).expr(longitude), new Term(this._r).expr(latitude)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.polygon" id="apidoc.element.rethinkdbdash.term.prototype.polygon">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>polygon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">polygon = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  // Arity check is done by r.polygon
  this._noPrefix(this, 'polygon');

  var term = new Term(this._r);
  term._query.push(termTypes.POLYGON);

  var args = [];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.polygonSub" id="apidoc.element.rethinkdbdash.term.prototype.polygonSub">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>polygonSub
        <span class="apidocSignatureSpan">(geometry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">polygonSub = function (geometry) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'polygonSub', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.POLYGON_SUB);
  var args = [this, new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.prepend" id="apidoc.element.rethinkdbdash.term.prototype.prepend">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>prepend
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function (value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'prepend', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.PREPEND)
  var args = [this, new Term(this._r).expr(value)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.random" id="apidoc.element.rethinkdbdash.term.prototype.random">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>random
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">random = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  var self = this;
  self._noPrefix(this, 'random');
  self._arityRange(_args, 0, 3, 'random', self);

  var term = new Term(self._r);
  term._query.push(termTypes.RANDOM);

  var args = [];
  for(var i=0; i&lt;_args.length-1; i++) {
    args.push(new Term(self._r).expr(_args[i]))
  }
  if (_args.length &gt; 0) {
    if (helper.isPlainObject(_args[_args.length-1])) {
      helper.loopKeys(_args[_args.length-1], function(obj, key) {
        if (key !== 'float') {
          throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `random`', self._query, 'Available option is float: &lt;
boolean&gt;');
        }
      });
      term._fillArgs(args);
      term._query.push(new Term(self._r).expr(translateOptions(_args[_args.length-1]))._query);
    }
    else {
      args.push(new Term(self._r).expr(_args[_args.length-1]))
      term._fillArgs(args);
    }
  }
  else {
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     for(var i=0; i&lt;self.options.buffer; i++) {
       if (self.getLength() &lt; self.options.max) {
         self.createConnection();
       }
     }
   }
 }, 0);
 this.id = Math.floor(Math.<span class="apidocCodeKeywordSpan">random</span>()*100000);
 this._log('Creating a pool connected to '+this.getAddress());
}

util.inherits(Pool, events.EventEmitter);
/*
* Events:
*  - draining // when `drain` is called
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.range" id="apidoc.element.rethinkdbdash.term.prototype.range">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>range
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">range = function (start, end) {
  this._noPrefix(this, 'range');
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'r.range', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.RANGE);
  var args = [];
  args.push(new Term(this._r).expr(start));
  if (end !== undefined) {
    args.push(new Term(this._r).expr(end));
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.rebalance" id="apidoc.element.rethinkdbdash.term.prototype.rebalance">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>rebalance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rebalance = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'rebalance', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.REBALANCE);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var dbName = util.uuid()
var tableName = util.uuid()

var query; // without `.run()`
//query = 'r.table("foo").add(1).add(1).add("hello-super-long-string").add("another-long-string"
;).add("one-last-string").map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test
) { return test("b").add("hello-super-long-string").add("another-long-string").add("one-last-
string").add("hello-super-long-string").add("another-long-string").add("one-last-string").add
("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello-super
-long-string").add("another-long-string").add("one-last-string").add("hello-super-long-string"
;).add("another-long-string").add("one-last-string").mul(test("b")).merge({ firstName: "xxxxxx
", lastName: "yyyy", email: "xxxxx@yyyy.com", phone: "xxx-xxx-xxxx" }); }).add(2).map(function
(doc) { return doc.add("hello-super-long-string").add("another-long-string").add("one-last-string").
add("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello-super
-long-string").add("another-long-string").add("one-last-string").add("hello-super-long-string"
;).add("another-long-string").add("one-last-string").add("hello-super-long-string").add("another
-long-string").add("one-last-string") }); })';
query = 'r.db(dbName).table(tableName).<span class="apidocCodeKeywordSpan">rebalance</span>().do(function(x) { return x.add
(4) })';
Promise.coroutine(function* () {
  try {
yield r.dbCreate(dbName).run();
yield r.db(dbName).tableCreate(tableName).run();

var result = yield eval(query).run();
throw new Error("Should have thrown an error");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.reconfigure" id="apidoc.element.rethinkdbdash.term.prototype.reconfigure">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>reconfigure
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconfigure = function (config) {
  var self = this;
  if (self._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arity(_args, 1, 'reconfigure', self);
  }
  var term = new Term(self._r);
  term._query.push(termTypes.RECONFIGURE);

  var args = [this];
  term._fillArgs(args);
  if (helper.isPlainObject(config)) {
    helper.loopKeys(config, function(obj, key) {
      if ((key !== 'shards') &amp;&amp; (key !== 'replicas') &amp;&amp;
        (key !== 'dryRun') &amp;&amp; (key !== 'primaryReplicaTag') &amp;&amp;
        (key !== 'nonvotingReplicaTags') &amp;&amp; (key !== 'emergencyRepair')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `reconfigure`', self._query, 'Available options are shards
: &lt;number&gt;, replicas: &lt;number&gt;, primaryReplicaTag: &lt;object&gt;, dryRun &lt;boolean&gt;, emergencyRepair: &lt;string&gt;, nonvotingReplicaTags: &lt;
array&lt;string&gt;&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(config))._query);
  }
  else {
    throw new Error.ReqlDriverError('First argument of `reconfigure` must be an object');
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.reduce" id="apidoc.element.rethinkdbdash.term.prototype.reduce">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>reduce
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reduce = function (func) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'reduce', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.REDUCE)
  var args = [this, new Term(this._r).expr(func)._wrap()];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.replace" id="apidoc.element.rethinkdbdash.term.prototype.replace">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>replace
        <span class="apidocSignatureSpan">(newValue, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (newValue, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'replace', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.REPLACE);
  var args = [self, new Term(self._r).expr(newValue)._wrap()];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'returnChanges') &amp;&amp; (key !== 'durability') &amp;&amp; (key !== 'nonAtomic')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `replace`', self._query, 'Available options are returnChanges
 &lt;bool&gt;, durability &lt;string&gt;, nonAtomic &lt;bool&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  else {
    carify(result, ''+term, underline);
  }

  if ((index === 0) &amp;&amp; ((father == null) || (!nonPrefix[father[0]]))) carify(result, ')', underline);

  if (underline) result.car = result.str.<span class="apidocCodeKeywordSpan">replace</span>(/./g, '^');

  return result;
},
TABLE: function(term, index, father, frames, options) {
  var result = {
    str: '',
    car: ''
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.round" id="apidoc.element.rethinkdbdash.term.prototype.round">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>round
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">round = function () {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'round', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.ROUND)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.row" id="apidoc.element.rethinkdbdash.term.prototype.row">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>row
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">row = function () {
  this._noPrefix(this, 'row');
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'r.row', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.IMPLICIT_VAR)
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.run" id="apidoc.element.rethinkdbdash.term.prototype.run">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>run
        <span class="apidocSignatureSpan">(connection, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (connection, options, callback) {
  var self = this;

  if (self._error != null) {
    var error = new Error.ReqlRuntimeError(self._error, self._query, {b: self._frames});
    return Promise.reject(error);
  }

  if (helper.isPlainObject(connection) &amp;&amp; (typeof connection._isConnection === 'function') &amp;&amp; (connection._isConnection() === true
)) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    else {
      if (!helper.isPlainObject(options)) options = {};
    }

    if (connection._isOpen() !== true) {
      return new Promise(function(resolve, reject) {
        reject(new Error.ReqlDriverError('`run` was called with a closed connection', self._query).setOperational());
      });
    }
    var p = new Promise(function(resolve, reject) {
      var token = connection._getToken();

      var query = [protodef.Query.QueryType.START];
      query.push(self._query);

      var _options = {};
      var sendOptions = false;
      if (connection.db != null) {
        sendOptions = true;
        _options.db = self._r.db(connection.db)._query;
      }

      if (self._r.arrayLimit != null) {
        sendOptions = true;
        _options[self._translateArgs['arrayLimit']] = self._r.arrayLimit;
      };


      var keepGoing = true; // we need it just to avoir calling resolve/reject multiple times
      helper.loopKeys(options, function(options, key) {
        if (keepGoing === true) {
          if ((key === 'readMode') || (key === 'durability') || (key === 'db') ||
            (key === 'noreply') || (key === 'arrayLimit') || (key === 'profile') ||
            (key === 'minBatchRows') || (key === 'maxBatchRows') || (key === 'maxBatchBytes') ||
            (key === 'maxBatchSeconds') || (key === 'firstBatchScaledownFactor')) {

            sendOptions = true;
            if (key === 'db') {
              _options[key] = self._r.db(options[key])._query;
            }
            else if (self._translateArgs.hasOwnProperty(key)) {
              _options[self._translateArgs[key]] = new Term(self._r).expr(options[key])._query;
            }
            else {
              _options[key] = new Term(self._r).expr(options[key])._query;
            }
          }
          else if ((key !== 'timeFormat') &amp;&amp; (key !== 'groupFormat') &amp;&amp;
              (key !== 'binaryFormat') &amp;&amp; (key !== 'cursor') &amp;&amp;
              (key !== 'readable') &amp;&amp; (key !== 'writable') &amp;&amp;
              (key !== 'transform') &amp;&amp; (key !== 'stream') &amp;&amp;
              (key !== 'highWaterMark')) {
            reject(new Error.ReqlDriverError('Unrecognized option `'+key+'` in `run`. Available options are readMode &lt;string&gt;, durability
 &lt;string&gt;, noreply &lt;bool&gt;, timeFormat &lt;string&gt;, groupFormat: &lt;string&gt;, profile &lt;bool&gt;, binaryFormat &lt;bool&gt;, cursor &lt;bool&gt;, stream
 &lt;bool&gt;'));
            keepGoing = false;
          }
        }
      });

      if (keepGoing === false) {
        connection.emit('release');
        return // The promise was rejected in the loopKeys
      }

      if (sendOptions === true) {
        query.push(_options);
      }
      connection._send(query, token, resolve, reject, self._query, options);
    }).nodeify(callback);
  }
  else {
    var poolMaster = self._r.getPoolMaster(); // if self._r is defined, so is self._r.getPool()
    if (!poolMaster) {
      throw new Error.ReqlDriverError('`run` was called without a connection and no pool has been created', self._query);
    }
    else {
      if (typeof connection === 'function') {
        // run(callback);
        callback = connection;
        options = {};
      }
      else if (helper.isPlainObject(connection)) {
        // run(options[, callback])
        callback = options;
        options = connection;
      }
      else {
        options = {};
      }


      var p = new Promise(function(resolve, reject) {
        poolMaster.getConnection().then(function(connection) {
          var token = connection._getToken();
          var query = [protodef.Query.QueryType.START];
          query.push(self._query);

          var _options = {};
          var send ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Connections are managed by the driver with an efficient connection pool.
Once you have imported the driver, you can immediately run queries,
you don't need to call `r.connect`, or pass a connection to `run`.

```js
var r = require('rethinkdbdash')();
r.table('users').get('orphee@gmail.com').<span class="apidocCodeKeywordSpan">run</span>().then(function(user
) {
  // ...
}).error(handleError)
```

- Cursors are coerced to arrays by default

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.sample" id="apidoc.element.rethinkdbdash.term.prototype.sample">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sample
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sample = function (size) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'sample', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SAMPLE)
  var args = [this, new Term(this._r).expr(size)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.saturday" id="apidoc.element.rethinkdbdash.term.prototype.saturday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>saturday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saturday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.SATURDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.seconds" id="apidoc.element.rethinkdbdash.term.prototype.seconds">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>seconds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seconds = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'seconds', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SECONDS)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.september" id="apidoc.element.rethinkdbdash.term.prototype.september">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>september
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">september = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.SEPTEMBER);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.setDifference" id="apidoc.element.rethinkdbdash.term.prototype.setDifference">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setDifference
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDifference = function (other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'setDifference', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SET_DIFFERENCE)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.setInsert" id="apidoc.element.rethinkdbdash.term.prototype.setInsert">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setInsert
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setInsert = function (other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'setInsert', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SET_INSERT)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.setIntersection" id="apidoc.element.rethinkdbdash.term.prototype.setIntersection">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setIntersection
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setIntersection = function (other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'setIntersection', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SET_INTERSECTION)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.setUnion" id="apidoc.element.rethinkdbdash.term.prototype.setUnion">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setUnion
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setUnion = function (other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'setUnion', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SET_UNION)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.skip" id="apidoc.element.rethinkdbdash.term.prototype.skip">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>skip
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function (value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'skip', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SKIP)
  var args = [this, new Term(this._r).expr(value)]
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.slice" id="apidoc.element.rethinkdbdash.term.prototype.slice">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>slice
        <span class="apidocSignatureSpan">(start, end, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (start, end, options) {
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 3, 'slice', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SLICE);

  var args = [];
  args.push(this);
  args.push(new Term(this._r).expr(start));

  if ((end !== undefined) &amp;&amp; (options !== undefined)) {
    args.push(new Term(this._r).expr(end));
    term._fillArgs(args);
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  else if ((end !== undefined) &amp;&amp; (options === undefined)) {
    if (helper.isPlainObject(end) === false) {
      args.push(new Term(this._r).expr(end));
      term._fillArgs(args);
    }
    else {
      term._fillArgs(args);
      term._query.push(new Term(this._r).expr(translateOptions(end))._query);
    }
  }
  else { // end and options are both undefined
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return;
}
self.buffer = Buffer.concat([self.buffer, buffer]);

if (self.open == false) {
  for(var i=0; i&lt;self.buffer.length; i++) {
    if (self.buffer[i] === 0) {
      var messageServerStr = self.buffer.<span class="apidocCodeKeywordSpan">slice</span>(0, i).toString();
      self.buffer = self.buffer.slice(i+1); // +1 to remove the null byte
      try {
        var messageServer = JSON.parse(messageServerStr);
      } catch(error) {
        self._abort();
        reject(new Err.ReqlDriverError('Could not parse the message sent by the server : \''+messageServerStr+'
;\'').setOperational());
        return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.spliceAt" id="apidoc.element.rethinkdbdash.term.prototype.spliceAt">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>spliceAt
        <span class="apidocSignatureSpan">(index, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spliceAt = function (index, array) {
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'spliceAt', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SPLICE_AT)
  var args = [this, new Term(this._r).expr(index), new Term(this._r).expr(array)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.split" id="apidoc.element.rethinkdbdash.term.prototype.split">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>split
        <span class="apidocSignatureSpan">(separator, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (separator, max) {
  if (this._fastArityRange(arguments.length, 0, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 2, 'split', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SPLIT)
  var args = [this];
  if (separator !== undefined) {
    args.push(new Term(this._r).expr(separator))
    if (max !== undefined) {
      args.push(new Term(this._r).expr(max))
    }
  }
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

frames = frames.b;
if (frames) this.frames = frames.slice(0);
//this.frames = JSON.stringify(frames, null, 2);

var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});

var queryLines = backtrace.str.<span class="apidocCodeKeywordSpan">split</span>('\n');
var carrotLines = backtrace.car.split('\n');

for(var i=0; i&lt;queryLines.length; i++) {
  this.message += queryLines[i]+'\n';
  if (carrotLines[i].match(/\^/)) {
    var pos = queryLines[i].match(/[^\s]/);
    if ((pos) &amp;&amp; (pos.index)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.status" id="apidoc.element.rethinkdbdash.term.prototype.status">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>status
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">status = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'status', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.STATUS);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.sub" id="apidoc.element.rethinkdbdash.term.prototype.sub">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sub = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'sub', this);

  var term = new Term(this._r);
  term._query.push(termTypes.SUB)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.sum" id="apidoc.element.rethinkdbdash.term.prototype.sum">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sum
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sum = function (field) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'sum', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SUM);
  var args = [this];
  if (field !== undefined) {
    args.push(new Term(this._r).expr(field)._wrap())
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.sunday" id="apidoc.element.rethinkdbdash.term.prototype.sunday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sunday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sunday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.SUNDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.sync" id="apidoc.element.rethinkdbdash.term.prototype.sync">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sync = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'sync', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SYNC)
  var args = [this._query];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.table" id="apidoc.element.rethinkdbdash.term.prototype.table">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>table
        <span class="apidocSignatureSpan">(table, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">table = function (table, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'table', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.TABLE)

  var args = [];
  if (Array.isArray(self._query) &amp;&amp; (self._query.length &gt; 0)) {
    args.push(self);
  }
  args.push(new Term(self._r).expr(table))
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== 'readMode') {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `table`', self._query, 'Available option is readMode &lt;
string&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Connections are managed by the driver with an efficient connection pool.
Once you have imported the driver, you can immediately run queries,
you don't need to call `r.connect`, or pass a connection to `run`.

```js
var r = require('rethinkdbdash')();
r.<span class="apidocCodeKeywordSpan">table</span>('users').get('orphee@gmail.com').run().then(function(user
) {
  // ...
}).error(handleError)
```

- Cursors are coerced to arrays by default

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.tableCreate" id="apidoc.element.rethinkdbdash.term.prototype.tableCreate">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tableCreate
        <span class="apidocSignatureSpan">(table, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tableCreate = function (table, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'tableCreate', self);
  }


  var term = new Term(self._r);
  term._query.push(termTypes.TABLE_CREATE)

  var args = [];
  if (Array.isArray(self._query) &amp;&amp; (self._query.length &gt; 0)) {
    args.push(self); // Push db
  }
  args.push(new Term(self._r).expr(table))
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    // Check for non valid key
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'primaryKey')
          &amp;&amp; (key !== 'durability')
          &amp;&amp; (key !== 'shards')
          &amp;&amp; (key !== 'replicas')
          &amp;&amp; (key !== 'primaryReplicaTag')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `tableCreate`', self._query, 'Available options are primaryKey
 &lt;string&gt;, durability &lt;string&gt;, shards &lt;number&gt;, replicas &lt;number/object&gt;, primaryReplicaTag &lt;object&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var query; // without `.run()`
//query = 'r.table("foo").add(1).add(1).add("hello-super-long-string").add("another-long-string"
;).add("one-last-string").map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test
) { return test("b").add("hello-super-long-string").add("another-long-string").add("one-last-
string").add("hello-super-long-string").add("another-long-string").add("one-last-string").add
("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello-super
-long-string").add("another-long-string").add("one-last-string").add("hello-super-long-string"
;).add("another-long-string").add("one-last-string").mul(test("b")).merge({ firstName: "xxxxxx
", lastName: "yyyy", email: "xxxxx@yyyy.com", phone: "xxx-xxx-xxxx" }); }).add(2).map(function
(doc) { return doc.add("hello-super-long-string").add("another-long-string").add("one-last-string").
add("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello-super
-long-string").add("another-long-string").add("one-last-string").add("hello-super-long-string"
;).add("another-long-string").add("one-last-string").add("hello-super-long-string").add("another
-long-string").add("one-last-string") }); })';
query = 'r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })';
Promise.coroutine(function* () {
try {
  yield r.dbCreate(dbName).run();
  yield r.db(dbName).<span class="apidocCodeKeywordSpan">tableCreate</span>(tableName).run();

  var result = yield eval(query).run();
  throw new Error("Should have thrown an error");
}
catch(e) {
  console.log(e.message);
  console.log('')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.tableDrop" id="apidoc.element.rethinkdbdash.term.prototype.tableDrop">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tableDrop
        <span class="apidocSignatureSpan">(table)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tableDrop = function (table) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'tableDrop', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TABLE_DROP)

  var args = [];
  if (!Array.isArray(this._query) || (this._query.length &gt; 0)) {
    args.push(this); // push db
  }
  args.push(new Term(this._r).expr(table))
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.tableList" id="apidoc.element.rethinkdbdash.term.prototype.tableList">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tableList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tableList = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'tableList', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TABLE_LIST);

  var args = [];
  if (!Array.isArray(this._query) || (this._query.length &gt; 0)) {
    args.push(this);
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.then" id="apidoc.element.rethinkdbdash.term.prototype.then">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>then
        <span class="apidocSignatureSpan">(resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (resolve, reject) {
  return this.run().then(resolve, reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Connections are managed by the driver with an efficient connection pool.
Once you have imported the driver, you can immediately run queries,
you don't need to call `r.connect`, or pass a connection to `run`.

```js
var r = require('rethinkdbdash')();
r.table('users').get('orphee@gmail.com').run().<span class="apidocCodeKeywordSpan">then</span>(function(user
) {
  // ...
}).error(handleError)
```

- Cursors are coerced to arrays by default

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.thursday" id="apidoc.element.rethinkdbdash.term.prototype.thursday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>thursday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thursday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.THURSDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.time" id="apidoc.element.rethinkdbdash.term.prototype.time">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>time
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._noPrefix(this, 'time');
  // Special check for arity
  var foundArgs = false;
  for(var i=0; i&lt;_args.length; i++) {
    if ((_args[i] instanceof Term) &amp;&amp; (_args[i]._query[0] === termTypes.ARGS)) {
      foundArgs = true;
      break;
    }
  }
  if (foundArgs === false) {
    if ((_args.length !== 4) &amp;&amp; (_args.length !== 7)) {
      throw new Error.ReqlDriverError('`r.time` called with '+_args.length+' argument'+((_args.length&gt;1)?'s':''), null, '`r.time
` takes 4 or 7 arguments');
    }
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TIME)
  var args = [];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.timeOfDay" id="apidoc.element.rethinkdbdash.term.prototype.timeOfDay">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>timeOfDay
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeOfDay = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'timeOfDay', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TIME_OF_DAY)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.timezone" id="apidoc.element.rethinkdbdash.term.prototype.timezone">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>timezone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timezone = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'timezone', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TIMEZONE)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toEpochTime" id="apidoc.element.rethinkdbdash.term.prototype.toEpochTime">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toEpochTime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toEpochTime = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'toEpochTime', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TO_EPOCH_TIME)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toGeojson" id="apidoc.element.rethinkdbdash.term.prototype.toGeojson">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toGeojson
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toGeojson = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'toGeojson', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.TO_GEOJSON);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toISO8601" id="apidoc.element.rethinkdbdash.term.prototype.toISO8601">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toISO8601
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toISO8601 = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'toISO8601', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TO_ISO8601)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toJSON" id="apidoc.element.rethinkdbdash.term.prototype.toJSON">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'toJSON', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.TO_JSON_STRING);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toJsonString" id="apidoc.element.rethinkdbdash.term.prototype.toJsonString">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toJsonString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJsonString = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'toJSON', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.TO_JSON_STRING);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toStream" id="apidoc.element.rethinkdbdash.term.prototype.toStream">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toStream
        <span class="apidocSignatureSpan">(connection, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toStream = function (connection, options) {
  if (helper.isPlainObject(connection) &amp;&amp; (typeof connection._isConnection === 'function') &amp;&amp; (connection._isConnection() === true
)) {
    if (helper.isPlainObject(options) === false) {
      options = {};
    }
    if (options.readable === true) {
      return this._toReadableStream(connection, options);
    }
    else if (options.writable === true) {
      return this._toWritableStream(connection, options);
    }
    else if (options.transform === true) {
      return this._toTransformStream(connection, options);
    }
    else {
      return this._toReadableStream(connection, options);
    }
  }
  else {
    options = connection;
    if (helper.isPlainObject(options) === false) {
      options = {};
    }
    if (options.readable === true) {
      return this._toReadableStream(options);
    }
    else if (options.writable === true) {
      return this._toWritableStream(options);
    }
    else if (options.transform === true) {
      return this._toTransformStream(options);
    }
    else {
      return this._toReadableStream(options);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
synchronously returned with the `toStream([connection])` method.

```js
var fs = require('fs');
var file = fs.createWriteStream('file.txt');

var r = require('rethinkdbdash')();
r.table('users').<span class="apidocCodeKeywordSpan">toStream</span>()
  .on('error', console.log)
  .pipe(file)
  .on('error', console.log)
  .on('end', function() {
    r.getPool().drain();
  });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toString" id="apidoc.element.rethinkdbdash.term.prototype.toString">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return Error.generateBacktrace(this._query, 0, null, [], {indent: 0, extra: 0}).str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.connection.on('error', function(error) {
  self.emit('error', error);
});

var versionBuffer = new Buffer(4)
versionBuffer.writeUInt32LE(protodef.VersionDummy.Version.V1_0, 0)

self.randomString = new Buffer(crypto.randomBytes(18)).<span class="apidocCodeKeywordSpan">toString</span>('base64')
var authBuffer = new Buffer(JSON.stringify({
  protocol_version: PROTOCOL_VERSION,
  authentication_method: AUTHENTIFICATION_METHOD,
  authentication: "n,,n=" + self.user + ",r=" + self.randomString
}));

helper.tryCatch(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.tuesday" id="apidoc.element.rethinkdbdash.term.prototype.tuesday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tuesday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tuesday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.TUESDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.typeOf" id="apidoc.element.rethinkdbdash.term.prototype.typeOf">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>typeOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeOf = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'typeOf', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TYPE_OF);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.ungroup" id="apidoc.element.rethinkdbdash.term.prototype.ungroup">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ungroup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ungroup = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'ungroup', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.UNGROUP)
  var args = [this._query];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.union" id="apidoc.element.rethinkdbdash.term.prototype.union">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>union
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">union = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.UNION)
  var args = [];
  if (!Array.isArray(this._query) || (this._query.length &gt; 0)) {
    args.push(this);
  }
  for(var i=0; i&lt;_args.length-1; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  if ((_args.length &gt; 1) &amp;&amp; (helper.isPlainObject(_args[_args.length-1])) &amp;&amp; (_args[_args.length-1].interleave !== undefined)) {
    term._fillArgs(args);
    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);
  }
  else if (_args.length &gt; 0) {
    args.push(new Term(this._r).expr(_args[_args.length-1]))
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.resetBufferParameters();
}

//  Create the feed on server_status and bind the listener to the feed
PoolMaster.prototype.fetchServers = function(useSeeds) {
var self = this;
var query = self._r.db('rethinkdb').table('server_status')
    .<span class="apidocCodeKeywordSpan">union</span>([SEPARATOR])
    .union(self._r.db('rethinkdb').table('server_status').changes())
// In case useSeeds is true, we rotate through all the seeds + the pool master
if (!useSeeds || self._seed === self._servers.length) {
  if (useSeeds &amp;&amp; self._seed === self._servers.length) {
    // We increase the back off only when we went through all the seeds
    self._consecutiveFails++;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.upcase" id="apidoc.element.rethinkdbdash.term.prototype.upcase">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>upcase
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">upcase = function (regex) {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'upcase', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.UPCASE)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.update" id="apidoc.element.rethinkdbdash.term.prototype.update">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>update
        <span class="apidocSignatureSpan">(newValue, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (newValue, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'update', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.UPDATE);
  var args = [self, new Term(self._r).expr(newValue)._wrap()];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'returnChanges') &amp;&amp; (key !== 'durability') &amp;&amp; (key !== 'nonAtomic')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `update`', self._query, 'Available options are returnChanges
 &lt;bool&gt;, durability &lt;string&gt;, nonAtomic &lt;bool&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var bluebird = require('bluebird');
var r = require('rethinkdbdash')();

bluebird.coroutine(function*() {
  try {
    var result = yield r.table('users').get('orphee@gmail.com').<span class="apidocCodeKeywordSpan">update<!--
span-->({name: 'Michel'});
    assert.equal(result.errors, 0);
  } catch(err) {
    console.log(err);
  }
});
```
...</span></pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.uuid" id="apidoc.element.rethinkdbdash.term.prototype.uuid">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>uuid
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uuid = function (str) {
  this._noPrefix(this, 'uuid');

  var term = new Term(this._r);
  term._query.push(termTypes.UUID)

  if (str !== undefined) {
    var args = [new Term(this._r).expr(str)];
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var r = require(__dirname+'/../lib')(config);
var util = require(__dirname+'/../test/util/common.js');
var assert = require('assert');




var dbName = util.<span class="apidocCodeKeywordSpan">uuid</span>()
var tableName = util.uuid()

var query; // without `.run()`
//query = 'r.table("foo").add(1).add(1).add("hello-super-long-string").add("another-long-string"
;).add("one-last-string").map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test
) { return test("b").add("hello-super-long-string").add("another-long-string").add("one-last-
string").add("hello-super-long-string").add("another-long-string").add("one-last-string").add
("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello-super
-long-string").add("another-long-string").add("one-last-string").add("hello-super-long-string"
;).add("another-long-string").add("one-last-string").mul(test("b")).merge({ firstName: "xxxxxx
", lastName: "yyyy", email: "xxxxx@yyyy.com", phone: "xxx-xxx-xxxx" }); }).add(2).map(function
(doc) { return doc.add("hello-super-long-string").add("another-long-string").add("one-last-string").
add("hello-super-long-string").add("another-long-string").add("one-last-string").add("hello-super
-long-string").add("another-long-string").add("one-last-string").add("hello-super-long-string"
;).add("another-long-string").add("one-last-string").add("hello-super-long-string").add("another
-long-string").add("one-last-string") }); })';
query = 'r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })';
Promise.coroutine(function* () {
try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.values" id="apidoc.element.rethinkdbdash.term.prototype.values">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'keys', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.VALUES)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.wait" id="apidoc.element.rethinkdbdash.term.prototype.wait">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>wait
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wait = function (options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 0, 1, 'wait', self);
  }
  var term = new Term(self._r);
  term._query.push(termTypes.WAIT);
  var args = [self];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'waitFor') &amp;&amp; (key !== 'timeout')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `wait`', self._query, 'Available options are waitFor: &lt;
string&gt;, timeout: &lt;number&gt;');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.wednesday" id="apidoc.element.rethinkdbdash.term.prototype.wednesday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>wednesday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wednesday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.WEDNESDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.withFields" id="apidoc.element.rethinkdbdash.term.prototype.withFields">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>withFields
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withFields = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'withFields', this);

  var term = new Term(this._r);
  term._query.push(termTypes.WITH_FIELDS);
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.without" id="apidoc.element.rethinkdbdash.term.prototype.without">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>without
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">without = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'without', this);

  var term = new Term(this._r);
  term._query.push(termTypes.WITHOUT)
  var args = [this];
  for(var i=0; i&lt;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.year" id="apidoc.element.rethinkdbdash.term.prototype.year">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>year
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">year = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'year', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.YEAR)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.zip" id="apidoc.element.rethinkdbdash.term.prototype.zip">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>zip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zip = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &lt; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'zip', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.ZIP);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.transform_stream" id="apidoc.module.rethinkdbdash.transform_stream">module rethinkdbdash.transform_stream</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream.transform_stream" id="apidoc.element.rethinkdbdash.transform_stream.transform_stream">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>transform_stream
        <span class="apidocSignatureSpan">(table, options, connection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TransformStream(table, options, connection) {
  this._table = table;
  this._r = table._r;
  this._options = options;
  this._cache = [];
  this._pendingCallback = null;
  this._ended = false;
  this._inserting = false;
  this._delayed = false;
  this._connection = connection;
  this._highWaterMark = options.highWaterMark || 100;
  this._insertOptions = {};
  this._insertOptions.durability = options.durability || 'hard';
  this._insertOptions.conflict = options.conflict || 'error';
  this._insertOptions.returnChanges = options.returnChanges || true;

  // Internal option to run some tests
  if (options.debug === true) {
    this._sequence = [];
  }

  Transform.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream.super_" id="apidoc.element.rethinkdbdash.transform_stream.super_">
        function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function')
      this._transform = options.transform;

    if (typeof options.flush === 'function')
      this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function() {
    if (typeof this._flush === 'function')
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.transform_stream.prototype" id="apidoc.module.rethinkdbdash.transform_stream.prototype">module rethinkdbdash.transform_stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream.prototype._flush" id="apidoc.element.rethinkdbdash.transform_stream.prototype._flush">
        function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_flush
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (done) {
  this._ended = true;
  if ((this._cache.length === 0) &amp;&amp; (this._inserting === false)) {
    done();
  }
  else { // this._inserting === true
    if (this._inserting === false) {
      this._flushCallback = done;
      this._insert();
    }
    else {
      this._flushCallback = done;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+' in less than '+
self.timeoutConnect+'s').setOperational());
}, self.timeoutConnect*1000);

self.connection.on('end', function() {
  self.open = false;
  self.emit('end');
  // We got a FIN packet, so we'll just flush
  self.<span class="apidocCodeKeywordSpan">_flush</span>();
});
self.connection.on('close', function() {
  // We emit end or close just once
  clearTimeout(self.timeoutOpen)
  clearInterval(self.pingIntervalId);
  self.connection.removeAllListeners();
  self.open = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream.prototype._insert" id="apidoc.element.rethinkdbdash.transform_stream.prototype._insert">
        function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_insert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_insert = function () {
  var self = this;
  self._inserting = true;

  var cache = self._cache;
  self._cache = [];

  if (Array.isArray(self._sequence)) {
    self._sequence.push(cache.length);
  }

  var pendingCallback = self._pendingCallback;
  self._pendingCallback = null;
  if (typeof pendingCallback === 'function') {
    pendingCallback();
  }

  var query = self._table.insert(cache, self._insertOptions);
  if (self._options.format === 'primaryKey') {
    query = query.do(function(result) {
      return self._r.branch(
        result('errors').eq(0),
        self._table.config()('primary_key').do(function(primaryKey) {
          return result('changes')('new_val')(primaryKey)
        }),
        result(self._r.error(result('errors').coerceTo('STRING').add(' errors returned. First error:\n').add(result('first_error
'))))
      )
    })
  }

  query.run(self._connection).then(function(result) {
    self._inserting = false;
    if (self._options.format === 'primaryKey') {
      for(var i=0; i&lt;result.length; i++) {
        self.push(result[i]);
      }
    }
    else {
      if (result.errors &gt; 0) {
        self._inserting = false;
        self.emit('error', new Error('Failed to insert some documents:'+JSON.stringify(result, null, 2)));
      }
      else {
        if (self._insertOptions.returnChanges === true) {
          for(var i=0; i&lt;result.changes.length; i++) {
            self.push(result.changes[i].new_val);
          }
        }
      }
    }

    pendingCallback = self._pendingCallback
    self._pendingCallback = null;
    if (typeof pendingCallback === 'function') {
      // Mean that we can buffer more
      pendingCallback();
    }
    else if (self._ended !== true) {
      if (((((self._writableState.lastBufferedRequest === null) ||
          self._writableState.lastBufferedRequest.chunk === self._cache[self._cache.length-1])))
        &amp;&amp; (self._cache.length &gt; 0)) {
          self._insert();
      }
    }
    else if (self._ended === true) {
      if (self._cache.length &gt; 0) {
        self._insert();
      }
      else {
        if (typeof self._flushCallback === 'function') {
          self._flushCallback();
        }
        self.push(null);
      }
    }
  }).error(function(error) {
    self._inserting = false;
    self.emit('error', error);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  done();
}
else {
  if (this._inserting === false) {
    if (this._delayed === true) {
      // We have to flush
      this._delayed = false;
      this.<span class="apidocCodeKeywordSpan">_insert</span>();
      // Fill the buffer while we are inserting data
      done();
    }
    else {
      var self = this;
      this._delayed = true;
      setImmediate(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream.prototype._next" id="apidoc.element.rethinkdbdash.transform_stream.prototype._next">
        function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_next
        <span class="apidocSignatureSpan">(value, encoding, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_next = function (value, encoding, done) {
  if ((this._writableState.lastBufferedRequest != null) &amp;&amp; (this._writableState.lastBufferedRequest.chunk !== value)) {
    // There's more data to buffer
    if (this._cache.length &lt; this._highWaterMark) {
      this._delayed = false;
      // Call done now, and more data will be put in the cache
      done();
    }
    else {
      if (this._inserting === false) {
        if (this._delayed === true) {
          // We have to flush
          this._delayed = false;
          this._insert();
          // Fill the buffer while we are inserting data
          done();
        }
        else {
          var self = this;
          this._delayed = true;
          setImmediate(function() {
            self._next(value, encoding, done);
          })
        }

      }
      else {
        // to call when we are dong inserting to keep buffering
        this._pendingCallback = done;
      }
    }
  }
  else { // We just pushed the last element in the internal buffer
    if (this._inserting === false) {
      if (this._delayed === true) {
        this._delayed = false;
        // to call when we are dong inserting to maybe flag the end
        this._insert();
        // We can call done now, because we have _flush to close the stream
        done();
      }
      else {
        var self = this;
        this._delayed = true;
        setImmediate(function() {
          self._next(value, encoding, done);
        })
      }
    }
    else {
      this._delayed = false;
      // There is nothing left in the internal buffer
      // But something is already inserting stuff.
      if (this._cache.length &lt; this._highWaterMark-1) {
        // Call done, to attempt to buffer more
        // This may trigger _flush
        //this._pendingCallback = done;
        done();
      }
      else {
        this._pendingCallback = done;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (typeof onFinish === 'function') {
    onFinish();
  }
}
else {
  if (self._closed === false) {
    if (self._stackSize &lt;= MAX_CALL_STACK) {
      self.<span class="apidocCodeKeywordSpan">_next</span>().then(resolve).error(function(error) {
        if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &amp;&amp;
            (error.message.match(/You cannot call `next` on a closed/) === null)) {
          reject(error);
        }
      });
    }
    else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream.prototype._transform" id="apidoc.element.rethinkdbdash.transform_stream.prototype._transform">
        function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_transform
        <span class="apidocSignatureSpan">(value, encoding, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (value, encoding, done) {
  this._cache.push(value);
  this._next(value, encoding, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.writable_stream" id="apidoc.module.rethinkdbdash.writable_stream">module rethinkdbdash.writable_stream</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.writable_stream.writable_stream" id="apidoc.element.rethinkdbdash.writable_stream.writable_stream">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>writable_stream
        <span class="apidocSignatureSpan">(table, options, connection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WritableStream(table, options, connection) {
  this._table = table;
  this._options = options;
  this._cache = [];
  this._pendingCallback = null;
  this._inserting = false;
  this._delayed = false;
  this._connection = connection;
  this._highWaterMark = options.highWaterMark || 100;

  this._insertOptions = {};
  this._insertOptions.durability = options.durability || 'hard';
  this._insertOptions.conflict = options.conflict || 'error';

  // Internal option to run some tests
  if (options.debug === true) {
    this._sequence = [];
  }

  Writable.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
  this._i = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.writable_stream.super_" id="apidoc.element.rethinkdbdash.writable_stream.super_">
        function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!(realHasInstance.call(Writable, this)) &amp;&amp;
      !(this instanceof Stream.Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;

    if (typeof options.writev === 'function')
      this._writev = options.writev;
  }

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.writable_stream.prototype" id="apidoc.module.rethinkdbdash.writable_stream.prototype">module rethinkdbdash.writable_stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.writable_stream.prototype._insert" id="apidoc.element.rethinkdbdash.writable_stream.prototype._insert">
        function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.prototype.</span>_insert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_insert = function () {
  var self = this;
  self._inserting = true;

  var cache = self._cache;
  self._cache = [];

  if (Array.isArray(self._sequence)) {
    self._sequence.push(cache.length);
  }

  self._table.insert(cache, self._insertOptions).run(self._connection).then(function(result) {
    self._inserting = false;
    if (result.errors &gt; 0) {
      self._inserting = false;
      self.emit('error', new Error('Failed to insert some documents:'+JSON.stringify(result, null, 2)));
    }
    if (typeof self._pendingCallback === 'function') {
      var pendingCallback = self._pendingCallback;
      self._pendingCallback = null;
      pendingCallback();
    }
    return null;
  }).error(function(error) {
    self._inserting = false;
    self.emit('error', error);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  done();
}
else {
  if (this._inserting === false) {
    if (this._delayed === true) {
      // We have to flush
      this._delayed = false;
      this.<span class="apidocCodeKeywordSpan">_insert</span>();
      // Fill the buffer while we are inserting data
      done();
    }
    else {
      var self = this;
      this._delayed = true;
      setImmediate(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.writable_stream.prototype._next" id="apidoc.element.rethinkdbdash.writable_stream.prototype._next">
        function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.prototype.</span>_next
        <span class="apidocSignatureSpan">(value, encoding, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_next = function (value, encoding, done) {
  var self = this;
  if ((this._writableState.lastBufferedRequest != null) &amp;&amp; (this._writableState.lastBufferedRequest.chunk !== value)) {
    // There's more data to buffer
    if (this._cache.length &lt; this._highWaterMark) {
      this._delayed = false;
      // Call done now, and more data will be put in the cache
      done();
    }
    else {
      if (this._inserting === false) {
        if (this._delayed === true) {
          this._delayed = false;
          // We have to flush
          this._insert();
          // Fill the buffer while we are inserting data
          done();
        }
        else {
          var self = this;
          this._delayed = true;
          setImmediate(function() {
            self._next(value, encoding, done);
          })
        }

      }
      else {
        this._delayed = false;
        // to call when we are dong inserting to keep buffering
        this._pendingCallback = done;
      }
    }
  }
  else { // We just pushed the last element in the internal buffer
    if (this._inserting === false) {
      if (this._delayed === true) {
        this._delayed = false;
        // to call when we are dong inserting to maybe flag the end
        // We cannot call done here as we may be inserting the last batch
        this._pendingCallback = done;
        this._insert();
      }
      else {
        var self = this;
        this._delayed = true;
        setImmediate(function() {
          self._next(value, encoding, done);
        })
      }
    }
    else {
      this._delayed = false;
      // We cannot call done here as we may be inserting the last batch
      //this._pendingCallback = done;
      this._pendingCallback = function() {
        self._next(value, encoding, done);
      };
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (typeof onFinish === 'function') {
    onFinish();
  }
}
else {
  if (self._closed === false) {
    if (self._stackSize &lt;= MAX_CALL_STACK) {
      self.<span class="apidocCodeKeywordSpan">_next</span>().then(resolve).error(function(error) {
        if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &amp;&amp;
            (error.message.match(/You cannot call `next` on a closed/) === null)) {
          reject(error);
        }
      });
    }
    else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.writable_stream.prototype._write" id="apidoc.element.rethinkdbdash.writable_stream.prototype._write">
        function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.prototype.</span>_write
        <span class="apidocSignatureSpan">(value, encoding, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (value, encoding, done) {
  this._i++;
  this._cache.push(value);
  this._next(value, encoding, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>