<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/neumino/rethinkdbdash#readme"

    >rethinkdbdash (v2.3.28)</a>
</h1>
<h4>A Node.js driver for RethinkDB with promises and a connection pool</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash">module rethinkdbdash</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>connection
            <span class="apidocSignatureSpan">(r, options, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>cursor
            <span class="apidocSignatureSpan">(connection, token, options, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>dequeue
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>metadata
            <span class="apidocSignatureSpan">(resolve, reject, query, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool
            <span class="apidocSignatureSpan">(r, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool_master
            <span class="apidocSignatureSpan">(r, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>stream
            <span class="apidocSignatureSpan">(options, cursor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>term
            <span class="apidocSignatureSpan">(r, value, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>transform_stream
            <span class="apidocSignatureSpan">(table, options, connection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.writable_stream">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>writable_stream
            <span class="apidocSignatureSpan">(table, options, connection)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>connection.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>cursor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>dequeue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>error</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>helper</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>metadata.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>pool.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>pool_master.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>stream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>term.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>transform_stream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.</span>writable_stream.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.connection">module rethinkdbdash.connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.connection">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>connection
            <span class="apidocSignatureSpan">(r, options, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.super_">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.connection.prototype">module rethinkdbdash.connection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._abort">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._checkProtocolVersion">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_checkProtocolVersion
            <span class="apidocSignatureSpan">(messageServer, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._compareDigest">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_compareDigest
            <span class="apidocSignatureSpan">(messageServer, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._computeSaltedPassword">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_computeSaltedPassword
            <span class="apidocSignatureSpan">(messageServer, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._continue">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_continue
            <span class="apidocSignatureSpan">(token, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._end">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_end
            <span class="apidocSignatureSpan">(token, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._flush">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._getToken">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_getToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._isConnection">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_isConnection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._isOpen">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_isOpen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._processResponse">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_processResponse
            <span class="apidocSignatureSpan">(response, token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._send">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_send
            <span class="apidocSignatureSpan">(query, token, resolve, reject, originalQuery, options, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype._sendProof">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_sendProof
            <span class="apidocSignatureSpan">(authentication, randomNonce, saltedPassword)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype.close">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>close
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype.noReplyWait">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>noReplyWait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype.noreplyWait">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>noreplyWait
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype.reconnect">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>reconnect
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype.server">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>server
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.connection.prototype.use">
            function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>use
            <span class="apidocSignatureSpan">(db)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.cursor">module rethinkdbdash.cursor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.cursor">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>cursor
            <span class="apidocSignatureSpan">(connection, token, options, type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.cursor.prototype">module rethinkdbdash.cursor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._done">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_done
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._each">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_each
            <span class="apidocSignatureSpan">(callback, onFinish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._eachAsync">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_eachAsync
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._eachAsyncInternal">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_eachAsyncInternal
            <span class="apidocSignatureSpan">(callback, finalResolve, finalReject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._eachCb">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_eachCb
            <span class="apidocSignatureSpan">(err, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._fetch">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._flush">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._makeEmitter">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_makeEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._next">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_next
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._push">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_push
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._pushError">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_pushError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._set">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_set
            <span class="apidocSignatureSpan">(ar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype._unsupportedToArray">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_unsupportedToArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.addListener">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.close">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.each">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>each
            <span class="apidocSignatureSpan">(callback, onFinish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.eachAsync">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>eachAsync
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.emit">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.getType">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>getType
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.hasNext">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>hasNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.includesStates">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>includesStates
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.listeners">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.next">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>next
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.on">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.once">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.removeListener">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.setIncludesStates">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>setIncludesStates
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.toArray">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>toArray
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.toJSON">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.cursor.prototype.toString">
            function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.dequeue">module rethinkdbdash.dequeue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.dequeue">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>dequeue
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.dequeue.prototype">module rethinkdbdash.dequeue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.delete">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>delete
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.get">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>get
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.getLength">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>getLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.pop">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>pop
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.push">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>push
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.shift">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>shift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.toArray">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>toArray
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.dequeue.prototype.unshift">
            function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>unshift
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.error">module rethinkdbdash.error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.ReqlClientError">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlClientError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.ReqlCompileError">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlCompileError
            <span class="apidocSignatureSpan">(message, query, frames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.ReqlDriverError">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlDriverError
            <span class="apidocSignatureSpan">(message, query, secondMessage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.ReqlRuntimeError">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlRuntimeError
            <span class="apidocSignatureSpan">(message, query, frames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.ReqlServerError">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlServerError
            <span class="apidocSignatureSpan">(message, query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.generateBacktrace">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>generateBacktrace
            <span class="apidocSignatureSpan">(term, index, father, frames, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.error.setOperational">
            function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>setOperational
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.helper">module rethinkdbdash.helper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.changeProto">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>changeProto
            <span class="apidocSignatureSpan">(object, other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.compareDigest">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>compareDigest
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.createLogger">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>createLogger
            <span class="apidocSignatureSpan">(poolMaster, silent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.getCanonicalAddress">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>getCanonicalAddress
            <span class="apidocSignatureSpan">(addresses)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.hasImplicit">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>hasImplicit
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.isPlainObject">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>isPlainObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.loopKeys">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>loopKeys
            <span class="apidocSignatureSpan">(obj, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.makeAtom">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>makeAtom
            <span class="apidocSignatureSpan">(response, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.makeSequence">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>makeSequence
            <span class="apidocSignatureSpan">(response, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.splitCommaEqual">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>splitCommaEqual
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.toArray">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>toArray
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.tryCatch">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>tryCatch
            <span class="apidocSignatureSpan">(toTry, handleError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.helper.xorBuffer">
            function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>xorBuffer
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>localhostAliases</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.metadata">module rethinkdbdash.metadata</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata.metadata">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>metadata
            <span class="apidocSignatureSpan">(resolve, reject, query, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.metadata.prototype">module rethinkdbdash.metadata.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata.prototype.removeCallbacks">
            function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>removeCallbacks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata.prototype.removeEndCallbacks">
            function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>removeEndCallbacks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata.prototype.setCallbacks">
            function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>setCallbacks
            <span class="apidocSignatureSpan">(resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata.prototype.setCursor">
            function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>setCursor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.metadata.prototype.setEnd">
            function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>setEnd
            <span class="apidocSignatureSpan">(resolve, reject)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.pool">module rethinkdbdash.pool</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.pool">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool
            <span class="apidocSignatureSpan">(r, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.super_">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.pool.prototype">module rethinkdbdash.pool.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype._aggressivelyExpandBuffer">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_aggressivelyExpandBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype._decreaseNumConnections">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_decreaseNumConnections
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype._expandBuffer">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_expandBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype._increaseNumConnections">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_increaseNumConnections
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.createConnection">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>createConnection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.drain">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>drain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.drainLocalhost">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>drainLocalhost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.getAddress">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getAddress
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.getAvailableLength">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getAvailableLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.getConnection">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getConnection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.getLength">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.putConnection">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>putConnection
            <span class="apidocSignatureSpan">(connection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool.prototype.setOptions">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>setOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.pool_master">module rethinkdbdash.pool_master</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.pool_master">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool_master
            <span class="apidocSignatureSpan">(r, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.super_">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.pool_master.prototype">module rethinkdbdash.pool_master.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype._expandAll">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>_expandAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype._flushErrors">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>_flushErrors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.createPool">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>createPool
            <span class="apidocSignatureSpan">(server)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.createPoolSettings">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>createPoolSettings
            <span class="apidocSignatureSpan">(globalOptions, serverOptions, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.deletePool">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>deletePool
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.drain">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>drain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.emitStatus">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>emitStatus
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.fetchServers">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>fetchServers
            <span class="apidocSignatureSpan">(useSeeds)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.getAvailableLength">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getAvailableLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.getConnection">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getConnection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.getLength">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.getNumAvailableConnections">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getNumAvailableConnections
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.getNumConnections">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getNumConnections
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.getPools">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getPools
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.handleAllServersResponse">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>handleAllServersResponse
            <span class="apidocSignatureSpan">(servers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.initPool">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>initPool
            <span class="apidocSignatureSpan">(pool)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.pool_master.prototype.resetBufferParameters">
            function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>resetBufferParameters
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.stream">module rethinkdbdash.stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.stream">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>stream
            <span class="apidocSignatureSpan">(options, cursor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.super_">
            function <span class="apidocSignatureSpan">rethinkdbdash.stream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.stream.prototype">module rethinkdbdash.stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.prototype._fetch">
            function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.prototype._fetchAndDecrement">
            function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_fetchAndDecrement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.prototype._read">
            function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_read
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.prototype._setCursor">
            function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_setCursor
            <span class="apidocSignatureSpan">(cursor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.stream.prototype.close">
            function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.term">module rethinkdbdash.term</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.term">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>term
            <span class="apidocSignatureSpan">(r, value, error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.term.prototype">module rethinkdbdash.term.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.ISO8601">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ISO8601
            <span class="apidocSignatureSpan">(isoTime, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._arity">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_arity
            <span class="apidocSignatureSpan">(args, num, method, term)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._arityRange">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_arityRange
            <span class="apidocSignatureSpan">(args, min, max, method, term)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._fastArity">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_fastArity
            <span class="apidocSignatureSpan">(len, num)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._fastArityRange">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_fastArityRange
            <span class="apidocSignatureSpan">(len, min, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._fillArgs">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_fillArgs
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._noPrefix">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_noPrefix
            <span class="apidocSignatureSpan">(term, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._setArrayLimit">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_setArrayLimit
            <span class="apidocSignatureSpan">(arrayLimit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._setNestingLevel">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_setNestingLevel
            <span class="apidocSignatureSpan">(nestingLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._toReadableStream">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_toReadableStream
            <span class="apidocSignatureSpan">(connection, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._toTransformStream">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_toTransformStream
            <span class="apidocSignatureSpan">(connection, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._toWritableStream">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_toWritableStream
            <span class="apidocSignatureSpan">(connection, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype._wrap">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_wrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.add">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>add
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.and">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>and
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.append">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>append
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.april">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>april
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.args">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>args
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.asc">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>asc
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.august">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>august
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.avg">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>avg
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.between">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>between
            <span class="apidocSignatureSpan">(start, end, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.binary">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>binary
            <span class="apidocSignatureSpan">(bin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.bracket">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>bracket
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.branch">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>branch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.catch">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>catch
            <span class="apidocSignatureSpan">(reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.ceil">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ceil
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.changeAt">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>changeAt
            <span class="apidocSignatureSpan">(index, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.changes">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>changes
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.circle">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>circle
            <span class="apidocSignatureSpan">(center, radius, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.coerceTo">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>coerceTo
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.concatMap">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>concatMap
            <span class="apidocSignatureSpan">(transformation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.config">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>config
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.contains">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>contains
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.count">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>count
            <span class="apidocSignatureSpan">(filter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.date">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>date
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.day">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>day
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.dayOfWeek">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dayOfWeek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.dayOfYear">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dayOfYear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.db">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>db
            <span class="apidocSignatureSpan">(db)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.dbCreate">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dbCreate
            <span class="apidocSignatureSpan">(db)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.dbDrop">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dbDrop
            <span class="apidocSignatureSpan">(db)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.dbList">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dbList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.december">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>december
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.default">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>default
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.delay">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>delay
            <span class="apidocSignatureSpan">(msecs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.delete">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>delete
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.deleteAt">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>deleteAt
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.desc">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>desc
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.difference">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>difference
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.distance">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>distance
            <span class="apidocSignatureSpan">(geometry, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.distinct">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>distinct
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.div">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>div
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.do">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>do
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.downcase">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>downcase
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.during">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>during
            <span class="apidocSignatureSpan">(left, right, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.epochTime">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>epochTime
            <span class="apidocSignatureSpan">(epochTime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.eq">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>eq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.eqJoin">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>eqJoin
            <span class="apidocSignatureSpan">(rightKey, sequence, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.error">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>error
            <span class="apidocSignatureSpan">(reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.expr">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>expr
            <span class="apidocSignatureSpan">(expression, nestingLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.february">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>february
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.fill">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>fill
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.filter">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>filter
            <span class="apidocSignatureSpan">(filter, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.finally">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>finally
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.floor">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>floor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.fold">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>fold
            <span class="apidocSignatureSpan">(base, func, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.forEach">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>forEach
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.friday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>friday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.ge">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ge
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.geojson">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>geojson
            <span class="apidocSignatureSpan">(geometry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.get">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>get
            <span class="apidocSignatureSpan">(primaryKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.getAll">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.getField">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getField
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.getIntersecting">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getIntersecting
            <span class="apidocSignatureSpan">(geometry, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.getNearest">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getNearest
            <span class="apidocSignatureSpan">(geometry, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.grant">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>grant
            <span class="apidocSignatureSpan">(name, access)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.group">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>group
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.gt">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>gt
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.hasFields">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>hasFields
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.hours">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>hours
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.http">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>http
            <span class="apidocSignatureSpan">(url, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.inTimezone">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>inTimezone
            <span class="apidocSignatureSpan">(timezone)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.includes">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>includes
            <span class="apidocSignatureSpan">(geometry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexCreate">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexCreate
            <span class="apidocSignatureSpan">(name, fn, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexDrop">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexDrop
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexList">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexRename">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexRename
            <span class="apidocSignatureSpan">(oldName, newName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexStatus">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexStatus
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexWait">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexWait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.indexesOf">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexesOf
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.info">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>info
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.innerJoin">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>innerJoin
            <span class="apidocSignatureSpan">(sequence, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.insert">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>insert
            <span class="apidocSignatureSpan">(documents, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.insertAt">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>insertAt
            <span class="apidocSignatureSpan">(index, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.intersects">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>intersects
            <span class="apidocSignatureSpan">(geometry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.isEmpty">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.january">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>january
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.js">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>js
            <span class="apidocSignatureSpan">(arg, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.json">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>json
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.july">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>july
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.june">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>june
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.keys">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.le">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>le
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.limit">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>limit
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.line">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.literal">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>literal
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.lt">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>lt
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.map">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>map
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.march">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>march
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.match">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>match
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.max">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>max
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.maxval">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>maxval
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.may">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>may
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.merge">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>merge
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.min">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>min
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.minutes">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>minutes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.minval">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>minval
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.mod">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>mod
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.monday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>monday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.month">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>month
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.mul">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>mul
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.ne">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ne
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.not">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.november">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>november
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.now">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>now
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.nth">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>nth
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.object">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>object
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.october">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>october
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.offsetsOf">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>offsetsOf
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.or">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>or
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.orderBy">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>orderBy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.outerJoin">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>outerJoin
            <span class="apidocSignatureSpan">(sequence, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.pluck">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>pluck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.point">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>point
            <span class="apidocSignatureSpan">(longitude, latitude)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.polygon">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>polygon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.polygonSub">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>polygonSub
            <span class="apidocSignatureSpan">(geometry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.prepend">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>prepend
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.random">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>random
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.range">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>range
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.rebalance">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>rebalance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.reconfigure">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>reconfigure
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.reduce">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>reduce
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.replace">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>replace
            <span class="apidocSignatureSpan">(newValue, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.round">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>round
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.row">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>row
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.run">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>run
            <span class="apidocSignatureSpan">(connection, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.sample">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sample
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.saturday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>saturday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.seconds">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>seconds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.september">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>september
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.setDifference">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setDifference
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.setInsert">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setInsert
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.setIntersection">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setIntersection
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.setUnion">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setUnion
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.skip">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>skip
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.slice">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>slice
            <span class="apidocSignatureSpan">(start, end, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.spliceAt">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>spliceAt
            <span class="apidocSignatureSpan">(index, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.split">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>split
            <span class="apidocSignatureSpan">(separator, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.status">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>status
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.sub">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.sum">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sum
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.sunday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sunday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.sync">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.table">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>table
            <span class="apidocSignatureSpan">(table, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.tableCreate">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tableCreate
            <span class="apidocSignatureSpan">(table, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.tableDrop">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tableDrop
            <span class="apidocSignatureSpan">(table)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.tableList">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tableList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.then">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>then
            <span class="apidocSignatureSpan">(resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.thursday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>thursday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.time">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>time
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.timeOfDay">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>timeOfDay
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.timezone">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>timezone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toEpochTime">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toEpochTime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toGeojson">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toGeojson
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toISO8601">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toISO8601
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toJSON">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toJsonString">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toJsonString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toStream">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toStream
            <span class="apidocSignatureSpan">(connection, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.toString">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.tuesday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tuesday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.typeOf">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>typeOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.ungroup">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ungroup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.union">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>union
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.upcase">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>upcase
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.update">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>update
            <span class="apidocSignatureSpan">(newValue, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.uuid">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>uuid
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.values">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.wait">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>wait
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.wednesday">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>wednesday
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.withFields">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>withFields
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.without">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>without
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.year">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>year
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.term.prototype.zip">
            function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>zip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_translateArgs</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.transform_stream">module rethinkdbdash.transform_stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream.transform_stream">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>transform_stream
            <span class="apidocSignatureSpan">(table, options, connection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream.super_">
            function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.transform_stream.prototype">module rethinkdbdash.transform_stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream.prototype._flush">
            function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_flush
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream.prototype._insert">
            function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_insert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream.prototype._next">
            function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_next
            <span class="apidocSignatureSpan">(value, encoding, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.transform_stream.prototype._transform">
            function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_transform
            <span class="apidocSignatureSpan">(value, encoding, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.writable_stream">module rethinkdbdash.writable_stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.writable_stream.writable_stream">
            function <span class="apidocSignatureSpan">rethinkdbdash.</span>writable_stream
            <span class="apidocSignatureSpan">(table, options, connection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.writable_stream.super_">
            function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rethinkdbdash.writable_stream.prototype">module rethinkdbdash.writable_stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.writable_stream.prototype._insert">
            function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.prototype.</span>_insert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.writable_stream.prototype._next">
            function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.prototype.</span>_next
            <span class="apidocSignatureSpan">(value, encoding, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rethinkdbdash.writable_stream.prototype._write">
            function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.prototype.</span>_write
            <span class="apidocSignatureSpan">(value, encoding, done)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash" id="apidoc.module.rethinkdbdash">module rethinkdbdash</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection" id="apidoc.element.rethinkdbdash.connection">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>connection
        <span class="apidocSignatureSpan">(r, options, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connection(r, options, resolve, reject) {
  var self = this;
  this.r = r;
  this.state = 0; // Track the progress of the handshake. -1 will be used for an error state.

  // Set default options - We have to save them in case the user tries to reconnect
  if (!helper.isPlainObject(options)) options = {};
  this.host = options.host || r._host;
  this.port = options.port || r._port;
  if (options.authKey != null) {
    if (options.user != null || options.password != null) {
      throw new Err.ReqlDriverError(&#x27;Cannot use both authKey and password&#x27;);
    }
    this.user = r._user;
    this.password = options.authKey;
  } else {
    if (options.user === undefined) {
      this.user = r._user;
    } else {
      this.user = options.user;
    }
    if (options.password === undefined) {
      this.password = r._password;
    } else {
      this.password = options.password;
    }
  }

  this.authKey = options.authKey || r._authKey;
  // period in *seconds* for the connection to be opened
  this.timeoutConnect = options.timeout || r._timeoutConnect;
  // The connection will be pinged every &#x3c;pingInterval&#x3e; seconds
  this.pingInterval = options.pingInterval || r._pingInterval;

  if (options.db) this.db = options.db; // Pass to each query

  this.token = 1;
  this.buffer = new Buffer(0);

  this.metadata = {}

  this.open = false; // true only if the user can write on the socket
  this.timeout = null;

  if (options.connection) {
    this.connection = options.connection;
  }
  else {
    var family = &#x27;IPv4&#x27;;
    if (net.isIPv6(self.host)) {
      family = &#x27;IPv6&#x27;;
    }

    var connectionArgs = {
      host: self.host,
      port: self.port,
      family: family
    }

    var tlsOptions = options.ssl || false;
    if (tlsOptions === false) {
      self.connection = net.connect(connectionArgs);
    } else {
      if (helper.isPlainObject(tlsOptions)) {
        // Copy the TLS options in connectionArgs
        helper.loopKeys(tlsOptions, function(tlsOptions, key) {
          connectionArgs[key] = tlsOptions[key];
        });
      }
      self.connection = tls.connect(connectionArgs);
    }
  }

  self.connection.setKeepAlive(true);

  self.timeoutOpen = setTimeout(function() {
    self.connection.end(); // Send a FIN packet
    reject(new Err.ReqlDriverError(&#x27;Failed to connect to &#x27;+self.host+&#x27;:&#x27;+self.port+&#x27; in less than &#x27;+self.timeoutConnect+&#x27;s&#x27;).setOperational
());
  }, self.timeoutConnect*1000);

  self.connection.on(&#x27;end&#x27;, function() {
    self.open = false;
    self.emit(&#x27;end&#x27;);
    // We got a FIN packet, so we&#x27;ll just flush
    self._flush();
  });
  self.connection.on(&#x27;close&#x27;, function() {
    // We emit end or close just once
    clearTimeout(self.timeoutOpen)
    clearInterval(self.pingIntervalId);
    self.connection.removeAllListeners();
    self.open = false;
    self.emit(&#x27;closed&#x27;);
    // The connection is fully closed, flush (in case &#x27;end&#x27; was not triggered)
    self._flush();
  });
  self.connection.setNoDelay();
  self.connection.once(&#x27;error&#x27;, function(error) {
    reject(new Err.ReqlDriverError(&#x27;Failed to connect to &#x27;+self.host+&#x27;:&#x27;+self.port+&#x27;\nFull error:\n&#x27;+JSON.stringify(error)).setOperational
());
  });
  self.connection.on(&#x27;connect&#x27;, function() {
    self.connection.removeAllListeners(&#x27;error&#x27;);
    self.connection.on(&#x27;error&#x27;, function(error) {
      self.emit(&#x27;error&#x27;, error);
    });

    var versionBuffer = new Buffer(4)
    versionBuffer.writeUInt32LE(protodef.VersionDummy.Version.V1_0, 0)

    self.randomString = new Buffer(crypto.randomBytes(18)).toString(&#x27;base64&#x27;)
    var authBuffer = new Buffer(JSON.stringify({
      protocol_version: PROTOCOL_VERSION,
      authentication_method: AUTHENTIFICATION_METHOD,
      authentication: &#x22;n,,n=&#x22; + self.user + &#x22;,r=&#x22; + self.randomString
    }));

    helper.tryCatch(function() {
      self.connection.write(Buffer.concat([versionBuffer, authBuffer, NULL_BUFFER]));
    }, function(err) {
      // The TCP connection is open, but the ReQL connection wasn&#x27;t established.
      // We can just abort the whole thing
      self.open = false;
      reject(new Err.ReqlD ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor" id="apidoc.element.rethinkdbdash.cursor">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>cursor
        <span class="apidocSignatureSpan">(connection, token, options, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cursor(connection, token, options, type) {
  this.connection = connection;
  this.token = token;

  this._stackSize = 0; // Estimation of our call stack.
  this._index = 0; // Position in this._data[0]
  this._data = []; // Array of non empty arrays
  this._fetching = false; // Are we fetching data
  this._canFetch = true; // Can we fetch more data?
  this._pendingPromises = []; // Pending promises&#x27; resolve/reject
  this.options = options || {};
  this._closed = false;
  this._closingPromise = null; // Promise returned by close
  this._type = type;
  this._setIncludesStates = false;
  if ((type === &#x27;feed&#x27;) || (type === &#x27;atomFeed&#x27;)) {
    this.toArray = _unsupportedToArray;
  }
  this._emittedEnd = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue" id="apidoc.element.rethinkdbdash.dequeue">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>dequeue
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Dequeue(size) {
  this.start = 0;
  this.end = 0;

  size = size || 50;
  this.buffer = new Array(size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata" id="apidoc.element.rethinkdbdash.metadata">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>metadata
        <span class="apidocSignatureSpan">(resolve, reject, query, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Metadata(resolve, reject, query, options) {
  this.resolve = resolve;
  this.reject = reject;
  this.query = query; // The query in case we have to build a backtrace
  this.options = options || {};
  this.cursor = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool" id="apidoc.element.rethinkdbdash.pool">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool
        <span class="apidocSignatureSpan">(r, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pool(r, options) {
  this._r = r;

  if (!helper.isPlainObject(options)) options = {};
  this.options = {};
  this.options.max = options.max || 1000; // 4000 is about the maximum the kernel can take
  var buffer = (typeof options.buffer === &#x27;number&#x27;) ? options.buffer : 50;
  this.options.buffer = (buffer &#x3c; this.options.max) ? buffer : this.options.max;
  this.options.timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed
?
  this.options.timeoutGb = options.timeoutGb || 60*60*1000; // Default timeout for TCP connection is 2 hours on Linux, we time out
 after one hour.
  this.options.maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError

  this.options.silent = options.silent || false;

  this.options.connection = {
    host: options.host || this._r._host,
    port: options.port || this._r._port,
    db: options.db || this._r._db,
    timeout: options.timeout || this._r._timeoutConnect,
    authKey: options.authKey,
    user: options.user,
    password: options.password,
    cursor: options.cursor || false,
    stream: options.stream || false,
    ssl: options.ssl || false,
    pingInterval: options.pingInterval || this._r._pingInterval
  }
  this._log = options._log;

  this._pool = new Dequeue(this.options.buffer+1);
  this._draining = false;
  this._drainingHandlers = null; // Store the resolve/reject methods once draining is called
  this._localhostToDrain = 0; // number of connections to &#x22;localhost&#x22; to remove
  this._connectionToReplace = 0; // number of connections to &#x22;localhost&#x22; to remove

  this._numConnections = 0;
  this._openingConnections = 0; // Number of connections being opened
  this._consecutiveFails = 0;   // In slow growth, the number of consecutive failures to open a connection
  this._slowGrowth = false;     // Opening one connection at a time
  this._slowlyGrowing = false;  // The next connection to be returned is one opened in slowGrowth mode
  this._extraConnections = 0; // Number of extra connections being opened that we should eventually close

  this._empty = true;

  var self = this;
  // So we can let the pool master bind listeners
  setTimeout(function() {
    if (self._draining === false) {
      for(var i=0; i&#x3c;self.options.buffer; i++) {
        if (self.getLength() &#x3c; self.options.max) {
          self.createConnection();
        }
      }
    }
  }, 0);
  this.id = Math.floor(Math.random()*100000);
  this._log(&#x27;Creating a pool connected to &#x27;+this.getAddress());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master" id="apidoc.element.rethinkdbdash.pool_master">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool_master
        <span class="apidocSignatureSpan">(r, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PoolMaster(r, options) {
  var self = this;
  var options = options || {};
  var lineLength = options.buffer || 50;

  self._r = r;
  self._line = new Dequeue(lineLength);
  self._pools = {};
  self._pools[UNKNOWN_POOLS] = []; // pools for which we do not know the server&#x27;id
  self._healthyPools = [];
  self._healthy = false;
  self._init = false;
  self._index = 0; // next pool to used
  self._indexUnknown =  0 // next unknown pool to used
  self._discovery = (typeof options.discovery === &#x27;boolean&#x27;) ? options.discovery: false; // Whether the pool master is in discovery
 mode or not
  //self._refresh = (typeof options.refresh === &#x27;number&#x27;) ? options.refresh: 1000*60*60; // Refresh rate for the list of servers
  self._options = options;
  self._options.buffer = options.buffer || 50;
  self._options.max = options.max || 1000;
  self._log = helper.createLogger(self, options.silent || false);
  self._draining = false;
  self._numConnections = 0;
  self._numAvailableConnections = 0;
  self._hasPrintWarningLocalhost = false;
  self._feed = null;
  self._consecutiveFails = -1;
  self._timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?
  self._maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError

  //TODO
  //self._usingPool = true; // If we have used the pool
  self._seed = 0;

  var pool;
  if (Array.isArray(options.servers)) {
    if (options.servers.length &#x3e; 0) {
      self._servers = options.servers;
      for(var i=0; i&#x3c;options.servers.length; i++) {
        var settings = self.createPoolSettings(options, options.servers[i], self._log);
        pool = new Pool(self._r, settings);
        self._pools[UNKNOWN_POOLS].push(pool);
        // A pool is considered healthy by default such that people can do
        // var = require(...)(); query.run();
        self._healthyPools.push(pool);
        self.emitStatus()
      }
    }
    else {
      throw new Err.ReqlDriverError(&#x22;If `servers` is an array, it must contain at least one server&#x22;)
    }
  }
  else {
    self._servers = [{
      host: options.host || &#x27;localhost&#x27;,
      port: options.port || 28015
    }]
    var settings = self.createPoolSettings(options, {}, self._log);
    pool = new Pool(self._r, settings);
    self._pools[UNKNOWN_POOLS].push(pool);
    self._healthyPools.push(pool);
    self.emitStatus()
  }

  // Initialize all the pools - bind listeners
  for(var i=0; i&#x3c;self._pools[UNKNOWN_POOLS].length; i++) {
    self.initPool(self._pools[UNKNOWN_POOLS][i]);
  }
  if ((self._discovery === true)) {
    self._timeout = setTimeout(function() { self.fetchServers() }, 0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream" id="apidoc.element.rethinkdbdash.stream">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>stream
        <span class="apidocSignatureSpan">(options, cursor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadableStream(options, cursor) {
  if (cursor) this._cursor = cursor;
  this._pending = 0; // How many time we called _read while no cursor was available
  this._index = 0;
  this._maxRecursion = 1000; // Hardcoded
  this._highWaterMark = options.highWaterMark;
  this._closed = false;

  Readable.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term" id="apidoc.element.rethinkdbdash.term">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>term
        <span class="apidocSignatureSpan">(r, value, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Term(r, value, error) {
  var self = this;
  var term = function(field) {
    if (Term.prototype._fastArity(arguments.length, 1) === false) {
      var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
      Term.prototype._arity(_args, 1, &#x27;(...)&#x27;, self);
    }
    return term.bracket(field);
  }
  helper.changeProto(term, self);

  if (value === undefined) {
    term._query = [];
  }
  else {
    term._query = value;
  }
  term._r = r; // Keep a reference to r for global settings

  if (error !== undefined) {
    term._error = error;
    term._frames = [];
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream" id="apidoc.element.rethinkdbdash.transform_stream">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>transform_stream
        <span class="apidocSignatureSpan">(table, options, connection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TransformStream(table, options, connection) {
  this._table = table;
  this._r = table._r;
  this._options = options;
  this._cache = [];
  this._pendingCallback = null;
  this._ended = false;
  this._inserting = false;
  this._delayed = false;
  this._connection = connection;
  this._highWaterMark = options.highWaterMark || 100;
  this._insertOptions = {};
  this._insertOptions.durability = options.durability || &#x27;hard&#x27;;
  this._insertOptions.conflict = options.conflict || &#x27;error&#x27;;
  this._insertOptions.returnChanges = options.returnChanges || true;

  // Internal option to run some tests
  if (options.debug === true) {
    this._sequence = [];
  }

  Transform.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.writable_stream" id="apidoc.element.rethinkdbdash.writable_stream">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>writable_stream
        <span class="apidocSignatureSpan">(table, options, connection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WritableStream(table, options, connection) {
  this._table = table;
  this._options = options;
  this._cache = [];
  this._pendingCallback = null;
  this._inserting = false;
  this._delayed = false;
  this._connection = connection;
  this._highWaterMark = options.highWaterMark || 100;

  this._insertOptions = {};
  this._insertOptions.durability = options.durability || &#x27;hard&#x27;;
  this._insertOptions.conflict = options.conflict || &#x27;error&#x27;;

  // Internal option to run some tests
  if (options.debug === true) {
    this._sequence = [];
  }

  Writable.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
  this._i = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.connection" id="apidoc.module.rethinkdbdash.connection">module rethinkdbdash.connection</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.connection" id="apidoc.element.rethinkdbdash.connection.connection">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>connection
        <span class="apidocSignatureSpan">(r, options, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connection(r, options, resolve, reject) {
  var self = this;
  this.r = r;
  this.state = 0; // Track the progress of the handshake. -1 will be used for an error state.

  // Set default options - We have to save them in case the user tries to reconnect
  if (!helper.isPlainObject(options)) options = {};
  this.host = options.host || r._host;
  this.port = options.port || r._port;
  if (options.authKey != null) {
    if (options.user != null || options.password != null) {
      throw new Err.ReqlDriverError(&#x27;Cannot use both authKey and password&#x27;);
    }
    this.user = r._user;
    this.password = options.authKey;
  } else {
    if (options.user === undefined) {
      this.user = r._user;
    } else {
      this.user = options.user;
    }
    if (options.password === undefined) {
      this.password = r._password;
    } else {
      this.password = options.password;
    }
  }

  this.authKey = options.authKey || r._authKey;
  // period in *seconds* for the connection to be opened
  this.timeoutConnect = options.timeout || r._timeoutConnect;
  // The connection will be pinged every &#x3c;pingInterval&#x3e; seconds
  this.pingInterval = options.pingInterval || r._pingInterval;

  if (options.db) this.db = options.db; // Pass to each query

  this.token = 1;
  this.buffer = new Buffer(0);

  this.metadata = {}

  this.open = false; // true only if the user can write on the socket
  this.timeout = null;

  if (options.connection) {
    this.connection = options.connection;
  }
  else {
    var family = &#x27;IPv4&#x27;;
    if (net.isIPv6(self.host)) {
      family = &#x27;IPv6&#x27;;
    }

    var connectionArgs = {
      host: self.host,
      port: self.port,
      family: family
    }

    var tlsOptions = options.ssl || false;
    if (tlsOptions === false) {
      self.connection = net.connect(connectionArgs);
    } else {
      if (helper.isPlainObject(tlsOptions)) {
        // Copy the TLS options in connectionArgs
        helper.loopKeys(tlsOptions, function(tlsOptions, key) {
          connectionArgs[key] = tlsOptions[key];
        });
      }
      self.connection = tls.connect(connectionArgs);
    }
  }

  self.connection.setKeepAlive(true);

  self.timeoutOpen = setTimeout(function() {
    self.connection.end(); // Send a FIN packet
    reject(new Err.ReqlDriverError(&#x27;Failed to connect to &#x27;+self.host+&#x27;:&#x27;+self.port+&#x27; in less than &#x27;+self.timeoutConnect+&#x27;s&#x27;).setOperational
());
  }, self.timeoutConnect*1000);

  self.connection.on(&#x27;end&#x27;, function() {
    self.open = false;
    self.emit(&#x27;end&#x27;);
    // We got a FIN packet, so we&#x27;ll just flush
    self._flush();
  });
  self.connection.on(&#x27;close&#x27;, function() {
    // We emit end or close just once
    clearTimeout(self.timeoutOpen)
    clearInterval(self.pingIntervalId);
    self.connection.removeAllListeners();
    self.open = false;
    self.emit(&#x27;closed&#x27;);
    // The connection is fully closed, flush (in case &#x27;end&#x27; was not triggered)
    self._flush();
  });
  self.connection.setNoDelay();
  self.connection.once(&#x27;error&#x27;, function(error) {
    reject(new Err.ReqlDriverError(&#x27;Failed to connect to &#x27;+self.host+&#x27;:&#x27;+self.port+&#x27;\nFull error:\n&#x27;+JSON.stringify(error)).setOperational
());
  });
  self.connection.on(&#x27;connect&#x27;, function() {
    self.connection.removeAllListeners(&#x27;error&#x27;);
    self.connection.on(&#x27;error&#x27;, function(error) {
      self.emit(&#x27;error&#x27;, error);
    });

    var versionBuffer = new Buffer(4)
    versionBuffer.writeUInt32LE(protodef.VersionDummy.Version.V1_0, 0)

    self.randomString = new Buffer(crypto.randomBytes(18)).toString(&#x27;base64&#x27;)
    var authBuffer = new Buffer(JSON.stringify({
      protocol_version: PROTOCOL_VERSION,
      authentication_method: AUTHENTIFICATION_METHOD,
      authentication: &#x22;n,,n=&#x22; + self.user + &#x22;,r=&#x22; + self.randomString
    }));

    helper.tryCatch(function() {
      self.connection.write(Buffer.concat([versionBuffer, authBuffer, NULL_BUFFER]));
    }, function(err) {
      // The TCP connection is open, but the ReQL connection wasn&#x27;t established.
      // We can just abort the whole thing
      self.open = false;
      reject(new Err.ReqlD ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.super_" id="apidoc.element.rethinkdbdash.connection.super_">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.connection.prototype" id="apidoc.module.rethinkdbdash.connection.prototype">module rethinkdbdash.connection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._abort" id="apidoc.element.rethinkdbdash.connection.prototype._abort">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_abort = function () {
  this.state = -1;
  this.removeAllListeners();
  this.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      for(var i=0; i&#x3c;self.buffer.length; i++) {
if (self.buffer[i] === 0) {
  var messageServerStr = self.buffer.slice(0, i).toString();
  self.buffer = self.buffer.slice(i+1); // +1 to remove the null byte
  try {
    var messageServer = JSON.parse(messageServerStr);
  } catch(error) {
    self.<span class="apidocCodeKeywordSpan">_abort</span>();
    reject(new Err.ReqlDriverError(&#x27;Could not parse the message sent by the server : \&#x27;&#x27;+messageServerStr+&#x27;\&#
x27;&#x27;).setOperational());
    return;
  }
  if (messageServer.success !== true) {
    self._abort();
    reject(new Err.ReqlDriverError(&#x27;Error &#x27;+messageServer.error_code+&#x27;:&#x27;+messageServer.error).setOperational
());
    return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._checkProtocolVersion" id="apidoc.element.rethinkdbdash.connection.prototype._checkProtocolVersion">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_checkProtocolVersion
        <span class="apidocSignatureSpan">(messageServer, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkProtocolVersion = function (messageServer, reject) {
  // Expect max_protocol_version, min_protocol_version, server_version, success
  var minVersion = messageServer.min_protocol_version
  var maxVersion = messageServer.max_protocol_version

  if (minVersion &#x3e; PROTOCOL_VERSION || maxVersion &#x3c; PROTOCOL_VERSION) {
    this._abort();
    reject(new Err.ReqlDriverError(&#x27;Unsupported protocol version: &#x27;+PROTOCOL_VERSION+&#x27;, expected between &#x27;+minVersion+&#x27; and &#x27;+ maxVersion
).setOperational());
  }
  this.state = 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (messageServer.success !== true) {
    self._abort();
    reject(new Err.ReqlDriverError(&#x27;Error &#x27;+messageServer.error_code+&#x27;:&#x27;+messageServer.error).setOperational
());
    return;
  }

  if (self.state === 0) {
    self.<span class="apidocCodeKeywordSpan">_checkProtocolVersion</span>(messageServer, reject);
  } else if (self.state === 1) {
    // Compute salt and send the proof
    self._computeSaltedPassword(messageServer, reject);
  } else if (self.state === 2) {
    self._compareDigest(messageServer, resolve, reject);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._compareDigest" id="apidoc.element.rethinkdbdash.connection.prototype._compareDigest">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_compareDigest
        <span class="apidocSignatureSpan">(messageServer, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compareDigest = function (messageServer, resolve, reject) {
  var self = this;
  var firstEquals = messageServer.authentication.indexOf(&#x27;=&#x27;)
  var serverSignatureValue = messageServer.authentication.slice(firstEquals+1)

  if (!helper.compareDigest(serverSignatureValue, self.serverSignature.toString(&#x22;base64&#x22;))) {
    reject(new Err.ReqlDriverError(&#x27;Invalid server signature&#x27;).setOperational());
  }

  self.state = 4
  self.connection.removeAllListeners(&#x27;error&#x27;);
  self.open = true;
  self.connection.on(&#x27;error&#x27;, function(e) {
    self.open = false;
  });
  clearTimeout(self.timeoutOpen)
  resolve(self);
  if (self.pingInterval &#x3e; 0) {
    self.pingIntervalId = setInterval(function() {
      self.pendingPing = true;
      self.r.error(PING_VALUE).run(self).error(function(error) {
        self.pendingPing = false;
        if (error.message !== PING_VALUE) {
          self.emit(&#x27;error&#x27;, new Err.ReqlDriverError(
                &#x27;Could not ping the connection&#x27;).setOperational());
          self.open = false;
          self.connection.end();
        } else {
        }
      });
    }, self.pingInterval*1000);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      if (self.state === 0) {
        self._checkProtocolVersion(messageServer, reject);
      } else if (self.state === 1) {
        // Compute salt and send the proof
        self._computeSaltedPassword(messageServer, reject);
      } else if (self.state === 2) {
        self.<span class="apidocCodeKeywordSpan">_compareDigest</span>(messageServer, resolve, reject);
      }
    }
  }
}
else {
  while(self.buffer.length &#x3e;= 12) {
    var token = self.buffer.readUInt32LE(0) + 0x100000000 * self.buffer.readUInt32LE(4);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._computeSaltedPassword" id="apidoc.element.rethinkdbdash.connection.prototype._computeSaltedPassword">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_computeSaltedPassword
        <span class="apidocSignatureSpan">(messageServer, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_computeSaltedPassword = function (messageServer, reject) {
  var self = this;
  var authentication = helper.splitCommaEqual(messageServer.authentication);

  var randomNonce = authentication.r
  var salt = new Buffer(authentication.s, &#x27;base64&#x27;)
  var iterations = parseInt(authentication.i)

  if (randomNonce.substr(0, self.randomString.length) !== self.randomString) {
    self._abort();
    reject(new Err.ReqlDriverError(&#x27;Invalid nonce from server&#x27;).setOperational());
  }

  // The salt is constant, so we can cache the salted password.
  var cacheKey = self.password.toString(&#x22;base64&#x22;)+&#x27;,&#x27;+salt.toString(&#x22;base64&#x22;)+&#x27;,&#x27;+iterations;
  if (CACHE_PBKDF2.hasOwnProperty(cacheKey)) {
    helper.tryCatch(function() {
      self._sendProof(messageServer.authentication, randomNonce, CACHE_PBKDF2[cacheKey]);
    }, function(err) {
      // The TCP connection is open, but the ReQL connection wasn&#x27;t established.
      // We can just abort the whole thing
      self.open = false;
      reject(new Err.ReqlDriverError(&#x27;Failed to perform handshake with &#x27;+self.host+&#x27;:&#x27;+self.port).setOperational());
    });
  } else {
    crypto.pbkdf2(self.password, salt, iterations, KEY_LENGTH, &#x22;sha256&#x22;, function(error, saltedPassword) {
      if (error != null) {
        self._abort();
        reject(new Err.ReqlDriverError(&#x27;Could not derive the key. Error:&#x27; + error.toString()).setOperational());
      }
      CACHE_PBKDF2[cacheKey] = saltedPassword;
      helper.tryCatch(function() {
        self._sendProof(messageServer.authentication, randomNonce, saltedPassword);
      }, function(err) {
        // The TCP connection is open, but the ReQL connection wasn&#x27;t established.
        // We can just abort the whole thing
        self.open = false;
        reject(new Err.ReqlDriverError(&#x27;Failed to perform handshake with &#x27;+self.host+&#x27;:&#x27;+self.port).setOperational());
      });
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
      }

      if (self.state === 0) {
        self._checkProtocolVersion(messageServer, reject);
      } else if (self.state === 1) {
        // Compute salt and send the proof
        self.<span class="apidocCodeKeywordSpan">_computeSaltedPassword</span>(messageServer, reject);
      } else if (self.state === 2) {
        self._compareDigest(messageServer, resolve, reject);
      }
    }
  }
}
else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._continue" id="apidoc.element.rethinkdbdash.connection.prototype._continue">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_continue
        <span class="apidocSignatureSpan">(token, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_continue = function (token, resolve, reject) {
  var query = [protodef.Query.QueryType.CONTINUE];
  this._send(query, token, resolve, reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Cursor.prototype._fetch = function() {
var self = this;
this._fetching = true;

var p = new Promise(function(resolve, reject) {
  self.connection.<span class="apidocCodeKeywordSpan">_continue</span>(self.token, resolve, reject);
}).then(function(response) {
  self._push(response);
  return null;
}).error(function(error) {
  self._fetching = false;
  self._canFetch = false;
  self._pushError(error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._end" id="apidoc.element.rethinkdbdash.connection.prototype._end">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_end
        <span class="apidocSignatureSpan">(token, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_end = function (token, resolve, reject) {
  var query = [protodef.Query.QueryType.STOP];
  this._send(query, token, resolve, reject, undefined, undefined, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var endCallback = function() {
      if (self._eventEmitter &#x26;&#x26; (self._emittedEnd === false)) {
        self._emittedEnd = true;
        self._eventEmitter.emit(&#x27;end&#x27;);
      }
      resolve();
    }
    self.connection.<span class="apidocCodeKeywordSpan">_end</span>(self.token, endCallback, reject);
  }
}).nodeify(callback);
return self._closingPromise;
}
Cursor.prototype._each = function(callback, onFinish) {
if (this._closed === true) {
  return callback(new Err.ReqlDriverError(&#x27;You cannot retrieve data from a cursor that is closed&#x27;).setOperational());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._flush" id="apidoc.element.rethinkdbdash.connection.prototype._flush">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function () {
  helper.loopKeys(this.metadata, function(metadata, key) {
    if (typeof metadata[key].reject === &#x27;function&#x27;) {
      metadata[key].reject(new Err.ReqlServerError(
            &#x27;The connection was closed before the query could be completed.&#x27;,
            metadata[key].query));
    }
    if (typeof metadata[key].endReject === &#x27;function&#x27;) {
      metadata[key].endReject(new Err.ReqlServerError(
            &#x27;The connection was closed before the query could be completed.&#x27;,
            metadata[key].query));
    }
  });
  this.metadata = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  reject(new Err.ReqlDriverError(&#x27;Failed to connect to &#x27;+self.host+&#x27;:&#x27;+self.port+&#x27; in less than &#x27;+
self.timeoutConnect+&#x27;s&#x27;).setOperational());
}, self.timeoutConnect*1000);

self.connection.on(&#x27;end&#x27;, function() {
  self.open = false;
  self.emit(&#x27;end&#x27;);
  // We got a FIN packet, so we&#x27;ll just flush
  self.<span class="apidocCodeKeywordSpan">_flush</span>();
});
self.connection.on(&#x27;close&#x27;, function() {
  // We emit end or close just once
  clearTimeout(self.timeoutOpen)
  clearInterval(self.pingIntervalId);
  self.connection.removeAllListeners();
  self.open = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._getToken" id="apidoc.element.rethinkdbdash.connection.prototype._getToken">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_getToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getToken = function () {
  return this.token++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.db = db;
}

Connection.prototype.server = function(callback) {
  var self = this;
  return new Promise(function(resolve, reject) {
    var query = [protodef.Query.QueryType.SERVER_INFO];
    self._send(query, self.<span class="apidocCodeKeywordSpan">_getToken</span>(), resolve, reject, undefined, undefined, true);
  }).nodeify(callback);
}

// Return the next token and update it.
Connection.prototype._getToken = function() {
  return this.token++;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._isConnection" id="apidoc.element.rethinkdbdash.connection.prototype._isConnection">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_isConnection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isConnection = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this;

if (self._error != null) {
  var error = new Error.ReqlRuntimeError(self._error, self._query, {b: self._frames});
  return Promise.reject(error);
}

if (helper.isPlainObject(connection) &#x26;&#x26; (typeof connection._isConnection === &#x27;function&#x27;) &#x26;&#x26; (connection
.<span class="apidocCodeKeywordSpan">_isConnection</span>() === true)) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  }
  else {
    if (!helper.isPlainObject(options)) options = {};
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._isOpen" id="apidoc.element.rethinkdbdash.connection.prototype._isOpen">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_isOpen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isOpen = function () {
  return this.open;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    clearTimeout(connection.timeout);
    self._decreaseNumConnections();
    self._expandBuffer();
  });
  connection.on(&#x27;release&#x27;, function() {
    if (this.<span class="apidocCodeKeywordSpan">_isOpen</span>()) self.putConnection(this);
  });
  self.putConnection(connection);
  return null;
}).error(function(error) {
  // We failed to create a connection, we are now going to create connections one by one
  self._openingConnections--;
  self._decreaseNumConnections();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._processResponse" id="apidoc.element.rethinkdbdash.connection.prototype._processResponse">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_processResponse
        <span class="apidocSignatureSpan">(response, token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processResponse = function (response, token) {
  //console.log(&#x27;Connection.prototype._processResponse: &#x27;+token);
  //console.log(JSON.stringify(response, null, 2));
  var self = this;

  var type = response.t;
  var result;
  var cursor;
  var stream;
  var currentResolve, currentReject;
  var datum;
  var options;

  if (type === responseTypes.COMPILE_ERROR) {
    self.emit(&#x27;release&#x27;);
    if (typeof self.metadata[token].reject === &#x27;function&#x27;) {
      self.metadata[token].reject(new Err.ReqlCompileError(helper.makeAtom(response), self.metadata[token].query, response));
    }

    delete self.metadata[token]
  }
  else if (type === responseTypes.CLIENT_ERROR) {
    self.emit(&#x27;release&#x27;);

    if (typeof self.metadata[token].reject === &#x27;function&#x27;) {
      currentResolve = self.metadata[token].resolve;
      currentReject = self.metadata[token].reject;
      self.metadata[token].removeCallbacks();
      currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));
      if (typeof self.metadata[token].endReject !== &#x27;function&#x27;) {
        // No pending STOP query, we can delete
        delete self.metadata[token]
      }
    }
    else if (typeof self.metadata[token].endResolve === &#x27;function&#x27;) {
      currentResolve = self.metadata[token].endResolve;
      currentReject = self.metadata[token].endReject;
      self.metadata[token].removeEndCallbacks();
      currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));
      delete self.metadata[token]
    }
    else if (token === -1) { // This should not happen now since 1.13 took the token out of the query
      var error = new Err.ReqlClientError(helper.makeAtom(response)+&#x27;\nClosing all outstanding queries...&#x27;);
      self.emit(&#x27;error&#x27;, error);
      // We don&#x27;t want a function to yield forever, so we just reject everything
      helper.loopKeys(self.rejectMap, function(rejectMap, key) {
        rejectMap[key](error);
      });
      self.close();
      delete self.metadata[token]
    }
  }
  else if (type === responseTypes.RUNTIME_ERROR) {
    var errorValue = helper.makeAtom(response);
    var error;
    // We don&#x27;t want to release a connection if we just pinged it.
    if (self.pendingPing === false || (errorValue !== PING_VALUE)) {
      self.emit(&#x27;release&#x27;);
      error = new Err.ReqlRuntimeError(errorValue, self.metadata[token].query, response);
    } else {
      error = new Err.ReqlRuntimeError(errorValue);
    }

    if (typeof self.metadata[token].reject === &#x27;function&#x27;) {
      currentResolve = self.metadata[token].resolve;
      currentReject = self.metadata[token].reject;
      self.metadata[token].removeCallbacks();
      error.setName(response.e);
      currentReject(error);
      if (typeof self.metadata[token].endReject !== &#x27;function&#x27;) {
        // No pending STOP query, we can delete
        delete self.metadata[token]
      }
    }
    else if (typeof self.metadata[token].endResolve === &#x27;function&#x27;) {
      currentResolve = self.metadata[token].endResolve;
      currentReject = self.metadata[token].endReject;
      self.metadata[token].removeEndCallbacks();
      delete self.metadata[token]
    }
  }
  else if (type === responseTypes.SUCCESS_ATOM) {
    self.emit(&#x27;release&#x27;);
    // self.metadata[token].resolve is always a function
    datum = helper.makeAtom(response, self.metadata[token].options);

    if ((Array.isArray(datum)) &#x26;&#x26;
        ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) &#x26;&#x26; (self.r._options
.cursor === true)))) {
      cursor = new Cursor(self, token, self.metadata[token].options, &#x27;cursor&#x27;);
      if (self.metadata[token].options.profile === true) {
        self.metadata[token].resolve({
          profile: response.p,
          result: cursor
        });
      }
      else {
        self.metadata[token].resolve(cursor);
      }

      cursor._push({done: true, response: { r: datum }});
    }
    else if ((Array.isArray(datum)) &#x26;&#x26;
        ((self.metadata[token].options.stream === true || self.r._options.stream === true) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var responseLength = self.buffer.readUInt32LE(8);

      if (self.buffer.length &#x3c; 12+responseLength) break;

      var responseBuffer = self.buffer.slice(12, 12+responseLength);
      var response = JSON.parse(responseBuffer);

      self.<span class="apidocCodeKeywordSpan">_processResponse</span>(response, token);

      self.buffer = self.buffer.slice(12+responseLength);
    }
  }
});

self.connection.on(&#x27;timeout&#x27;, function(buffer) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._send" id="apidoc.element.rethinkdbdash.connection.prototype._send">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_send
        <span class="apidocSignatureSpan">(query, token, resolve, reject, originalQuery, options, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_send = function (query, token, resolve, reject, originalQuery, options, end) {
  //console.log(&#x27;Connection.prototype._send: &#x27;+token);
  //console.log(JSON.stringify(query, null, 2));

  var self = this;
  if (self.open === false) {
    var err = new Err.ReqlDriverError(&#x27;The connection was closed by the other party&#x27;);
    err.setOperational();
    reject(err);
    return;
  }

  var queryStr = JSON.stringify(query);
  var querySize = Buffer.byteLength(queryStr);

  var buffer = new Buffer(8+4+querySize);
  buffer.writeUInt32LE(token &#x26; 0xFFFFFFFF, 0)
  buffer.writeUInt32LE(Math.floor(token / 0xFFFFFFFF), 4)

  buffer.writeUInt32LE(querySize, 8);

  buffer.write(queryStr, 12);

  // noreply instead of noReply because the otpions are translated for the server
  if ((!helper.isPlainObject(options)) || (options.noreply != true)) {
    if (!self.metadata[token]) {
      self.metadata[token] = new Metadata(resolve, reject, originalQuery, options);
    }
    else if (end === true) {
      self.metadata[token].setEnd(resolve, reject);
    }
    else {
      self.metadata[token].setCallbacks(resolve, reject);
    }
  }
  else {
    if (typeof resolve === &#x27;function&#x27;) resolve();
    this.emit(&#x27;release&#x27;);
  }

  // This will emit an error if the connection is closed
  helper.tryCatch(function() {
    self.connection.write(buffer);
  }, function(err) {
    self.metadata[token].reject(err);
    delete self.metadata[token]
  });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    delete self.metadata[token]
  });

};

Connection.prototype._continue = function(token, resolve, reject) {
  var query = [protodef.Query.QueryType.CONTINUE];
  this.<span class="apidocCodeKeywordSpan">_send</span>(query, token, resolve, reject);
}
Connection.prototype._end = function(token, resolve, reject) {
  var query = [protodef.Query.QueryType.STOP];
  this._send(query, token, resolve, reject, undefined, undefined, true);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype._sendProof" id="apidoc.element.rethinkdbdash.connection.prototype._sendProof">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>_sendProof
        <span class="apidocSignatureSpan">(authentication, randomNonce, saltedPassword)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendProof = function (authentication, randomNonce, saltedPassword) {
  var clientFinalMessageWithoutProof = &#x22;c=biws,r=&#x22; + randomNonce;
  var clientKey = crypto.createHmac(&#x22;sha256&#x22;, saltedPassword).update(&#x22;Client Key&#x22;).digest()
  var storedKey = crypto.createHash(&#x22;sha256&#x22;).update(clientKey).digest()

  var authMessage =
      &#x22;n=&#x22; + this.user + &#x22;,r=&#x22; + this.randomString + &#x22;,&#x22; +
      authentication + &#x22;,&#x22; +
      clientFinalMessageWithoutProof

  var clientSignature = crypto.createHmac(&#x22;sha256&#x22;, storedKey).update(authMessage).digest()
  var clientProof = helper.xorBuffer(clientKey, clientSignature)

  var serverKey = crypto.createHmac(&#x22;sha256&#x22;, saltedPassword).update(&#x22;Server Key&#x22;).digest()
  this.serverSignature = crypto.createHmac(&#x22;sha256&#x22;, serverKey).update(authMessage).digest()

  this.state = 2
  var message = JSON.stringify({
    authentication: clientFinalMessageWithoutProof + &#x22;,p=&#x22; + clientProof.toString(&#x22;base64&#x22;)
  })
  this.connection.write(Buffer.concat([new Buffer(message.toString()), NULL_BUFFER]))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  reject(new Err.ReqlDriverError(&#x27;Invalid nonce from server&#x27;).setOperational());
}

// The salt is constant, so we can cache the salted password.
var cacheKey = self.password.toString(&#x22;base64&#x22;)+&#x27;,&#x27;+salt.toString(&#x22;base64&#x22;)+&#x27;,&#x27;+iterations
;
if (CACHE_PBKDF2.hasOwnProperty(cacheKey)) {
  helper.tryCatch(function() {
    self.<span class="apidocCodeKeywordSpan">_sendProof</span>(messageServer.authentication, randomNonce, CACHE_PBKDF2[cacheKey]);
  }, function(err) {
    // The TCP connection is open, but the ReQL connection wasn&#x27;t established.
    // We can just abort the whole thing
    self.open = false;
    reject(new Err.ReqlDriverError(&#x27;Failed to perform handshake with &#x27;+self.host+&#x27;:&#x27;+self.port).setOperational
());
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype.close" id="apidoc.element.rethinkdbdash.connection.prototype.close">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>close
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  }
  var self = this;

  var p = new Promise(function(resolve, reject) {
    if (!helper.isPlainObject(options)) options = {};
    if (options.noreplyWait === true) {
      self.noreplyWait().then(function(r) {
        self.open = false;
        self.connection.end()
        resolve(r);
      }).error(function(e) {
        reject(e)
      });
    }
    else{
      self.open = false;
      self.connection.end();
      resolve();
    }
  }).nodeify(callback);
  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
2. Remove everything related to a connection:

```js
r.connect({host: ..., port: ...}).then(function(connection) {
  connection.on(&#x27;error&#x27;, handleError);
  query.run(connection).then(function(result) {
    // console.log(result);
    connection.<span class="apidocCodeKeywordSpan">close</span>();
  });
});
```

Becomes:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype.noReplyWait" id="apidoc.element.rethinkdbdash.connection.prototype.noReplyWait">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>noReplyWait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noReplyWait = function () {
  throw new Err.ReqlDriverError(&#x27;Did you mean to use `noreplyWait` instead of `noReplyWait`?&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype.noreplyWait" id="apidoc.element.rethinkdbdash.connection.prototype.noreplyWait">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>noreplyWait
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noreplyWait = function (callback) {
  var self = this;
  var token = self._getToken();

  var p = new Promise(function(resolve, reject) {
    var query = [protodef.Query.QueryType.NOREPLY_WAIT];

    self._send(query, token, resolve, reject);
  }).nodeify(callback);
  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  options = {};
}
var self = this;

var p = new Promise(function(resolve, reject) {
  if (!helper.isPlainObject(options)) options = {};
  if (options.noreplyWait === true) {
    self.<span class="apidocCodeKeywordSpan">noreplyWait</span>().then(function(r) {
      self.open = false;
      self.connection.end()
      resolve(r);
    }).error(function(e) {
      reject(e)
    });
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype.reconnect" id="apidoc.element.rethinkdbdash.connection.prototype.reconnect">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>reconnect
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconnect = function (options, callback) {
  var self = this;

  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  }

  if (!helper.isPlainObject(options)) options = {};

  if (options.noreplyWait === true) {
    var p = new Promise(function(resolve, reject) {
      self.close(options).then(function() {
        self.r.connect({
          host: self.host,
          port: self.port,
          authKey: self.authKey,
          db: self.db
        }).then(function(c) {
          resolve(c);
        }).error(function(e) {
          reject(e);
        });
      }).error(function(e) {
        reject(e)
      })
    }).nodeify(callback);
  }
  else {
    return self.r.connect({
      host: self.host,
      port: self.port,
      authKey: self.authKey,
      db: self.db
    }, callback);
  }

  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype.server" id="apidoc.element.rethinkdbdash.connection.prototype.server">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>server
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">server = function (callback) {
  var self = this;
  return new Promise(function(resolve, reject) {
    var query = [protodef.Query.QueryType.SERVER_INFO];
    self._send(query, self._getToken(), resolve, reject, undefined, undefined, true);
  }).nodeify(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.connection.prototype.use" id="apidoc.element.rethinkdbdash.connection.prototype.use">
        function <span class="apidocSignatureSpan">rethinkdbdash.connection.prototype.</span>use
        <span class="apidocSignatureSpan">(db)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (db) {
  if (typeof db !== &#x27;string&#x27;) throw new Err.ReqlDriverError(&#x27;First argument of `use` must be a string&#x27;)
  this.db = db;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.cursor" id="apidoc.module.rethinkdbdash.cursor">module rethinkdbdash.cursor</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.cursor" id="apidoc.element.rethinkdbdash.cursor.cursor">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>cursor
        <span class="apidocSignatureSpan">(connection, token, options, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cursor(connection, token, options, type) {
  this.connection = connection;
  this.token = token;

  this._stackSize = 0; // Estimation of our call stack.
  this._index = 0; // Position in this._data[0]
  this._data = []; // Array of non empty arrays
  this._fetching = false; // Are we fetching data
  this._canFetch = true; // Can we fetch more data?
  this._pendingPromises = []; // Pending promises&#x27; resolve/reject
  this.options = options || {};
  this._closed = false;
  this._closingPromise = null; // Promise returned by close
  this._type = type;
  this._setIncludesStates = false;
  if ((type === &#x27;feed&#x27;) || (type === &#x27;atomFeed&#x27;)) {
    this.toArray = _unsupportedToArray;
  }
  this._emittedEnd = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.cursor.prototype" id="apidoc.module.rethinkdbdash.cursor.prototype">module rethinkdbdash.cursor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._done" id="apidoc.element.rethinkdbdash.cursor.prototype._done">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_done
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_done = function () {
  this._canFetch = false;
  if (this._eventEmitter) {
    this._eventEmitter.emit(&#x27;end&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self._canFetch = false;
  self._pushError(error);
})
}

Cursor.prototype._push = function(data) {
var couldfetch = this._canFetch;
if (data.done) this.<span class="apidocCodeKeywordSpan">_done</span>();
var response = data.response;
this._fetching = false;
// If the cursor was closed, we ignore all following response
if ((response.r.length &#x3e; 0) &#x26;&#x26; (couldfetch === true)) {
  this._data.push(helper.makeSequence(response, this.options));
}
// this._fetching = false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._each" id="apidoc.element.rethinkdbdash.cursor.prototype._each">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_each
        <span class="apidocSignatureSpan">(callback, onFinish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_each = function (callback, onFinish) {
  if (this._closed === true) {
    return callback(new Err.ReqlDriverError(&#x27;You cannot retrieve data from a cursor that is closed&#x27;).setOperational());
  }
  var self = this;

  var reject = function(err) {
    if (err.message === &#x27;No more rows in the &#x27;+self._type.toLowerCase()+&#x27;.&#x27;) {
      if (typeof onFinish === &#x27;function&#x27;) {
        onFinish();
      }
    }
    else {
      callback(err);
    }
    return null;
  }
  var resolve = function(data) {
    self._stackSize++;
    var keepGoing = callback(null, data);
    if (keepGoing === false) {
      if (typeof onFinish === &#x27;function&#x27;) {
        onFinish();
      }
    }
    else {
      if (self._closed === false) {
        if (self._stackSize &#x3c;= MAX_CALL_STACK) {
          self._next().then(resolve).error(function(error) {
            if ((error.message !== &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) &#x26;&#x26;
                (error.message.match(/You cannot call `next` on a closed/) === null)) {
              reject(error);
            }
          });
        }
        else {
          setTimeout(function() {
            self._stackSize = 0;
            self._next().then(resolve).error(function(error) {
              if ((error.message !== &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) &#x26;&#x26;
                  (error.message.match(/You cannot call `next` on a closed/) === null)) {
                reject(error);
              }
            });
          }, 0);
        }
      }
    }
    return null;
  }

  self._next().then(resolve).error(function(error) {
    // We can silence error when the cursor is closed as this
    if ((error.message !== &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) &#x26;&#x26;
        (error.message.match(/You cannot call `next` on a closed/) === null)) {
      reject(error);
    }
  });
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
throw new Error(&#x27;The `hasNext` command has been removed in 1.13, please use `next`.&#x27;)
}
Cursor.prototype.toArray = function(callback) {
var self = this;
var p = new Promise(function(resolve, reject) {
  var result = [];
  var i =0;
  self.<span class="apidocCodeKeywordSpan">_each</span>(function(err, data) {
    if (err) {
      reject(err);
    }
    else {
      result.push(data);
    }
  }, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._eachAsync" id="apidoc.element.rethinkdbdash.cursor.prototype._eachAsync">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_eachAsync
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_eachAsync = function (callback) {
  var self = this;
  return new Promise(function(resolve, reject) {
    self._eachAsyncInternal(callback, resolve, reject)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._eachAsyncInternal" id="apidoc.element.rethinkdbdash.cursor.prototype._eachAsyncInternal">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_eachAsyncInternal
        <span class="apidocSignatureSpan">(callback, finalResolve, finalReject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_eachAsyncInternal = function (callback, finalResolve, finalReject) {
  if (this._closed === true) {
    finalReject(new Err.ReqlDriverError(&#x27;You cannot retrieve data from a cursor that is closed&#x27;).setOperational());
    return;
  }
  var self = this;

  var nextCb = function() {
    self._stackSize++;
    self._next().then(function(row) {
      if (self._stackSize &#x3c;= MAX_CALL_STACK) {
        if (callback.length &#x3c;= 1) {
          Promise.resolve(callback(row)).then(nextCb)
          return null;
        }
        else {
          new Promise(function(resolve, reject) {
            return callback(row, resolve)
          }).then(nextCb);
          return null;
        }
      }
      else {
        new Promise(function(resolve, reject) {
          setTimeout(function() {
            self._stackSize = 0;
            if (callback.length &#x3c;= 1) {
              Promise.resolve(callback(row)).then(resolve).catch(reject);
            }
            else {
              new Promise(function(resolve, reject) {
                return callback(row, resolve)
              }).then(resolve).catch(reject);
              return null;
            }
          }, 0)
        }).then(nextCb);
        return null;
      }
    }).error(function(error) {
      if ((error.message === &#x27;No more rows in the &#x27;+self._type.toLowerCase()+&#x27;.&#x27;) ||
          (error.message === &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) ||
          (error.message.match(/You cannot call `next` on a closed/) !== null)) {
        return finalResolve();
      }
      return finalReject(Err.setOperational(error));
    });
  }
  nextCb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});
return null;
}
Cursor.prototype._eachAsync = function(callback) {
var self = this;
return new Promise(function(resolve, reject) {
  self.<span class="apidocCodeKeywordSpan">_eachAsyncInternal</span>(callback, resolve, reject)
});
}
Cursor.prototype._eachAsyncInternal = function(callback, finalResolve, finalReject) {
if (this._closed === true) {
  finalReject(new Err.ReqlDriverError(&#x27;You cannot retrieve data from a cursor that is closed&#x27;).setOperational());
  return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._eachCb" id="apidoc.element.rethinkdbdash.cursor.prototype._eachCb">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_eachCb
        <span class="apidocSignatureSpan">(err, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_eachCb = function (err, data) {
  // We should silent things if the cursor/feed is closed
  if (this._closed === false) {
    if (err) {
      this._eventEmitter.emit(&#x27;error&#x27;, err);
    }
    else {
      this._eventEmitter.emit(&#x27;data&#x27;, data);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._fetch" id="apidoc.element.rethinkdbdash.cursor.prototype._fetch">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fetch = function () {
  var self = this;
  this._fetching = true;

  var p = new Promise(function(resolve, reject) {
    self.connection._continue(self.token, resolve, reject);
  }).then(function(response) {
    self._push(response);
    return null;
  }).error(function(error) {
    self._fetching = false;
    self._canFetch = false;
    self._pushError(error);
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (self._data[0].length === self._index) {
      self._index = 0;
      self._data.shift();
      if ((self._data.length === 1)
        &#x26;&#x26; (self._canFetch === true)
        &#x26;&#x26; (self._closed === false)
        &#x26;&#x26; (self._fetching === false)) {
          self.<span class="apidocCodeKeywordSpan">_fetch</span>();
      }
    }
    return Promise.resolve(result).nodeify(callback);
  }
}
else {
  return new Promise(function(resolve, reject) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._flush" id="apidoc.element.rethinkdbdash.cursor.prototype._flush">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function () {
  while ((this._pendingPromises.length &#x3e; 0) &#x26;&#x26; ((this._data.length &#x3e; 0) || ((this._fetching === false) &#x26;&#x26; (this._canFetch === false
)))) {
    var fullfiller = this._pendingPromises.shift();
    var resolve = fullfiller.resolve;
    var reject = fullfiller.reject;

    if (this._data.length &#x3e; 0) {
      var result = this._data[0][this._index++];
      if (result instanceof Error) {
        reject(result);
      }
      else {
        resolve(result);
      }

      if (this._data[0].length === this._index) {
        this._index = 0;
        this._data.shift();
        if ((this._data.length &#x3c;= 1)
          &#x26;&#x26; (this._canFetch === true)
          &#x26;&#x26; (this._closed === false)
          &#x26;&#x26; (this._fetching === false)) {
            this._fetch();
        }
      }
    }
    else {
      reject(new Err.ReqlDriverError(&#x27;No more rows in the &#x27;+this._type.toLowerCase()).setOperational())
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  reject(new Err.ReqlDriverError(&#x27;Failed to connect to &#x27;+self.host+&#x27;:&#x27;+self.port+&#x27; in less than &#x27;+
self.timeoutConnect+&#x27;s&#x27;).setOperational());
}, self.timeoutConnect*1000);

self.connection.on(&#x27;end&#x27;, function() {
  self.open = false;
  self.emit(&#x27;end&#x27;);
  // We got a FIN packet, so we&#x27;ll just flush
  self.<span class="apidocCodeKeywordSpan">_flush</span>();
});
self.connection.on(&#x27;close&#x27;, function() {
  // We emit end or close just once
  clearTimeout(self.timeoutOpen)
  clearInterval(self.pingIntervalId);
  self.connection.removeAllListeners();
  self.open = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._makeEmitter" id="apidoc.element.rethinkdbdash.cursor.prototype._makeEmitter">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_makeEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_makeEmitter = function () {
  this.next = function() {
    throw new Err.ReqlDriverError(&#x27;You cannot call `next` once you have bound listeners on the &#x27;+this._type)
  }
  this.each = function() {
    throw new Err.ReqlDriverError(&#x27;You cannot call `each` once you have bound listeners on the &#x27;+this._type)
  }
  this.eachAsync = function() {
    throw new Err.ReqlDriverError(&#x27;You cannot call `eachAsync` once you have bound listeners on the &#x27;+this._type)
  }
  this.toArray = function() {
    throw new Err.ReqlDriverError(&#x27;You cannot call `toArray` once you have bound listeners on the &#x27;+this._type)
  }
  this._eventEmitter = new EventEmitter();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

for(var i=0; i&#x3c;methods.length; i++) {
(function(n) {
  var method = methods[n];
  Cursor.prototype[method] = function() {
    var self = this;
    if (self._eventEmitter == null) {
      self.<span class="apidocCodeKeywordSpan">_makeEmitter</span>();
      setImmediate(function() {
        self._each(self._eachCb.bind(self), function() {
          if (self._emittedEnd === false) {
            self._emittedEnd = true;
            self._eventEmitter.emit(&#x27;end&#x27;);
          }
        });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._next" id="apidoc.element.rethinkdbdash.cursor.prototype._next">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_next
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_next = function (callback) {
  var self = this;
  if (self._closed === true) {
    return Promise.reject(new Err.ReqlDriverError(
      &#x27;You cannot call `next` on a closed &#x27;+self._type).setOperational()
    ).nodeify(callback);
  }
  else if ((self._data.length === 0) &#x26;&#x26; (self._canFetch === false)) {
    return Promise.reject(new Err.ReqlDriverError(
      &#x27;No more rows in the &#x27;+self._type.toLowerCase()).setOperational()
    ).nodeify(callback);
  }
  else {
    if ((self._data.length &#x3e; 0) &#x26;&#x26; (self._data[0].length &#x3e; self._index)) {
      var result = self._data[0][self._index++];
      if (result instanceof Error) {
        return Promise.reject(result).nodeify(callback);
      }
      else {
        // This could be possible if we get back batch with just one document?
        if (self._data[0].length === self._index) {
          self._index = 0;
          self._data.shift();
          if ((self._data.length === 1)
            &#x26;&#x26; (self._canFetch === true)
            &#x26;&#x26; (self._closed === false)
            &#x26;&#x26; (self._fetching === false)) {
              self._fetch();
          }
        }
        return Promise.resolve(result).nodeify(callback);
      }
    }
    else {
      return new Promise(function(resolve, reject) {
        self._pendingPromises.push({resolve: resolve, reject: reject});
      }).nodeify(callback);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (typeof onFinish === &#x27;function&#x27;) {
    onFinish();
  }
}
else {
  if (self._closed === false) {
    if (self._stackSize &#x3c;= MAX_CALL_STACK) {
      self.<span class="apidocCodeKeywordSpan">_next</span>().then(resolve).error(function(error) {
        if ((error.message !== &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) &#x26;&#x26;
            (error.message.match(/You cannot call `next` on a closed/) === null)) {
          reject(error);
        }
      });
    }
    else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._push" id="apidoc.element.rethinkdbdash.cursor.prototype._push">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_push
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_push = function (data) {
  var couldfetch = this._canFetch;
  if (data.done) this._done();
  var response = data.response;
  this._fetching = false;
  // If the cursor was closed, we ignore all following response
  if ((response.r.length &#x3e; 0) &#x26;&#x26; (couldfetch === true)) {
    this._data.push(helper.makeSequence(response, this.options));
  }
  // this._fetching = false
  if ((this._closed === false) &#x26;&#x26; (this._canFetch) &#x26;&#x26; (this._data.length &#x3c;= 1)) this._fetch();
  this._flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      result: cursor
    });
  }
  else {
    self.metadata[token].resolve(cursor);
  }

  cursor.<span class="apidocCodeKeywordSpan">_push</span>({done: true, response: { r: datum }});
}
else if ((Array.isArray(datum)) &#x26;&#x26;
    ((self.metadata[token].options.stream === true || self.r._options.stream === true))) {
  cursor = new Cursor(self, token, self.metadata[token].options, &#x27;cursor&#x27;);
  stream = new ReadableStream({}, cursor);
  if (self.metadata[token].options.profile === true) {
    self.metadata[token].resolve({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._pushError" id="apidoc.element.rethinkdbdash.cursor.prototype._pushError">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_pushError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_pushError = function (error) {
  this._data.push([error]);
  this._flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.connection._continue(self.token, resolve, reject);
}).then(function(response) {
  self._push(response);
  return null;
}).error(function(error) {
  self._fetching = false;
  self._canFetch = false;
  self.<span class="apidocCodeKeywordSpan">_pushError</span>(error);
})
}

Cursor.prototype._push = function(data) {
var couldfetch = this._canFetch;
if (data.done) this._done();
var response = data.response;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._set" id="apidoc.element.rethinkdbdash.cursor.prototype._set">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_set
        <span class="apidocSignatureSpan">(ar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_set = function (ar) {
  this._fetching = false;
  this._canFetch = false;
  if (ar.length &#x3e; 0) {
    this._data.push(ar);
  }
  this._flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype._unsupportedToArray" id="apidoc.element.rethinkdbdash.cursor.prototype._unsupportedToArray">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>_unsupportedToArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_unsupportedToArray = function () {
  throw new Error(&#x27;The `toArray` method is not available on feeds.&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.addListener" id="apidoc.element.rethinkdbdash.cursor.prototype.addListener">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit(&#x27;end&#x27;);
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.close" id="apidoc.element.rethinkdbdash.cursor.prototype.close">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
  var self = this;
  if (self._closed === true) {
    return self._closingPromise.nodeify(callback);
  }
  self._closed = true;

  self._closingPromise = new Promise(function(resolve, reject) {
    if ((self._canFetch === false) &#x26;&#x26; (self._fetching === false)) {
      resolve()
    }
    else { // since v0_4 (RethinkDB 2.0) we can (must) force a STOP request even if a CONTINUE query is pending
      var endCallback = function() {
        if (self._eventEmitter &#x26;&#x26; (self._emittedEnd === false)) {
          self._emittedEnd = true;
          self._eventEmitter.emit(&#x27;end&#x27;);
        }
        resolve();
      }
      self.connection._end(self.token, endCallback, reject);
    }
  }).nodeify(callback);
  return self._closingPromise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
2. Remove everything related to a connection:

```js
r.connect({host: ..., port: ...}).then(function(connection) {
  connection.on(&#x27;error&#x27;, handleError);
  query.run(connection).then(function(result) {
    // console.log(result);
    connection.<span class="apidocCodeKeywordSpan">close</span>();
  });
});
```

Becomes:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.each" id="apidoc.element.rethinkdbdash.cursor.prototype.each">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>each
        <span class="apidocSignatureSpan">(callback, onFinish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">each = function (callback, onFinish) {
  if (this._closed === true) {
    return callback(new Err.ReqlDriverError(&#x27;You cannot retrieve data from a cursor that is closed&#x27;).setOperational());
  }
  var self = this;

  var reject = function(err) {
    if (err.message === &#x27;No more rows in the &#x27;+self._type.toLowerCase()+&#x27;.&#x27;) {
      if (typeof onFinish === &#x27;function&#x27;) {
        onFinish();
      }
    }
    else {
      callback(err);
    }
    return null;
  }
  var resolve = function(data) {
    self._stackSize++;
    var keepGoing = callback(null, data);
    if (keepGoing === false) {
      if (typeof onFinish === &#x27;function&#x27;) {
        onFinish();
      }
    }
    else {
      if (self._closed === false) {
        if (self._stackSize &#x3c;= MAX_CALL_STACK) {
          self._next().then(resolve).error(function(error) {
            if ((error.message !== &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) &#x26;&#x26;
                (error.message.match(/You cannot call `next` on a closed/) === null)) {
              reject(error);
            }
          });
        }
        else {
          setTimeout(function() {
            self._stackSize = 0;
            self._next().then(resolve).error(function(error) {
              if ((error.message !== &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) &#x26;&#x26;
                  (error.message.match(/You cannot call `next` on a closed/) === null)) {
                reject(error);
              }
            });
          }, 0);
        }
      }
    }
    return null;
  }

  self._next().then(resolve).error(function(error) {
    // We can silence error when the cursor is closed as this
    if ((error.message !== &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) &#x26;&#x26;
        (error.message.match(/You cannot call `next` on a closed/) === null)) {
      reject(error);
    }
  });
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (self._draining === true) {
  // There is no need to close the feed here as we&#x27;ll close the connections
  return feed.close();
}
self._feed = feed;
var initializing = true;
var servers = [];
feed.<span class="apidocCodeKeywordSpan">each</span>(function(err, change) {
  if (err) {
    self._log(&#x27;The changefeed on server_status returned an error: &#x27;+err.toString());
    // We have to refetch everything as the server that was serving the feed may
    // have died.
    if (!self._draining) {
      setTimeout(function() {
        self.fetchServers();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.eachAsync" id="apidoc.element.rethinkdbdash.cursor.prototype.eachAsync">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>eachAsync
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachAsync = function (callback) {
  var self = this;
  return new Promise(function(resolve, reject) {
    self._eachAsyncInternal(callback, resolve, reject)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.emit" id="apidoc.element.rethinkdbdash.cursor.prototype.emit">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit(&#x27;end&#x27;);
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.timeoutOpen = setTimeout(function() {
  self.connection.end(); // Send a FIN packet
  reject(new Err.ReqlDriverError(&#x27;Failed to connect to &#x27;+self.host+&#x27;:&#x27;+self.port+&#x27; in less than &#x27;+
self.timeoutConnect+&#x27;s&#x27;).setOperational());
}, self.timeoutConnect*1000);

self.connection.on(&#x27;end&#x27;, function() {
  self.open = false;
  self.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;end&#x27;);
  // We got a FIN packet, so we&#x27;ll just flush
  self._flush();
});
self.connection.on(&#x27;close&#x27;, function() {
  // We emit end or close just once
  clearTimeout(self.timeoutOpen)
  clearInterval(self.pingIntervalId);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.getType" id="apidoc.element.rethinkdbdash.cursor.prototype.getType">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>getType
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getType = function () {
  return this._type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.hasNext" id="apidoc.element.rethinkdbdash.cursor.prototype.hasNext">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>hasNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasNext = function () {
  throw new Error(&#x27;The `hasNext` command has been removed in 1.13, please use `next`.&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.includesStates" id="apidoc.element.rethinkdbdash.cursor.prototype.includesStates">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>includesStates
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includesStates = function () {
  return this._setIncludesStates;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.listeners" id="apidoc.element.rethinkdbdash.cursor.prototype.listeners">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit(&#x27;end&#x27;);
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.next" id="apidoc.element.rethinkdbdash.cursor.prototype.next">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>next
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (callback) {
  var self = this;
  if (self._closed === true) {
    return Promise.reject(new Err.ReqlDriverError(
      &#x27;You cannot call `next` on a closed &#x27;+self._type).setOperational()
    ).nodeify(callback);
  }
  else if ((self._data.length === 0) &#x26;&#x26; (self._canFetch === false)) {
    return Promise.reject(new Err.ReqlDriverError(
      &#x27;No more rows in the &#x27;+self._type.toLowerCase()).setOperational()
    ).nodeify(callback);
  }
  else {
    if ((self._data.length &#x3e; 0) &#x26;&#x26; (self._data[0].length &#x3e; self._index)) {
      var result = self._data[0][self._index++];
      if (result instanceof Error) {
        return Promise.reject(result).nodeify(callback);
      }
      else {
        // This could be possible if we get back batch with just one document?
        if (self._data[0].length === self._index) {
          self._index = 0;
          self._data.shift();
          if ((self._data.length === 1)
            &#x26;&#x26; (self._canFetch === true)
            &#x26;&#x26; (self._closed === false)
            &#x26;&#x26; (self._fetching === false)) {
              self._fetch();
          }
        }
        return Promise.resolve(result).nodeify(callback);
      }
    }
    else {
      return new Promise(function(resolve, reject) {
        self._pendingPromises.push({resolve: resolve, reject: reject});
      }).nodeify(callback);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.on" id="apidoc.element.rethinkdbdash.cursor.prototype.on">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit(&#x27;end&#x27;);
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// var r = require(&#x27;rethinkdbdash&#x27;)({servers: [{host: ..., port: ...}]});
```

2. Remove everything related to a connection:

```js
r.connect({host: ..., port: ...}).then(function(connection) {
  connection.<span class="apidocCodeKeywordSpan">on</span>(&#x27;error&#x27;, handleError);
  query.run(connection).then(function(result) {
    // console.log(result);
    connection.close();
  });
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.once" id="apidoc.element.rethinkdbdash.cursor.prototype.once">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit(&#x27;end&#x27;);
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.connection.removeAllListeners();
  self.open = false;
  self.emit(&#x27;closed&#x27;);
  // The connection is fully closed, flush (in case &#x27;end&#x27; was not triggered)
  self._flush();
});
self.connection.setNoDelay();
self.connection.<span class="apidocCodeKeywordSpan">once</span>(&#x27;error&#x27;, function(error) {
  reject(new Err.ReqlDriverError(&#x27;Failed to connect to &#x27;+self.host+&#x27;:&#x27;+self.port+&#x27;\nFull error:\n&#x27;+
JSON.stringify(error)).setOperational());
});
self.connection.on(&#x27;connect&#x27;, function() {
  self.connection.removeAllListeners(&#x27;error&#x27;);
  self.connection.on(&#x27;error&#x27;, function(error) {
    self.emit(&#x27;error&#x27;, error);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.removeAllListeners" id="apidoc.element.rethinkdbdash.cursor.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit(&#x27;end&#x27;);
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // We got a FIN packet, so we&#x27;ll just flush
  self._flush();
});
self.connection.on(&#x27;close&#x27;, function() {
  // We emit end or close just once
  clearTimeout(self.timeoutOpen)
  clearInterval(self.pingIntervalId);
  self.connection.<span class="apidocCodeKeywordSpan">removeAllListeners</span>();
  self.open = false;
  self.emit(&#x27;closed&#x27;);
  // The connection is fully closed, flush (in case &#x27;end&#x27; was not triggered)
  self._flush();
});
self.connection.setNoDelay();
self.connection.once(&#x27;error&#x27;, function(error) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.removeListener" id="apidoc.element.rethinkdbdash.cursor.prototype.removeListener">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit(&#x27;end&#x27;);
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.setIncludesStates" id="apidoc.element.rethinkdbdash.cursor.prototype.setIncludesStates">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>setIncludesStates
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setIncludesStates = function () {
  this._setIncludesStates = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      currentReject(new Err.ReqlDriverError(&#x27;Unknown ResponseNote &#x27;+response.n[i]+&#x27;, the driver is probably out of
 date.&#x27;).setOperational());
      return;
    }
  }
}
cursor = new Cursor(self, token, self.metadata[token].options, typeResult);
if (includesStates === true) {
  cursor.<span class="apidocCodeKeywordSpan">setIncludesStates</span>();
}
if ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) &#x26;&#x26; (self.r.
_options.cursor === true))) {
  // Return a cursor
  if (self.metadata[token].options.profile === true) {
    currentResolve({
      profile: response.p,
      result: cursor
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.setMaxListeners" id="apidoc.element.rethinkdbdash.cursor.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () {
  var self = this;
  if (self._eventEmitter == null) {
    self._makeEmitter();
    setImmediate(function() {
      self._each(self._eachCb.bind(self), function() {
        if (self._emittedEnd === false) {
          self._emittedEnd = true;
          self._eventEmitter.emit(&#x27;end&#x27;);
        }
      });
    });
  }
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  self._eventEmitter[method].apply(self._eventEmitter, _args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.toArray" id="apidoc.element.rethinkdbdash.cursor.prototype.toArray">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>toArray
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function (callback) {
  var self = this;
  var p = new Promise(function(resolve, reject) {
    var result = [];
    var i =0;
    self._each(function(err, data) {
      if (err) {
        reject(err);
      }
      else {
        result.push(data);
      }
    }, function() {
      resolve(result);
    });
  }).nodeify(callback);
  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Cursors are coerced to arrays by default

```js
var r = require(&#x27;rethinkdbdash&#x27;)();
r.table(&#x27;data&#x27;).run().then(function(result) {
  assert(Array.isArray(result)) // true
  // With the official driver you need to call
  // result.<span class="apidocCodeKeywordSpan">toArray</span>().then(function(result2) {
  //   assert(Array.isArray(result2))
  // })
});
```

#### Drop in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.toJSON" id="apidoc.element.rethinkdbdash.cursor.prototype.toJSON">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  if (this._type === &#x27;Cursor&#x27;) {
    throw new Err.ReqlDriverError(&#x27;You cannot serialize a Cursor to JSON. Retrieve data from the cursor with `toArray` or `next`&#x27;);
  }
  else {
    throw new Err.ReqlDriverError(&#x27;You cannot serialize a &#x27;+this._type+&#x27; to JSON. Retrieve data from the cursor with `each` or `
next`&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.cursor.prototype.toString" id="apidoc.element.rethinkdbdash.cursor.prototype.toString">
        function <span class="apidocSignatureSpan">rethinkdbdash.cursor.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return &#x27;[object &#x27;+this._type+&#x27;]&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.connection.on(&#x27;error&#x27;, function(error) {
  self.emit(&#x27;error&#x27;, error);
});

var versionBuffer = new Buffer(4)
versionBuffer.writeUInt32LE(protodef.VersionDummy.Version.V1_0, 0)

self.randomString = new Buffer(crypto.randomBytes(18)).<span class="apidocCodeKeywordSpan">toString</span>(&#x27;base64&#x27;)
var authBuffer = new Buffer(JSON.stringify({
  protocol_version: PROTOCOL_VERSION,
  authentication_method: AUTHENTIFICATION_METHOD,
  authentication: &#x22;n,,n=&#x22; + self.user + &#x22;,r=&#x22; + self.randomString
}));

helper.tryCatch(function() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.dequeue" id="apidoc.module.rethinkdbdash.dequeue">module rethinkdbdash.dequeue</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.dequeue" id="apidoc.element.rethinkdbdash.dequeue.dequeue">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>dequeue
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Dequeue(size) {
  this.start = 0;
  this.end = 0;

  size = size || 50;
  this.buffer = new Array(size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.dequeue.prototype" id="apidoc.module.rethinkdbdash.dequeue.prototype">module rethinkdbdash.dequeue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.delete" id="apidoc.element.rethinkdbdash.dequeue.prototype.delete">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>delete
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (index) {
  var current, next;
  if (this.start+index &#x3e;= this.buffer.length) {
    current = this.start+index-this.buffer.length;
    next = this.start+index-this.buffer.length+1;
  }
  else {
    current = this.start+index;
    next = this.start+index+1;
  }

  for(var i=index; i&#x3c;(this.buffer.length-index); i++) {
    if (next === this.buffer.length) next = 0;
    if (current === this.buffer.length) current = 0;

    this.buffer[current] = this.buffer[next];
    current++;
    next++;
  }

  this.end--;
  if (this.end &#x3c; 0) this.end = this.buffer.length-1
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    connection.on(&#x27;error&#x27;, function(error) {
// We are going to close connection, but we don&#x27;t want another process to use it before
// So we remove it from the pool now (if it&#x27;s inside)
self._log(&#x27;Error emitted by a connection: &#x27;+JSON.stringify(error));
for(var i=0; i&#x3c;self.getAvailableLength(); i++) {
  if (self._pool.get(i) === this) {
    self._pool.<span class="apidocCodeKeywordSpan">delete</span>(i);
    self.emit(&#x27;available-size&#x27;, self._pool.getLength());
    self.emit(&#x27;available-size-diff&#x27;, -1);
    break;
  }
}
// We want to make sure that it&#x27;s not going to try to reconnect
clearTimeout(connection.timeout);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.get" id="apidoc.element.rethinkdbdash.dequeue.prototype.get">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>get
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index) {
  if (this.start+index &#x3e; this.buffer.length) {
    return this.buffer[this.start+index-this.buffer.length]
  }
  else {
    return this.buffer[this.start+index]
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Connections are managed by the driver with an efficient connection pool.
Once you have imported the driver, you can immediately run queries,
you don&#x27;t need to call `r.connect`, or pass a connection to `run`.

```js
var r = require(&#x27;rethinkdbdash&#x27;)();
r.table(&#x27;users&#x27;).<span class="apidocCodeKeywordSpan">get</span>(&#x27;orphee@gmail.com&#x27;).run().then(function(user
) {
  // ...
}).error(handleError)
```

- Cursors are coerced to arrays by default

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.getLength" id="apidoc.element.rethinkdbdash.dequeue.prototype.getLength">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>getLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLength = function () {
  if (this.start &#x3c;= this.end) {
    return this.end-this.start;
  }
  else {
    return this.buffer.length-(this.start-this.end);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- `draining`: when `drain` is called
- `queueing`: when a query is added/removed from the queue (queries waiting for a connection), the size of the queue is provided
- `size`: when the number of connections changes, the number of connections is provided
- `available-size`: when the number of available connections changes, the number of available connections is provided

You can get the number of connections (opened or being opened).
```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">getLength</span>();
```

You can also get the number of available connections (idle connections, without
a query running on it).

```js
r.getPoolMaster().getAvailableLength();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.pop" id="apidoc.element.rethinkdbdash.dequeue.prototype.pop">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>pop
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function (element) {
  //TODO: Decrease size when possible/needed? This may not be
  //something we really need/want
  // Return the element in this.end-1
  if (this.getLength() &#x3e; 0) {
    var pos = this.end-1;
    if (pos &#x3c; 0) pos = this.buffer.length-1;
    this.end = pos;
    var result = this.buffer[pos];
    this.buffer[pos] = undefined;
    return result;
  }
  else {
    return undefined
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Pool.prototype.getConnection = function() {
  var self = this;
  var p = new Promise(function(resolve, reject) {
if (self._draining === true) {
  return reject(new Err.ReqlDriverError(&#x27;The pool is being drained&#x27;).setOperational());
}

var connection = self._pool.<span class="apidocCodeKeywordSpan">pop</span>();
self.emit(&#x27;available-size&#x27;, self._pool.getLength());
self.emit(&#x27;available-size-diff&#x27;, -1);

if (connection) {
  clearTimeout(connection.timeout);
  resolve(connection);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.push" id="apidoc.element.rethinkdbdash.dequeue.prototype.push">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>push
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (element) {
  // push on this.end and then increase this.end
  // this.end should NEVER be equal to this.buffer.length
  this.buffer[this.end] = element;
  this.end++;
  if (this.end === this.buffer.length) this.end = 0;

  if (this.start === this.end) {
    // Resize
    var previousBuffer = this.buffer;

    this.buffer = new Array(previousBuffer.length*2);

    var i, k = 0;
    for(i=this.start; i&#x3c;previousBuffer.length; i++) {
      this.buffer[k++] = previousBuffer[i];
    }
    for(i=0; i&#x3c;this.start; i++) {
      this.buffer[k++] = previousBuffer[i];
    }
    this.start = 0;
    this.end = previousBuffer.length;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          }
        }
        return Promise.resolve(result).nodeify(callback);
      }
    }
    else {
      return new Promise(function(resolve, reject) {
        self._pendingPromises.<span class="apidocCodeKeywordSpan">push</span>({resolve: resolve, reject: reject});
      }).nodeify(callback);
    }
  }
}
Cursor.prototype.hasNext = function() {
  throw new Error(&#x27;The `hasNext` command has been removed in 1.13, please use `next`.&#x27;)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.shift" id="apidoc.element.rethinkdbdash.dequeue.prototype.shift">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>shift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function () {
  // Return the element in this.start

  if (this.getLength() &#x3e; 0) {
    var result = this.buffer[this.start];
    this.buffer[this.start] = undefined;
    this.start++;
    if (this.start === this.buffer.length) this.start = 0;
    return result;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (result instanceof Error) {
  return Promise.reject(result).nodeify(callback);
}
else {
  // This could be possible if we get back batch with just one document?
  if (self._data[0].length === self._index) {
    self._index = 0;
    self._data.<span class="apidocCodeKeywordSpan">shift</span>();
    if ((self._data.length === 1)
      &#x26;&#x26; (self._canFetch === true)
      &#x26;&#x26; (self._closed === false)
      &#x26;&#x26; (self._fetching === false)) {
        self._fetch();
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.toArray" id="apidoc.element.rethinkdbdash.dequeue.prototype.toArray">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>toArray
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function (index) {
  var result = [];
  for(var i=0; i&#x3c;this.getLength(); i++) {
    result.push(this.get(i));
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Cursors are coerced to arrays by default

```js
var r = require(&#x27;rethinkdbdash&#x27;)();
r.table(&#x27;data&#x27;).run().then(function(result) {
  assert(Array.isArray(result)) // true
  // With the official driver you need to call
  // result.<span class="apidocCodeKeywordSpan">toArray</span>().then(function(result2) {
  //   assert(Array.isArray(result2))
  // })
});
```

#### Drop in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.dequeue.prototype.unshift" id="apidoc.element.rethinkdbdash.dequeue.prototype.unshift">
        function <span class="apidocSignatureSpan">rethinkdbdash.dequeue.prototype.</span>unshift
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function (element) {
  // push on this.start-1 and then decrease this.start.
  // this.end should NEVER be equal to this.buffer.length

  var pos = this.start-1;
  if (pos &#x3c; 0) pos = this.buffer.length-1;

  this.buffer[pos] = element;
  this.start = pos;

  if (this.start === this.end) {
    //Resize
    var previousBuffer = this.buffer;

    this.buffer = new Array(previousBuffer.length*2);

    var i, k = 0;
    for(i=this.start; i&#x3c;previousBuffer.length; i++) {
      this.buffer[k++] = previousBuffer[i];
    }
    for(i=0; i&#x3c;this.start; i++) {
      this.buffer[k++] = previousBuffer[i];
    }
    this.start = 0;
    this.end = previousBuffer.length;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var result = {
str: &#x27;&#x27;,
car: &#x27;&#x27;
  }
  var backtrace, currentFrame, underline;

  if (helper.isPlainObject(term[2])) {
//if ((currentFrame != null) &#x26;&#x26; (frames != null)) frames.<span class="apidocCodeKeywordSpan">unshift</span>(currentFrame
);

//underline = Array.isArray(frames) &#x26;&#x26; (frames.length === 0);
var underline = false;
//if (Array.isArray(frames)) currentFrame = frames.shift();

// This works before there is no prefix term than can be called with no normal argument but with an optarg
if (Array.isArray(term[1]) &#x26;&#x26; (term[1].length &#x3e; 1)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.error" id="apidoc.module.rethinkdbdash.error">module rethinkdbdash.error</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.ReqlClientError" id="apidoc.element.rethinkdbdash.error.ReqlClientError">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlClientError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReqlClientError(message) {
  Error.captureStackTrace(this, ReqlClientError);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  else if (type === responseTypes.CLIENT_ERROR) {
self.emit(&#x27;release&#x27;);

if (typeof self.metadata[token].reject === &#x27;function&#x27;) {
  currentResolve = self.metadata[token].resolve;
  currentReject = self.metadata[token].reject;
  self.metadata[token].removeCallbacks();
  currentReject(new Err.<span class="apidocCodeKeywordSpan">ReqlClientError</span>(helper.makeAtom(response), self.metadata[token
].query, response));
  if (typeof self.metadata[token].endReject !== &#x27;function&#x27;) {
    // No pending STOP query, we can delete
    delete self.metadata[token]
  }
}
else if (typeof self.metadata[token].endResolve === &#x27;function&#x27;) {
  currentResolve = self.metadata[token].endResolve;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.ReqlCompileError" id="apidoc.element.rethinkdbdash.error.ReqlCompileError">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlCompileError
        <span class="apidocSignatureSpan">(message, query, frames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReqlCompileError(message, query, frames) {
  Error.captureStackTrace(this, ReqlCompileError);
  this.message = message;

  if ((query != null) &#x26;&#x26; (frames)) {
    if ((this.message.length &#x3e; 0) &#x26;&#x26; (this.message[this.message.length-1] === &#x27;.&#x27;)) {
      this.message = this.message.slice(0, this.message.length-1);
    }

    this.message += &#x27; in:\n&#x27;;

    frames = frames.b;
    if (frames) this.frames = frames.slice(0);
    //this.frames = JSON.stringify(frames, null, 2);

    var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});

    var queryLines = backtrace.str.split(&#x27;\n&#x27;);
    var carrotLines = backtrace.car.split(&#x27;\n&#x27;);

    for(var i=0; i&#x3c;queryLines.length; i++) {
      this.message += queryLines[i]+&#x27;\n&#x27;;
      if (carrotLines[i].match(/\^/)) {
        var pos = queryLines[i].match(/[^\s]/);
        if ((pos) &#x26;&#x26; (pos.index)) {
          this.message += space(pos.index)+carrotLines[i].slice(pos.index)+&#x27;\n&#x27;;
        }
        else {
          this.message += carrotLines[i]+&#x27;\n&#x27;;
        }
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var currentResolve, currentReject;
var datum;
var options;

if (type === responseTypes.COMPILE_ERROR) {
  self.emit(&#x27;release&#x27;);
  if (typeof self.metadata[token].reject === &#x27;function&#x27;) {
    self.metadata[token].reject(new Err.<span class="apidocCodeKeywordSpan">ReqlCompileError</span>(helper.makeAtom(response), self
.metadata[token].query, response));
  }

  delete self.metadata[token]
}
else if (type === responseTypes.CLIENT_ERROR) {
  self.emit(&#x27;release&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.ReqlDriverError" id="apidoc.element.rethinkdbdash.error.ReqlDriverError">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlDriverError
        <span class="apidocSignatureSpan">(message, query, secondMessage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReqlDriverError(message, query, secondMessage) {
  Error.captureStackTrace(this, ReqlDriverError);
  this.message = this.msg = message;

  if ((Array.isArray(query) &#x26;&#x26; (query.length &#x3e; 0)) || (!Array.isArray(query) &#x26;&#x26; query != null)) {
    if ((this.message.length &#x3e; 0) &#x26;&#x26; (this.message[this.message.length-1] === &#x27;.&#x27;)) {
      this.message = this.message.slice(0, this.message.length-1);
    }

    this.message += &#x27; after:\n&#x27;;

    var backtrace = generateBacktrace(query, 0, null, [], {indent: 0, extra: 0});

    this.message += backtrace.str;
  }
  else {
    if (this.message[this.message.length-1] !== &#x27;?&#x27;) this.message += &#x27;.&#x27;;
  }
  if (secondMessage) this.message += &#x27;\n&#x27;+secondMessage;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Set default options - We have to save them in case the user tries to reconnect
if (!helper.isPlainObject(options)) options = {};
this.host = options.host || r._host;
this.port = options.port || r._port;
if (options.authKey != null) {
  if (options.user != null || options.password != null) {
    throw new Err.<span class="apidocCodeKeywordSpan">ReqlDriverError</span>(&#x27;Cannot use both authKey and password&#x27;);
  }
  this.user = r._user;
  this.password = options.authKey;
} else {
  if (options.user === undefined) {
    this.user = r._user;
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.ReqlRuntimeError" id="apidoc.element.rethinkdbdash.error.ReqlRuntimeError">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlRuntimeError
        <span class="apidocSignatureSpan">(message, query, frames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReqlRuntimeError(message, query, frames) {
  Error.captureStackTrace(this, ReqlRuntimeError);
  this.message = this.msg = message;

  if ((query != null) &#x26;&#x26; (frames)) {
    if ((this.message.length &#x3e; 0) &#x26;&#x26; (this.message[this.message.length-1] === &#x27;.&#x27;)) {
      this.message = this.message.slice(0, this.message.length-1);
    }

    this.message += &#x27; in:\n&#x27;;

    frames = frames.b;
    if (frames) this.frames = frames.slice(0);
    //this.frames = JSON.stringify(frames, null, 2);

    var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});

    var queryLines = backtrace.str.split(&#x27;\n&#x27;);
    var carrotLines = backtrace.car.split(&#x27;\n&#x27;);

    for(var i=0; i&#x3c;queryLines.length; i++) {
      this.message += queryLines[i]+&#x27;\n&#x27;;
      if (carrotLines[i].match(/\^/)) {
        var pos = queryLines[i].match(/[^\s]/);
        if ((pos) &#x26;&#x26; (pos.index)) {
          this.message += space(pos.index)+carrotLines[i].slice(pos.index)+&#x27;\n&#x27;;
        }
        else {
          this.message += carrotLines[i]+&#x27;\n&#x27;;
        }
      }
    }
  }
  //this.query = JSON.stringify(query, null, 2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  else if (type === responseTypes.RUNTIME_ERROR) {
var errorValue = helper.makeAtom(response);
var error;
// We don&#x27;t want to release a connection if we just pinged it.
if (self.pendingPing === false || (errorValue !== PING_VALUE)) {
  self.emit(&#x27;release&#x27;);
  error = new Err.<span class="apidocCodeKeywordSpan">ReqlRuntimeError</span>(errorValue, self.metadata[token].query, response);
} else {
  error = new Err.ReqlRuntimeError(errorValue);
}

if (typeof self.metadata[token].reject === &#x27;function&#x27;) {
  currentResolve = self.metadata[token].resolve;
  currentReject = self.metadata[token].reject;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.ReqlServerError" id="apidoc.element.rethinkdbdash.error.ReqlServerError">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>ReqlServerError
        <span class="apidocSignatureSpan">(message, query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReqlServerError(message, query) {
  Error.captureStackTrace(this, ReqlServerError);
  this.message = this.msg = message;

  if ((Array.isArray(query) &#x26;&#x26; (query.length &#x3e; 0)) || (!Array.isArray(query) &#x26;&#x26; query != null)) {
    if ((this.message.length &#x3e; 0) &#x26;&#x26; (this.message[this.message.length-1] === &#x27;.&#x27;)) {
      this.message = this.message.slice(0, this.message.length-1);
    }

    this.message += &#x27; for:\n&#x27;;

    var backtrace = generateBacktrace(query, 0, null, [], {indent: 0, extra: 0});

    this.message += backtrace.str;
  }
  else {
    if (this.message[this.message.length-1] !== &#x27;?&#x27;) this.message += &#x27;.&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Connection.prototype._isOpen = function() {
return this.open;
}

Connection.prototype._flush = function() {
helper.loopKeys(this.metadata, function(metadata, key) {
  if (typeof metadata[key].reject === &#x27;function&#x27;) {
    metadata[key].reject(new Err.<span class="apidocCodeKeywordSpan">ReqlServerError</span>(
          &#x27;The connection was closed before the query could be completed.&#x27;,
          metadata[key].query));
  }
  if (typeof metadata[key].endReject === &#x27;function&#x27;) {
    metadata[key].endReject(new Err.ReqlServerError(
          &#x27;The connection was closed before the query could be completed.&#x27;,
          metadata[key].query));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.generateBacktrace" id="apidoc.element.rethinkdbdash.error.generateBacktrace">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>generateBacktrace
        <span class="apidocSignatureSpan">(term, index, father, frames, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateBacktrace(term, index, father, frames, options) {
  var result = {
    str: &#x27;&#x27;,
    car: &#x27;&#x27;
  }
  var backtrace, currentFrame, underline;

  // frames = null -&#x3e; do not underline
  // frames = [] -&#x3e; underline

  if (Array.isArray(term)) {
    if (term.length === 0) {
      var underline = Array.isArray(frames) &#x26;&#x26; (frames.length === 0);
      carify(result, &#x27;undefined&#x27;, underline);
    }
    else if (specialType[term[0]]) {
      backtrace = specialType[term[0]](term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
    else if (nonPrefix[term[0]]) {
      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
    else { // normal type -- this.&#x3c;method&#x3e;( this.args... )
      backtrace = generateNormalBacktrace(term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
  }
  else if (term !== undefined) {
    backtrace = specialType[termTypes.DATUM](term, index, father, frames, options);

    result.str = backtrace.str;
    result.car = backtrace.car;
  }
  else {
    //throw new Error(&#x27;The driver should never enter this condition. Please report the query to the developers -- End 2&#x27;)
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return this.run().finally(handler);
}
Term.prototype.delay = function(msecs) {
return this.run().delay(msecs);
}

Term.prototype.toString = function() {
return Error.<span class="apidocCodeKeywordSpan">generateBacktrace</span>(this._query, 0, null, [], {indent: 0, extra: 0}).str;
}

Term.prototype._wrap = function() {
var self = this;
if (helper.hasImplicit(this._query)) {
  if (this._query[0] === termTypes.ARGS) {
    throw new Error.ReqlDriverError(&#x27;Implicit variable `r.row` cannot be used inside `r.args`&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.error.setOperational" id="apidoc.element.rethinkdbdash.error.setOperational">
        function <span class="apidocSignatureSpan">rethinkdbdash.error.</span>setOperational
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOperational = function (error) {
  error[IS_OPERATIONAL] = true;
  return error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

self.connection.setKeepAlive(true);

self.timeoutOpen = setTimeout(function() {
  self.connection.end(); // Send a FIN packet
  reject(new Err.ReqlDriverError(&#x27;Failed to connect to &#x27;+self.host+&#x27;:&#x27;+self.port+&#x27; in less than &#x27;+
self.timeoutConnect+&#x27;s&#x27;).<span class="apidocCodeKeywordSpan">setOperational</span>());
}, self.timeoutConnect*1000);

self.connection.on(&#x27;end&#x27;, function() {
  self.open = false;
  self.emit(&#x27;end&#x27;);
  // We got a FIN packet, so we&#x27;ll just flush
  self._flush();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.helper" id="apidoc.module.rethinkdbdash.helper">module rethinkdbdash.helper</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.changeProto" id="apidoc.element.rethinkdbdash.helper.changeProto">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>changeProto
        <span class="apidocSignatureSpan">(object, other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function changeProto(object, other) {
  object.__proto__ = other.__proto__;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var term = function(field) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, &#x27;(...)&#x27;, self);
  }
  return term.bracket(field);
}
helper.<span class="apidocCodeKeywordSpan">changeProto</span>(term, self);

if (value === undefined) {
  term._query = [];
}
else {
  term._query = value;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.compareDigest" id="apidoc.element.rethinkdbdash.helper.compareDigest">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>compareDigest
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareDigest(a, b) {
  var left = undefined
  var right = b
  var result = undefined
  if (a.length === b.length) {
    left = a
    result = 0
  } else {
    left = b
    result = 1
  }
  var len = Math.min(a.length, b.length);
  for(var i=0; i&#x3c;len; i++) {
    result |= a[i] ^b[i]
  }
  return result === 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Connection.prototype._compareDigest = function(messageServer, resolve, reject) {
var self = this;
var firstEquals = messageServer.authentication.indexOf(&#x27;=&#x27;)
var serverSignatureValue = messageServer.authentication.slice(firstEquals+1)

if (!helper.<span class="apidocCodeKeywordSpan">compareDigest</span>(serverSignatureValue, self.serverSignature.toString(&#x22;base64
&#x22;))) {
  reject(new Err.ReqlDriverError(&#x27;Invalid server signature&#x27;).setOperational());
}

self.state = 4
self.connection.removeAllListeners(&#x27;error&#x27;);
self.open = true;
self.connection.on(&#x27;error&#x27;, function(e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.createLogger" id="apidoc.element.rethinkdbdash.helper.createLogger">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>createLogger
        <span class="apidocSignatureSpan">(poolMaster, silent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLogger(poolMaster, silent) {
  return function(message) {
    if (silent !== true) {
      console.error(message);
    }
    poolMaster.emit(&#x27;log&#x27;, message);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self._index = 0; // next pool to used
self._indexUnknown =  0 // next unknown pool to used
self._discovery = (typeof options.discovery === &#x27;boolean&#x27;) ? options.discovery: false; // Whether the pool master is in
 discovery mode or not
//self._refresh = (typeof options.refresh === &#x27;number&#x27;) ? options.refresh: 1000*60*60; // Refresh rate for the list of
 servers
self._options = options;
self._options.buffer = options.buffer || 50;
self._options.max = options.max || 1000;
self._log = helper.<span class="apidocCodeKeywordSpan">createLogger</span>(self, options.silent || false);
self._draining = false;
self._numConnections = 0;
self._numAvailableConnections = 0;
self._hasPrintWarningLocalhost = false;
self._feed = null;
self._consecutiveFails = -1;
self._timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.getCanonicalAddress" id="apidoc.element.rethinkdbdash.helper.getCanonicalAddress">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>getCanonicalAddress
        <span class="apidocSignatureSpan">(addresses)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCanonicalAddress(addresses) {
  // We suppose that the addresses are all valid, and therefore use loose regex
  for(var i=0; i&#x3c;addresses.length; i++) {
    var addresse = addresses[i];
    if ((/^127(\.\d{1,3}){3}$/.test(addresse.host)) || (/0?:?0?:?0?:?0?:?0?:?0?:0?:1/.test(addresse.host))) {
      addresse.value = 0;
    }
    else if ((net.isIPv6(addresse.host)) &#x26;&#x26; (/^[fF]|[eE]80:.*\:.*\:/.test(addresse.host))) {
      addresse.value = 1;
    }
    else if (/^169\.254\.\d{1,3}\.\d{1,3}$/.test(addresse.host)) {
      addresse.value = 2;
    }
    else if (/^192\.168\.\d{1,3}\.\d{1,3}$/.test(addresse.host)) {
      addresse.value = 3;
    }
    else if (/^172\.(1\d|2\d|30|31)\.\d{1,3}\.\d{1,3}$/.test(addresse.host)) {
      addresse.value = 4;
    }
    else if (/^10(\.\d{1,3}){3}$/.test(addresse.host)) {
      addresse.value = 5;
    }
    else if ((net.isIPv6(addresse.host)) &#x26;&#x26; (/^[fF]|[cCdD].*\:.*\:/.test(&#x27;addresse.host&#x27;))) {
      addresse.value = 6;
    }
    else {
      addresse.value = 7;
    }
  }
  var result = addresses[0];
  var max = addresses[0].value;
  for(var i=0; i&#x3c;addresses.length; i++) {
    if (addresses[i].value &#x3e; max) {
      result = addresses[i];
      max = addresses[i].value;
    }
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) &#x26;&#x26;
      helper.localhostAliases.hasOwnProperty(pool.options.connection.host))) &#x26;&#x26;
      (server.network.reql_port === pool.options.connection.port)) {

      self._pools[server.id] = self._pools[UNKNOWN_POOLS].splice(j, 1)[0];
      // We may assign the wrong pool to this server if it&#x27;s maching on localhost
      if (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host)) {
        self._pools[server.id].options.connection.host = helper.<span class="apidocCodeKeywordSpan">getCanonicalAddress</span>(server
.network.canonical_addresses).host;
        self._pools[server.id].drainLocalhost();
      }
      found = true;
      break;
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.hasImplicit" id="apidoc.element.rethinkdbdash.helper.hasImplicit">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>hasImplicit
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasImplicit(arg) {
  if (Array.isArray(arg)) {
    if (arg[0] === termTypes.IMPLICIT_VAR) return true;

    if (Array.isArray(arg[1])) {
      for(var i=0; i&#x3c;arg[1].length; i++) {
        if (hasImplicit(arg[1][i])) return true;
      }
    }
    if (isPlainObject(arg[2])) {
      for(var key in arg[2]) {
        if (hasImplicit(arg[2][key])) return true;
      }
    }
  }
  else if (isPlainObject(arg)) {
    for(var key in arg) {
      if (hasImplicit(arg[key])) return true;
    }
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  car: &#x27;&#x27;
};
var backtrace, underline, currentFrame;

var underline = Array.isArray(frames) &#x26;&#x26; (frames.length === 0);
if (Array.isArray(frames)) currentFrame = frames.shift();

if ((term[1][0][1].length === 1) &#x26;&#x26; (helper.<span class="apidocCodeKeywordSpan">hasImplicit</span>(term[1][1]))) {
  if ((currentFrame != null) &#x26;&#x26; (currentFrame === 1)) {
    backtrace = generateBacktrace(term[1][1], 1, term, frames, options);
  }
  else {
    backtrace = generateBacktrace(term[1][1], 1, term, null, options);
  }
  result.str = backtrace.str;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.isPlainObject" id="apidoc.element.rethinkdbdash.helper.isPlainObject">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>isPlainObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === &#x27;[object Object]&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function Connection(r, options, resolve, reject) {
var self = this;
this.r = r;
this.state = 0; // Track the progress of the handshake. -1 will be used for an error state.

// Set default options - We have to save them in case the user tries to reconnect
if (!helper.<span class="apidocCodeKeywordSpan">isPlainObject</span>(options)) options = {};
this.host = options.host || r._host;
this.port = options.port || r._port;
if (options.authKey != null) {
  if (options.user != null || options.password != null) {
    throw new Err.ReqlDriverError(&#x27;Cannot use both authKey and password&#x27;);
  }
  this.user = r._user;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.loopKeys" id="apidoc.element.rethinkdbdash.helper.loopKeys">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>loopKeys
        <span class="apidocSignatureSpan">(obj, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loopKeys(obj, fn) {
  var keys = Object.keys(obj);
  var result;
  var keysLength = keys.length;
  for(var i=0; i&#x3c;keysLength; i++) {
    result = fn(obj, keys[i]);
    if (result === false) return;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var tlsOptions = options.ssl || false;
  if (tlsOptions === false) {
    self.connection = net.connect(connectionArgs);
  } else {
    if (helper.isPlainObject(tlsOptions)) {
      // Copy the TLS options in connectionArgs
      helper.<span class="apidocCodeKeywordSpan">loopKeys</span>(tlsOptions, function(tlsOptions, key) {
        connectionArgs[key] = tlsOptions[key];
      });
    }
    self.connection = tls.connect(connectionArgs);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.makeAtom" id="apidoc.element.rethinkdbdash.helper.makeAtom">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>makeAtom
        <span class="apidocSignatureSpan">(response, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function makeAtom(response, options) {
  options = options || {};
  return recursivelyConvertPseudotype(response.r[0], options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var currentResolve, currentReject;
var datum;
var options;

if (type === responseTypes.COMPILE_ERROR) {
  self.emit(&#x27;release&#x27;);
  if (typeof self.metadata[token].reject === &#x27;function&#x27;) {
    self.metadata[token].reject(new Err.ReqlCompileError(helper.<span class="apidocCodeKeywordSpan">makeAtom</span>(response), self
.metadata[token].query, response));
  }

  delete self.metadata[token]
}
else if (type === responseTypes.CLIENT_ERROR) {
  self.emit(&#x27;release&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.makeSequence" id="apidoc.element.rethinkdbdash.helper.makeSequence">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>makeSequence
        <span class="apidocSignatureSpan">(response, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function makeSequence(response, options) {
  options = options || {};
  return recursivelyConvertPseudotype(response.r, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Cursor.prototype._push = function(data) {
  var couldfetch = this._canFetch;
  if (data.done) this._done();
  var response = data.response;
  this._fetching = false;
  // If the cursor was closed, we ignore all following response
  if ((response.r.length &#x3e; 0) &#x26;&#x26; (couldfetch === true)) {
    this._data.push(helper.<span class="apidocCodeKeywordSpan">makeSequence</span>(response, this.options));
  }
  // this._fetching = false
  if ((this._closed === false) &#x26;&#x26; (this._canFetch) &#x26;&#x26; (this._data.length &#x3c;= 1)) this._fetch();
  this._flush();
}
// Try to solve as many pending promises as possible
Cursor.prototype._flush = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.splitCommaEqual" id="apidoc.element.rethinkdbdash.helper.splitCommaEqual">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>splitCommaEqual
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function splitCommaEqual(message) {
  var result = {};
  var messageParts = message.split(&#x27;,&#x27;);
  for(var i=0; i&#x3c;messageParts.length; i++) {
    var equalPosition = messageParts[i].indexOf(&#x22;=&#x22;)
    result[messageParts[i].slice(0, equalPosition)] = messageParts[i].slice(equalPosition+1);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  reject(new Err.ReqlDriverError(&#x27;Unsupported protocol version: &#x27;+PROTOCOL_VERSION+&#x27;, expected between &#x27;+minVersion
+&#x27; and &#x27;+ maxVersion).setOperational());
}
this.state = 1;
};

Connection.prototype._computeSaltedPassword = function(messageServer, reject) {
var self = this;
var authentication = helper.<span class="apidocCodeKeywordSpan">splitCommaEqual</span>(messageServer.authentication);

var randomNonce = authentication.r
var salt = new Buffer(authentication.s, &#x27;base64&#x27;)
var iterations = parseInt(authentication.i)

if (randomNonce.substr(0, self.randomString.length) !== self.randomString) {
  self._abort();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.toArray" id="apidoc.element.rethinkdbdash.helper.toArray">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>toArray
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toArray(args) {
  return Array.prototype.slice.call(args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Cursors are coerced to arrays by default

```js
var r = require(&#x27;rethinkdbdash&#x27;)();
r.table(&#x27;data&#x27;).run().then(function(result) {
  assert(Array.isArray(result)) // true
  // With the official driver you need to call
  // result.<span class="apidocCodeKeywordSpan">toArray</span>().then(function(result2) {
  //   assert(Array.isArray(result2))
  // })
});
```

#### Drop in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.tryCatch" id="apidoc.element.rethinkdbdash.helper.tryCatch">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>tryCatch
        <span class="apidocSignatureSpan">(toTry, handleError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryCatch(toTry, handleError) {
  try{
  toTry()
  }
  catch(err) {
  handleError(err)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.randomString = new Buffer(crypto.randomBytes(18)).toString(&#x27;base64&#x27;)
var authBuffer = new Buffer(JSON.stringify({
  protocol_version: PROTOCOL_VERSION,
  authentication_method: AUTHENTIFICATION_METHOD,
  authentication: &#x22;n,,n=&#x22; + self.user + &#x22;,r=&#x22; + self.randomString
}));

helper.<span class="apidocCodeKeywordSpan">tryCatch</span>(function() {
  self.connection.write(Buffer.concat([versionBuffer, authBuffer, NULL_BUFFER]));
}, function(err) {
  // The TCP connection is open, but the ReQL connection wasn&#x27;t established.
  // We can just abort the whole thing
  self.open = false;
  reject(new Err.ReqlDriverError(&#x27;Failed to perform handshake with &#x27;+self.host+&#x27;:&#x27;+self.port).setOperational
());
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.helper.xorBuffer" id="apidoc.element.rethinkdbdash.helper.xorBuffer">
        function <span class="apidocSignatureSpan">rethinkdbdash.helper.</span>xorBuffer
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xorBuffer(a, b) {
  var result = [];
  var len = Math.min(a.length, b.length)
  for(var i=0; i&#x3c;len; i++) {
    result.push(a[i] ^ b[i]);
  }
  return new Buffer(result);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var authMessage =
    &#x22;n=&#x22; + this.user + &#x22;,r=&#x22; + this.randomString + &#x22;,&#x22; +
    authentication + &#x22;,&#x22; +
    clientFinalMessageWithoutProof

var clientSignature = crypto.createHmac(&#x22;sha256&#x22;, storedKey).update(authMessage).digest()
var clientProof = helper.<span class="apidocCodeKeywordSpan">xorBuffer</span>(clientKey, clientSignature)

var serverKey = crypto.createHmac(&#x22;sha256&#x22;, saltedPassword).update(&#x22;Server Key&#x22;).digest()
this.serverSignature = crypto.createHmac(&#x22;sha256&#x22;, serverKey).update(authMessage).digest()

this.state = 2
var message = JSON.stringify({
  authentication: clientFinalMessageWithoutProof + &#x22;,p=&#x22; + clientProof.toString(&#x22;base64&#x22;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.metadata" id="apidoc.module.rethinkdbdash.metadata">module rethinkdbdash.metadata</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata.metadata" id="apidoc.element.rethinkdbdash.metadata.metadata">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>metadata
        <span class="apidocSignatureSpan">(resolve, reject, query, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Metadata(resolve, reject, query, options) {
  this.resolve = resolve;
  this.reject = reject;
  this.query = query; // The query in case we have to build a backtrace
  this.options = options || {};
  this.cursor = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.metadata.prototype" id="apidoc.module.rethinkdbdash.metadata.prototype">module rethinkdbdash.metadata.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata.prototype.removeCallbacks" id="apidoc.element.rethinkdbdash.metadata.prototype.removeCallbacks">
        function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>removeCallbacks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeCallbacks = function () {
  this.resolve = null;
  this.reject = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  else if (type === responseTypes.CLIENT_ERROR) {
self.emit(&#x27;release&#x27;);

if (typeof self.metadata[token].reject === &#x27;function&#x27;) {
  currentResolve = self.metadata[token].resolve;
  currentReject = self.metadata[token].reject;
  self.metadata[token].<span class="apidocCodeKeywordSpan">removeCallbacks</span>();
  currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));
  if (typeof self.metadata[token].endReject !== &#x27;function&#x27;) {
    // No pending STOP query, we can delete
    delete self.metadata[token]
  }
}
else if (typeof self.metadata[token].endResolve === &#x27;function&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata.prototype.removeEndCallbacks" id="apidoc.element.rethinkdbdash.metadata.prototype.removeEndCallbacks">
        function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>removeEndCallbacks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeEndCallbacks = function () {
  this.endResolve = null;
  this.endReject = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // No pending STOP query, we can delete
    delete self.metadata[token]
  }
}
else if (typeof self.metadata[token].endResolve === &#x27;function&#x27;) {
  currentResolve = self.metadata[token].endResolve;
  currentReject = self.metadata[token].endReject;
  self.metadata[token].<span class="apidocCodeKeywordSpan">removeEndCallbacks</span>();
  currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));
  delete self.metadata[token]
}
else if (token === -1) { // This should not happen now since 1.13 took the token out of the query
  var error = new Err.ReqlClientError(helper.makeAtom(response)+&#x27;\nClosing all outstanding queries...&#x27;);
  self.emit(&#x27;error&#x27;, error);
  // We don&#x27;t want a function to yield forever, so we just reject everything
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata.prototype.setCallbacks" id="apidoc.element.rethinkdbdash.metadata.prototype.setCallbacks">
        function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>setCallbacks
        <span class="apidocSignatureSpan">(resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setCallbacks = function (resolve, reject) {
  this.resolve = resolve;
  this.reject = reject;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!self.metadata[token]) {
    self.metadata[token] = new Metadata(resolve, reject, originalQuery, options);
  }
  else if (end === true) {
    self.metadata[token].setEnd(resolve, reject);
  }
  else {
    self.metadata[token].<span class="apidocCodeKeywordSpan">setCallbacks</span>(resolve, reject);
  }
}
else {
  if (typeof resolve === &#x27;function&#x27;) resolve();
  this.emit(&#x27;release&#x27;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata.prototype.setCursor" id="apidoc.element.rethinkdbdash.metadata.prototype.setCursor">
        function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>setCursor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setCursor = function () {
  this.cursor = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.metadata.prototype.setEnd" id="apidoc.element.rethinkdbdash.metadata.prototype.setEnd">
        function <span class="apidocSignatureSpan">rethinkdbdash.metadata.prototype.</span>setEnd
        <span class="apidocSignatureSpan">(resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEnd = function (resolve, reject) {
  this.endResolve = resolve;
  this.endReject = reject;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// noreply instead of noReply because the otpions are translated for the server
if ((!helper.isPlainObject(options)) || (options.noreply != true)) {
  if (!self.metadata[token]) {
    self.metadata[token] = new Metadata(resolve, reject, originalQuery, options);
  }
  else if (end === true) {
    self.metadata[token].<span class="apidocCodeKeywordSpan">setEnd</span>(resolve, reject);
  }
  else {
    self.metadata[token].setCallbacks(resolve, reject);
  }
}
else {
  if (typeof resolve === &#x27;function&#x27;) resolve();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.pool" id="apidoc.module.rethinkdbdash.pool">module rethinkdbdash.pool</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.pool" id="apidoc.element.rethinkdbdash.pool.pool">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool
        <span class="apidocSignatureSpan">(r, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pool(r, options) {
  this._r = r;

  if (!helper.isPlainObject(options)) options = {};
  this.options = {};
  this.options.max = options.max || 1000; // 4000 is about the maximum the kernel can take
  var buffer = (typeof options.buffer === &#x27;number&#x27;) ? options.buffer : 50;
  this.options.buffer = (buffer &#x3c; this.options.max) ? buffer : this.options.max;
  this.options.timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed
?
  this.options.timeoutGb = options.timeoutGb || 60*60*1000; // Default timeout for TCP connection is 2 hours on Linux, we time out
 after one hour.
  this.options.maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError

  this.options.silent = options.silent || false;

  this.options.connection = {
    host: options.host || this._r._host,
    port: options.port || this._r._port,
    db: options.db || this._r._db,
    timeout: options.timeout || this._r._timeoutConnect,
    authKey: options.authKey,
    user: options.user,
    password: options.password,
    cursor: options.cursor || false,
    stream: options.stream || false,
    ssl: options.ssl || false,
    pingInterval: options.pingInterval || this._r._pingInterval
  }
  this._log = options._log;

  this._pool = new Dequeue(this.options.buffer+1);
  this._draining = false;
  this._drainingHandlers = null; // Store the resolve/reject methods once draining is called
  this._localhostToDrain = 0; // number of connections to &#x22;localhost&#x22; to remove
  this._connectionToReplace = 0; // number of connections to &#x22;localhost&#x22; to remove

  this._numConnections = 0;
  this._openingConnections = 0; // Number of connections being opened
  this._consecutiveFails = 0;   // In slow growth, the number of consecutive failures to open a connection
  this._slowGrowth = false;     // Opening one connection at a time
  this._slowlyGrowing = false;  // The next connection to be returned is one opened in slowGrowth mode
  this._extraConnections = 0; // Number of extra connections being opened that we should eventually close

  this._empty = true;

  var self = this;
  // So we can let the pool master bind listeners
  setTimeout(function() {
    if (self._draining === false) {
      for(var i=0; i&#x3c;self.options.buffer; i++) {
        if (self.getLength() &#x3c; self.options.max) {
          self.createConnection();
        }
      }
    }
  }, 0);
  this.id = Math.floor(Math.random()*100000);
  this._log(&#x27;Creating a pool connected to &#x27;+this.getAddress());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.super_" id="apidoc.element.rethinkdbdash.pool.super_">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.pool.prototype" id="apidoc.module.rethinkdbdash.pool.prototype">module rethinkdbdash.pool.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype._aggressivelyExpandBuffer" id="apidoc.element.rethinkdbdash.pool.prototype._aggressivelyExpandBuffer">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_aggressivelyExpandBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_aggressivelyExpandBuffer = function () {
  for(var i=0; i&#x3c;this.options.buffer; i++) {
    this._expandBuffer();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
// Need another flag
else if ((self._slowlyGrowing === true) &#x26;&#x26; (self._slowGrowth === true) &#x26;&#x26; (self._consecutiveFails &#x3e; 0)) {
  self._log(&#x27;Exiting slow growth mode&#x27;);
  self._consecutiveFails = 0;
  self._slowGrowth = false;
  self._slowlyGrowing = false;
  self.<span class="apidocCodeKeywordSpan">_aggressivelyExpandBuffer</span>();
}



connection.on(&#x27;error&#x27;, function(error) {
  // We are going to close connection, but we don&#x27;t want another process to use it before
  // So we remove it from the pool now (if it&#x27;s inside)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype._decreaseNumConnections" id="apidoc.element.rethinkdbdash.pool.prototype._decreaseNumConnections">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_decreaseNumConnections
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_decreaseNumConnections = function () {
  this._numConnections--;
  this.emit(&#x27;size&#x27;, this._numConnections)
  this.emit(&#x27;size-diff&#x27;, -1)
  if ((this._drainingHandlers !== null) &#x26;&#x26; (this._numConnections === 0)) {
    this._drainingHandlers.resolve();
  }
  // We do not check for this._empty === false because we want to emit empty if the pool
  // tries to connect to an unavailable server (such that the master can remove it from the
  // healthy pool
  if (this._numConnections === 0) {
    this._empty = true;
    this.emit(&#x27;empty&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      self.emit(&#x27;available-size&#x27;, self._pool.getLength());
      self.emit(&#x27;available-size-diff&#x27;, -1);
      break;
    }
  }

  clearTimeout(connection.timeout);
  self.<span class="apidocCodeKeywordSpan">_decreaseNumConnections</span>();
  self._expandBuffer();
});
connection.on(&#x27;timeout&#x27;, function() {
  for(var i=0; i&#x3c;self.getAvailableLength(); i++) {
    if (self._pool.get(i) === this) {
      self._pool.delete(i);
      self.emit(&#x27;available-size&#x27;, self._pool.getLength());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype._expandBuffer" id="apidoc.element.rethinkdbdash.pool.prototype._expandBuffer">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_expandBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_expandBuffer = function () {
  if ((this._draining === false) &#x26;&#x26;
      (this._pool.getLength() &#x3c; this.options.buffer+this._localhostToDrain) &#x26;&#x26;
      (this._numConnections &#x3c; this.options.max+this._localhostToDrain)) {
    this.createConnection();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if ((self._numConnections === 0) &#x26;&#x26; (self._slowGrowth === true)) {
        // If the server is down we do not want to buffer the queries
        return reject(new Err.ReqlDriverError(&#x27;The pool does not have any opened connections and failed to open a new one&#
x27;).setOperational());
      }
    }

    if (self._slowGrowth === false) {
      self.<span class="apidocCodeKeywordSpan">_expandBuffer</span>();
    }

  });
  return p;
};

Pool.prototype._decreaseNumConnections = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype._increaseNumConnections" id="apidoc.element.rethinkdbdash.pool.prototype._increaseNumConnections">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>_increaseNumConnections
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_increaseNumConnections = function () {
  this._numConnections++;
  this.emit(&#x27;size&#x27;, this._numConnections)
  this.emit(&#x27;size-diff&#x27;, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
}
};

Pool.prototype.createConnection = function() {
var self = this;
self.<span class="apidocCodeKeywordSpan">_increaseNumConnections</span>();
self._openingConnections++;

self.emit(&#x27;creating-connection&#x27;, self);
if (self._draining === true) {
  return; // Do not create a new connection if we are draining the pool.
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.createConnection" id="apidoc.element.rethinkdbdash.pool.prototype.createConnection">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>createConnection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createConnection = function () {
  var self = this;
  self._increaseNumConnections();
  self._openingConnections++;

  self.emit(&#x27;creating-connection&#x27;, self);
  if (self._draining === true) {
    return; // Do not create a new connection if we are draining the pool.
  }

  return self._r.connect(self.options.connection).then(function(connection) {
    self.emit(&#x27;created-connection&#x27;, self);

    self._openingConnections--;

    if ((self._slowlyGrowing === false) &#x26;&#x26; (self._slowGrowth === true) &#x26;&#x26; (self._openingConnections === 0)) {
      self._consecutiveFails++;
      self._slowlyGrowing = true;
      self.timeoutReconnect = setTimeout(function() {
        self.createConnection();
        //self._expandBuffer();
      }, (1&#x3c;&#x3c;Math.min(self.options.maxExponent, self._consecutiveFails))*self.options.timeoutError);
    }
    // Need another flag
    else if ((self._slowlyGrowing === true) &#x26;&#x26; (self._slowGrowth === true) &#x26;&#x26; (self._consecutiveFails &#x3e; 0)) {
      self._log(&#x27;Exiting slow growth mode&#x27;);
      self._consecutiveFails = 0;
      self._slowGrowth = false;
      self._slowlyGrowing = false;
      self._aggressivelyExpandBuffer();
    }



    connection.on(&#x27;error&#x27;, function(error) {
      // We are going to close connection, but we don&#x27;t want another process to use it before
      // So we remove it from the pool now (if it&#x27;s inside)
      self._log(&#x27;Error emitted by a connection: &#x27;+JSON.stringify(error));
      for(var i=0; i&#x3c;self.getAvailableLength(); i++) {
        if (self._pool.get(i) === this) {
          self._pool.delete(i);
          self.emit(&#x27;available-size&#x27;, self._pool.getLength());
          self.emit(&#x27;available-size-diff&#x27;, -1);
          break;
        }
      }
      // We want to make sure that it&#x27;s not going to try to reconnect
      clearTimeout(connection.timeout);

      // Not sure what happened here, so let&#x27;s be safe and close this connection.
      connection.close().then(function() {
        return self._expandBuffer();
      }).error(function(e) {
        // We failed to close this connection, but we removed it from the pool... so err, let&#x27;s just ignore that.
        self._expandBuffer();
      });
    });
    connection.on(&#x27;end&#x27;, function(e) {
      // The connection was closed by the server, let&#x27;s clean...
      for(var i=0; i&#x3c;self.getAvailableLength(); i++) {
        if (self._pool.get(i) === this) {
          self._pool.delete(i);
          self.emit(&#x27;available-size&#x27;, self._pool.getLength());
          self.emit(&#x27;available-size-diff&#x27;, -1);
          break;
        }
      }

      clearTimeout(connection.timeout);
      self._decreaseNumConnections();
      self._expandBuffer();
    });
    connection.on(&#x27;timeout&#x27;, function() {
      for(var i=0; i&#x3c;self.getAvailableLength(); i++) {
        if (self._pool.get(i) === this) {
          self._pool.delete(i);
          self.emit(&#x27;available-size&#x27;, self._pool.getLength());
          self.emit(&#x27;available-size-diff&#x27;, -1);
          break;
        }
      }

      clearTimeout(connection.timeout);
      self._decreaseNumConnections();
      self._expandBuffer();
    });
    connection.on(&#x27;release&#x27;, function() {
      if (this._isOpen()) self.putConnection(this);
    });
    self.putConnection(connection);
    return null;
  }).error(function(error) {
    // We failed to create a connection, we are now going to create connections one by one
    self._openingConnections--;
    self._decreaseNumConnections();

    self._slowGrowth = true;
    if (self._slowlyGrowing === false) {
      self._log(&#x27;Entering slow growth mode&#x27;);
    }
    self._slowlyGrowing = true;

    // Log an error
    self._log(&#x27;Fail to create a new connection for the connection pool. Error:&#x27;+JSON.stringify(error));

    if (self._openingConnections === 0) {
      self._consecutiveFails++;
      self.timeoutReconnect = setTimeout(function() {
        //self._expandBuffer();
        self.createConnection();
      }, (1&#x3c;&#x3c;Math.min(self.options.maxExponent, self._consecutiveFails))*self.options.timeoutError);
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var self = this;
  // So we can let the pool master bind listeners
  setTimeout(function() {
    if (self._draining === false) {
      for(var i=0; i&#x3c;self.options.buffer; i++) {
        if (self.getLength() &#x3c; self.options.max) {
          self.<span class="apidocCodeKeywordSpan">createConnection</span>();
        }
      }
    }
  }, 0);
  this.id = Math.floor(Math.random()*100000);
  this._log(&#x27;Creating a pool connected to &#x27;+this.getAddress());
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.drain" id="apidoc.element.rethinkdbdash.pool.prototype.drain">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>drain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drain = function () {
  var self = this;
  self._draining = true;
  self._log(&#x27;Draining the pool connected to &#x27;+this.getAddress());
  self.emit(&#x27;draining&#x27;);
  var p = new Promise(function(resolve, reject) {
    var connection = self._pool.pop();
    self.emit(&#x27;available-size&#x27;, self._pool.getLength());
    self.emit(&#x27;available-size-diff&#x27;, -1);
    while(connection) {
      connection.close();
      clearTimeout(connection.timeout);
      connection = self._pool.pop();
    }
    if (self.timeoutReconnect !== undefined) {
      clearTimeout(self.timeoutReconnect);
      self.timeoutReconnect = null;
    }
    if (self.getLength() === 0) {
      resolve();
    }
    else {
      self._drainingHandlers = {
        resolve: resolve,
        reject: reject
      }
    }
  });
  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
is solved, this behavior may be changed in the future.

Because the connection pool will keep some connections available, a script will not
terminate. If you have finished executing your queries and want your Node.js script
to exit, you need to drain the pool with:

```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">drain</span>();
```

The pool master by default will log all errors/new states on `stderr`. If you do not
want to pollute `stderr`, pass `silent: true` when you import the driver. You can retrieve the
logs by binding a listener for the `log` event on the pool master.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.drainLocalhost" id="apidoc.element.rethinkdbdash.pool.prototype.drainLocalhost">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>drainLocalhost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drainLocalhost = function () {
  var self = this;
  // All the connections are to localhost, let&#x27;s create new ones (not to localhost)
  self._connectionToReplace = self._numConnections;
  ;
  for(var i=0, numConnections=self._numConnections; i&#x3c;numConnections; i++) {
    self.createConnection().finally(function() {
      self._localhostToDrain++;
      self._connectionToReplace--;
      if ((self._connectionToReplace === 0) &#x26;&#x26; (self._localhostToDrain &#x3e; 0)) {
        var len = self._pool.getLength();
        for(var j=0; j&#x3c;len; j++) {
          if (self._localhostToDrain === 0) {
            break;
          }
          var _connection = self._pool.shift();
          if (helper.localhostAliases.hasOwnProperty(_connection.host)) {
            self._localhostToDrain--;
            _connection.close();
            clearTimeout(_connection.timeout);
          }
          else {
            self._pool.push(_connection);
          }
        }
      }

    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      helper.localhostAliases.hasOwnProperty(pool.options.connection.host))) &#x26;&#x26;
      (server.network.reql_port === pool.options.connection.port)) {

      self._pools[server.id] = self._pools[UNKNOWN_POOLS].splice(j, 1)[0];
      // We may assign the wrong pool to this server if it&#x27;s maching on localhost
      if (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host)) {
        self._pools[server.id].options.connection.host = helper.getCanonicalAddress(server.network.canonical_addresses).host;
        self._pools[server.id].<span class="apidocCodeKeywordSpan">drainLocalhost</span>();
      }
      found = true;
      break;
    }
  }
}
if (found === false) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.getAddress" id="apidoc.element.rethinkdbdash.pool.prototype.getAddress">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getAddress
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAddress = function () {
  return this.options.connection.host+&#x27;:&#x27;+this.options.connection.port;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       if (self.getLength() &#x3c; self.options.max) {
         self.createConnection();
       }
     }
   }
 }, 0);
 this.id = Math.floor(Math.random()*100000);
 this._log(&#x27;Creating a pool connected to &#x27;+this.<span class="apidocCodeKeywordSpan">getAddress</span>());
}

util.inherits(Pool, events.EventEmitter);
/*
* Events:
*  - draining // when `drain` is called
*  - queueing(size of the queue) // the number of queries being beffered changed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.getAvailableLength" id="apidoc.element.rethinkdbdash.pool.prototype.getAvailableLength">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getAvailableLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableLength = function () {
  return this._pool.getLength();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
r.getPoolMaster().getLength();
```

You can also get the number of available connections (idle connections, without
a query running on it).

```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">getAvailableLength</span>();
```

You can also drain the pool as mentionned earlier with;

```js
r.getPoolMaster().drain();
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.getConnection" id="apidoc.element.rethinkdbdash.pool.prototype.getConnection">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getConnection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConnection = function () {
  var self = this;
  var p = new Promise(function(resolve, reject) {
    if (self._draining === true) {
      return reject(new Err.ReqlDriverError(&#x27;The pool is being drained&#x27;).setOperational());
    }

    var connection = self._pool.pop();
    self.emit(&#x27;available-size&#x27;, self._pool.getLength());
    self.emit(&#x27;available-size-diff&#x27;, -1);

    if (connection) {
      clearTimeout(connection.timeout);
      resolve(connection);
    }
    else {
      if ((self._numConnections === 0) &#x26;&#x26; (self._slowGrowth === true)) {
        // If the server is down we do not want to buffer the queries
        return reject(new Err.ReqlDriverError(&#x27;The pool does not have any opened connections and failed to open a new one&#x27;).setOperational
());
      }
    }

    if (self._slowGrowth === false) {
      self._expandBuffer();
    }

  });
  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Find a pool with available connections
var result;
for(var i=0; i&#x3c;self._healthyPools.length; i++) {
  if (self._index &#x3e;= self._healthyPools.length) {
    self._index = 0;
  }
  if (self._healthyPools[self._index].getAvailableLength() &#x3e; 0) {
    result = self._healthyPools[self._index].<span class="apidocCodeKeywordSpan">getConnection</span>();
  }
  self._index++;
  if (self._index === self._healthyPools.length) {
    self._index = 0;
  }
  if (result) {
    return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.getLength" id="apidoc.element.rethinkdbdash.pool.prototype.getLength">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>getLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLength = function () {
  return this._numConnections;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- `draining`: when `drain` is called
- `queueing`: when a query is added/removed from the queue (queries waiting for a connection), the size of the queue is provided
- `size`: when the number of connections changes, the number of connections is provided
- `available-size`: when the number of available connections changes, the number of available connections is provided

You can get the number of connections (opened or being opened).
```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">getLength</span>();
```

You can also get the number of available connections (idle connections, without
a query running on it).

```js
r.getPoolMaster().getAvailableLength();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.putConnection" id="apidoc.element.rethinkdbdash.pool.prototype.putConnection">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>putConnection
        <span class="apidocSignatureSpan">(connection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putConnection = function (connection) {
  var self = this;
  if (connection.end === false) {
    // Temporary attempt to fix #192 - this should not happen.
    return;
  }
  if (self._empty === true) {
    self._empty = false;
    // We emit not-empty only we have at least one opened connection
    self.emit(&#x27;not-empty&#x27;);
  }
  if ((self._localhostToDrain &#x3e; 0) &#x26;&#x26; (helper.localhostAliases.hasOwnProperty(connection.host))) {
    self._localhostToDrain--;
    connection.close();
    clearTimeout(connection.timeout);
    self.createConnection();
  }
  else if (self._drainingHandlers !== null) {
    connection.close();
    clearTimeout(connection.timeout);
    if (self.getLength() === 0) {
      self._drainingHandlers.resolve();
    }
  }
  else if (self._extraConnections &#x3e; 0) {
    self._extraConnections--;
    connection.close().error(function(error) {
      self._log(&#x27;Fail to properly close a connection. Error:&#x27;+JSON.stringify(error));
    });
    clearTimeout(connection.timeout);
  }
<span class="apidocCodeCommentSpan">  /*
  // We let the pool garbage collect these connections
  else if (self.getAvailableLength()+1 &#x3e; self.options.buffer) { // +1 for the connection we may put back
    // Note that because we have available connections here, the pool master has no pending
    // queries.
    connection.close().error(function(error) {
      self._log(&#x27;Fail to properly close a connection. Error:&#x27;+JSON.stringify(error));
    });
    clearTimeout(connection.timeout);
  }
  */
</span>  else {
    self._pool.push(connection);
    self.emit(&#x27;available-size&#x27;, self._pool.getLength());
    self.emit(&#x27;available-size-diff&#x27;, 1);
    self.emit(&#x27;new-connection&#x27;, connection);

    clearTimeout(connection.timeout);
    var timeoutCb = function() {
      if (self._pool.get(0) === connection) {
        if (self._pool.getLength() &#x3e; self.options.buffer) {
          self._pool.shift().close();
          self.emit(&#x27;available-size&#x27;, self._pool.getLength());
          self.emit(&#x27;available-size-diff&#x27;, -1);
        }
        else {
          connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
        }
      }
      else {
        // This should technically never happens
        connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
      }
    }
    connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    clearTimeout(connection.timeout);
    self._decreaseNumConnections();
    self._expandBuffer();
  });
  connection.on(&#x27;release&#x27;, function() {
    if (this._isOpen()) self.<span class="apidocCodeKeywordSpan">putConnection</span>(this);
  });
  self.putConnection(connection);
  return null;
}).error(function(error) {
  // We failed to create a connection, we are now going to create connections one by one
  self._openingConnections--;
  self._decreaseNumConnections();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool.prototype.setOptions" id="apidoc.element.rethinkdbdash.pool.prototype.setOptions">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool.prototype.</span>setOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOptions = function (options) {
  if (helper.isPlainObject(options)) {
    for(var key in options) {
      this.options[key] = options[key];
    }
  }
  return this.options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.pool_master" id="apidoc.module.rethinkdbdash.pool_master">module rethinkdbdash.pool_master</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.pool_master" id="apidoc.element.rethinkdbdash.pool_master.pool_master">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>pool_master
        <span class="apidocSignatureSpan">(r, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PoolMaster(r, options) {
  var self = this;
  var options = options || {};
  var lineLength = options.buffer || 50;

  self._r = r;
  self._line = new Dequeue(lineLength);
  self._pools = {};
  self._pools[UNKNOWN_POOLS] = []; // pools for which we do not know the server&#x27;id
  self._healthyPools = [];
  self._healthy = false;
  self._init = false;
  self._index = 0; // next pool to used
  self._indexUnknown =  0 // next unknown pool to used
  self._discovery = (typeof options.discovery === &#x27;boolean&#x27;) ? options.discovery: false; // Whether the pool master is in discovery
 mode or not
  //self._refresh = (typeof options.refresh === &#x27;number&#x27;) ? options.refresh: 1000*60*60; // Refresh rate for the list of servers
  self._options = options;
  self._options.buffer = options.buffer || 50;
  self._options.max = options.max || 1000;
  self._log = helper.createLogger(self, options.silent || false);
  self._draining = false;
  self._numConnections = 0;
  self._numAvailableConnections = 0;
  self._hasPrintWarningLocalhost = false;
  self._feed = null;
  self._consecutiveFails = -1;
  self._timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?
  self._maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError

  //TODO
  //self._usingPool = true; // If we have used the pool
  self._seed = 0;

  var pool;
  if (Array.isArray(options.servers)) {
    if (options.servers.length &#x3e; 0) {
      self._servers = options.servers;
      for(var i=0; i&#x3c;options.servers.length; i++) {
        var settings = self.createPoolSettings(options, options.servers[i], self._log);
        pool = new Pool(self._r, settings);
        self._pools[UNKNOWN_POOLS].push(pool);
        // A pool is considered healthy by default such that people can do
        // var = require(...)(); query.run();
        self._healthyPools.push(pool);
        self.emitStatus()
      }
    }
    else {
      throw new Err.ReqlDriverError(&#x22;If `servers` is an array, it must contain at least one server&#x22;)
    }
  }
  else {
    self._servers = [{
      host: options.host || &#x27;localhost&#x27;,
      port: options.port || 28015
    }]
    var settings = self.createPoolSettings(options, {}, self._log);
    pool = new Pool(self._r, settings);
    self._pools[UNKNOWN_POOLS].push(pool);
    self._healthyPools.push(pool);
    self.emitStatus()
  }

  // Initialize all the pools - bind listeners
  for(var i=0; i&#x3c;self._pools[UNKNOWN_POOLS].length; i++) {
    self.initPool(self._pools[UNKNOWN_POOLS][i]);
  }
  if ((self._discovery === true)) {
    self._timeout = setTimeout(function() { self.fetchServers() }, 0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.super_" id="apidoc.element.rethinkdbdash.pool_master.super_">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.pool_master.prototype" id="apidoc.module.rethinkdbdash.pool_master.prototype">module rethinkdbdash.pool_master.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype._expandAll" id="apidoc.element.rethinkdbdash.pool_master.prototype._expandAll">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>_expandAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_expandAll = function () {
  for(var i=0; i&#x3c;this._healthyPools.length; i++) {
    this._healthyPools[i]._expandBuffer();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self._line.push({
      resolve: resolve,
      reject: reject
    });

    self.emit(&#x27;queueing&#x27;, self._line.getLength())
    // We could add a condition to be less greedy (for early start)
    self.<span class="apidocCodeKeywordSpan">_expandAll</span>();
  });

}
}
PoolMaster.prototype._expandAll = function() {
for(var i=0; i&#x3c;this._healthyPools.length; i++) {
  this._healthyPools[i]._expandBuffer();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype._flushErrors" id="apidoc.element.rethinkdbdash.pool_master.prototype._flushErrors">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>_flushErrors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flushErrors = function () {
  while(this._line.getLength() &#x3e; 0) {
    this._line.shift().reject(new Err.ReqlDriverError(&#x27;None of the pools have an opened connection and failed to open a new one&#x27;).
setOperational());
    this.emit(&#x27;queueing&#x27;, this._line.getLength())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (self._healthyPools[i] === this) {
      self._healthyPools.splice(i, 1);
      self.emitStatus()
      break;
    }
  }
  if (self._healthyPools.length === 0) {
    self.<span class="apidocCodeKeywordSpan">_flushErrors</span>();
  }

  self.resetBufferParameters();
});
pool.on(&#x27;draining&#x27;, function() {
  for(var i=0; i&#x3c;self._healthyPools.length; i++) {
    if (self._healthyPools[i] === this) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.createPool" id="apidoc.element.rethinkdbdash.pool_master.prototype.createPool">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>createPool
        <span class="apidocSignatureSpan">(server)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createPool = function (server) {
  var self = this;
  var address = helper.getCanonicalAddress(server.network.canonical_addresses);
  var settings = self.createPoolSettings(self._options, {
    port: server.network.reql_port,
    host: address.host
  }, self._log);
  var pool = new Pool(self._r, settings);
  self._pools[server.id] = pool
  self.initPool(pool);
  self._healthyPools.push(pool);
  self.emitStatus()
  self.resetBufferParameters();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          found = true;
          break;
        }
      }
    }
    if (found === false) {
      // We just found a new server, let&#x27;s extract the canonical address and connect to it
      self.<span class="apidocCodeKeywordSpan">createPool</span>(server);
    }
  }
} // Each server know has a pool

// Check if we need to remove pools
helper.loopKeys(self._pools, function(pools, key) { // among the pools with a server id
  if (key !== UNKNOWN_POOLS) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.createPoolSettings" id="apidoc.element.rethinkdbdash.pool_master.prototype.createPoolSettings">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>createPoolSettings
        <span class="apidocSignatureSpan">(globalOptions, serverOptions, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createPoolSettings = function (globalOptions, serverOptions, log) {
  var settings = {};
  var numServers = Array.isArray(globalOptions.servers) ? globalOptions.servers.length: 1;
  helper.loopKeys(globalOptions, function(options, key) {
    if ((key === &#x27;buffer&#x27;) || (key === &#x27;max&#x27;)) {
      settings[key] = Math.ceil(options[key]/numServers);
      settings[key] = Math.ceil(options[key]/numServers);
    }
    else if (key !== &#x27;servers&#x27;) {
      settings[key] = options[key];
    }
  });
  if (serverOptions) {
    helper.loopKeys(serverOptions, function(options, key) {
      settings[key] = options[key];
    });
  }
  settings._log = log;
  return settings;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self._seed = 0;

var pool;
if (Array.isArray(options.servers)) {
  if (options.servers.length &#x3e; 0) {
    self._servers = options.servers;
    for(var i=0; i&#x3c;options.servers.length; i++) {
      var settings = self.<span class="apidocCodeKeywordSpan">createPoolSettings</span>(options, options.servers[i], self._log);
      pool = new Pool(self._r, settings);
      self._pools[UNKNOWN_POOLS].push(pool);
      // A pool is considered healthy by default such that people can do
      // var = require(...)(); query.run();
      self._healthyPools.push(pool);
      self.emitStatus()
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.deletePool" id="apidoc.element.rethinkdbdash.pool_master.prototype.deletePool">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>deletePool
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deletePool = function (key) {
  var self = this;
  var pool = self._pools[key];
  self._log(&#x27;Removing pool connected to: &#x27;+pool.getAddress())
  pool.drain().then(function() {
    pool.removeAllListeners();
  }).error(function(error) {
    self._log(&#x27;Pool connected to: &#x27;+self._pools[key].getAddress()+&#x27; could not be properly drained.&#x27;)
    self._log(error.message);
    self._log(error.stack);
  });
  delete self._pools[key];
  self.resetBufferParameters();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
} // Each server know has a pool

// Check if we need to remove pools
helper.loopKeys(self._pools, function(pools, key) { // among the pools with a server id
  if (key !== UNKNOWN_POOLS) {
    if (knownServer.hasOwnProperty(key) === false) {
      self.<span class="apidocCodeKeywordSpan">deletePool</span>(key); // We just found a pool that doesn&#x27;t map to any known
 RethinkDB server
    }
    else {
      knownServer[key].count++;
    }
  }
});
for(var i=0;i&#x3c;self._pools[UNKNOWN_POOLS].length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.drain" id="apidoc.element.rethinkdbdash.pool_master.prototype.drain">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>drain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drain = function () {
  this.emit(&#x27;draining&#x27;);
  if (this._discovery === true) {
    this._discovery = false;
    if (this._feed != null) {
      this._feed.close();
    }
  }
  this._draining = true;
  var promises = [];
  var pools = this.getPools();
  for(var i=0; i&#x3c;pools.length; i++) {
    promises.push(pools[i].drain());
  }
  this._healthyPools = [];
  var self = this;
  return Promise.all(promises).then(function() {
    for(var i=0; i&#x3c;pools.length; i++) {
      pools[i].removeAllListeners();
    }
  }).error(function(error) {
    if (self._options.silent !== true) {
      self._log(&#x27;Failed to drain all the pools:&#x27;);
      self._log(error.message);
      self._log(error.stack);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
is solved, this behavior may be changed in the future.

Because the connection pool will keep some connections available, a script will not
terminate. If you have finished executing your queries and want your Node.js script
to exit, you need to drain the pool with:

```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">drain</span>();
```

The pool master by default will log all errors/new states on `stderr`. If you do not
want to pollute `stderr`, pass `silent: true` when you import the driver. You can retrieve the
logs by binding a listener for the `log` event on the pool master.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.emitStatus" id="apidoc.element.rethinkdbdash.pool_master.prototype.emitStatus">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>emitStatus
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emitStatus = function () {
  var healthy = this._healthyPools.length !== 0;
  if (this._healthy !== healthy) {
    this._healthy = healthy;
    this.emit(&#x27;healthy&#x27;, healthy)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for(var i=0; i&#x3c;options.servers.length; i++) {
      var settings = self.createPoolSettings(options, options.servers[i], self._log);
      pool = new Pool(self._r, settings);
      self._pools[UNKNOWN_POOLS].push(pool);
      // A pool is considered healthy by default such that people can do
      // var = require(...)(); query.run();
      self._healthyPools.push(pool);
      self.<span class="apidocCodeKeywordSpan">emitStatus</span>()
    }
  }
  else {
    throw new Err.ReqlDriverError(&#x22;If `servers` is an array, it must contain at least one server&#x22;)
  }
}
else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.fetchServers" id="apidoc.element.rethinkdbdash.pool_master.prototype.fetchServers">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>fetchServers
        <span class="apidocSignatureSpan">(useSeeds)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchServers = function (useSeeds) {
  var self = this;
  var query = self._r.db(&#x27;rethinkdb&#x27;).table(&#x27;server_status&#x27;)
      .union([SEPARATOR])
      .union(self._r.db(&#x27;rethinkdb&#x27;).table(&#x27;server_status&#x27;).changes())
  // In case useSeeds is true, we rotate through all the seeds + the pool master
  if (!useSeeds || self._seed === self._servers.length) {
    if (useSeeds &#x26;&#x26; self._seed === self._servers.length) {
      // We increase the back off only when we went through all the seeds
      self._consecutiveFails++;
    }

    self._seed = 0;
    var promise = query.run({cursor: true})
  }
  else {
    var settings = self._servers[self._seed];
    self._seed++;
    var promise = self._r.connect(settings).then(function(connection) {
      return query.run(connection, {cursor: true})
    });
  }
  promise.then(function(feed) {
    if (self._draining === true) {
      // There is no need to close the feed here as we&#x27;ll close the connections
      return feed.close();
    }
    self._feed = feed;
    var initializing = true;
    var servers = [];
    feed.each(function(err, change) {
      if (err) {
        self._log(&#x27;The changefeed on server_status returned an error: &#x27;+err.toString());
        // We have to refetch everything as the server that was serving the feed may
        // have died.
        if (!self._draining) {
          setTimeout(function() {
            self.fetchServers();
          }, 0); // Give a timeout to let the driver clean the pools
        }
        return;
      }
      if (initializing === true) {
        if (change === SEPARATOR) {
          initializing = false;
          self.handleAllServersResponse(servers);
          // Rerun the whole query after to make sure that a change did not skip/sneak between the union. As long
          // as RethinkDB does not provide initial results
          setTimeout(function() {
            self._r.db(&#x27;rethinkdb&#x27;).table(&#x27;server_status&#x27;).run({cursor: false}).then(function(servers) {
              self.handleAllServersResponse(servers);
            }).error(function(error) {
              self._log(&#x27;Fail to retrieve a second copy of server_status&#x27;);
              //TODO Retry
            });
          }, 1000);
        }
        else {
          servers.push(change);
        }
        return;
      }

      if (change.new_val !== null &#x26;&#x26; change.old_val === null) {
        // New server
        self.createPool(change.new_val);
      }
      else if (change.new_val === null &#x26;&#x26; change.old_val !== null) {
        // A server was removed
        var server = change.old_val;
        if (self._pools[server.id] != null) {
          self.deletePool(server.id);
        }
        else {
          var found = false;
          for(var i=0; i&#x3c;self._pools[UNKNOWN_POOLS].length; i++) {
            if (((server.network.canonical_addresses[k].host === self._pools[UNKNOWN_POOLS][i].options.connection.host) ||
              (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) &#x26;&#x26; (helper.localhostAliases.hasOwnProperty
(self._pools[UNKNOWN_POOLS][i].options.connection.host)))) &#x26;&#x26;
              (server.network.reql_port === self._pools[UNKNOWN_POOLS][i].options.connection.port)) {
              found = true;

              (function (pool) {
                self._log(&#x27;Removing pool connected to: &#x27;+pool.getAddress())
                var pool = self._pools[UNKNOWN_POOLS].splice(i, 1)[0];
                pool.drain().then(function() {
                  pool.removeAllListeners();
                }).error(function(error) {
                  if (self._options.silent !== true) {
                    self._log(&#x27;Pool connected to: &#x27;+pool.getAddress()+&#x27; could not be properly drained.&#x27;)
                    self._log(error.message);
                    self._log(error.stack);
                  }
                });
              })(self._pools[UNKNOWN_POOLS][i]);
              break;
            }
          }
        }
        if (found === false) {
          self._log(&#x27;A server was removed but no pool for this server exists...&#x27;)
        }
      }
      // We ignore this change since t ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Initialize all the pools - bind listeners
for(var i=0; i&#x3c;self._pools[UNKNOWN_POOLS].length; i++) {
  self.initPool(self._pools[UNKNOWN_POOLS][i]);
}
if ((self._discovery === true)) {
  self._timeout = setTimeout(function() { self.<span class="apidocCodeKeywordSpan">fetchServers</span>() }, 0);
}
}
util.inherits(PoolMaster, events.EventEmitter);

PoolMaster.prototype.getPools = function() {
var result = [];
helper.loopKeys(this._pools, function(pools, key) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.getAvailableLength" id="apidoc.element.rethinkdbdash.pool_master.prototype.getAvailableLength">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getAvailableLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableLength = function () {
  return this._numAvailableConnections;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
r.getPoolMaster().getLength();
```

You can also get the number of available connections (idle connections, without
a query running on it).

```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">getAvailableLength</span>();
```

You can also drain the pool as mentionned earlier with;

```js
r.getPoolMaster().drain();
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.getConnection" id="apidoc.element.rethinkdbdash.pool_master.prototype.getConnection">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getConnection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConnection = function () {
  var self = this;
  // Find a pool with available connections
  var result;
  for(var i=0; i&#x3c;self._healthyPools.length; i++) {
    if (self._index &#x3e;= self._healthyPools.length) {
      self._index = 0;
    }
    if (self._healthyPools[self._index].getAvailableLength() &#x3e; 0) {
      result = self._healthyPools[self._index].getConnection();
    }
    self._index++;
    if (self._index === self._healthyPools.length) {
      self._index = 0;
    }
    if (result) {
      return result;
    }
  }
  if (self._healthyPools.length === 0) {
    return new Promise(function(resolve, reject) {
      reject(new Err.ReqlDriverError(&#x27;None of the pools have an opened connection and failed to open a new one&#x27;).setOperational());
    });
  }
  else {
    // All pool are busy, buffer the request
    return new Promise(function(resolve, reject) {
      self._line.push({
        resolve: resolve,
        reject: reject
      });

      self.emit(&#x27;queueing&#x27;, self._line.getLength())
      // We could add a condition to be less greedy (for early start)
      self._expandAll();
    });

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Find a pool with available connections
var result;
for(var i=0; i&#x3c;self._healthyPools.length; i++) {
  if (self._index &#x3e;= self._healthyPools.length) {
    self._index = 0;
  }
  if (self._healthyPools[self._index].getAvailableLength() &#x3e; 0) {
    result = self._healthyPools[self._index].<span class="apidocCodeKeywordSpan">getConnection</span>();
  }
  self._index++;
  if (self._index === self._healthyPools.length) {
    self._index = 0;
  }
  if (result) {
    return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.getLength" id="apidoc.element.rethinkdbdash.pool_master.prototype.getLength">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLength = function () {
  return this._numConnections;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- `draining`: when `drain` is called
- `queueing`: when a query is added/removed from the queue (queries waiting for a connection), the size of the queue is provided
- `size`: when the number of connections changes, the number of connections is provided
- `available-size`: when the number of available connections changes, the number of available connections is provided

You can get the number of connections (opened or being opened).
```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">getLength</span>();
```

You can also get the number of available connections (idle connections, without
a query running on it).

```js
r.getPoolMaster().getAvailableLength();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.getNumAvailableConnections" id="apidoc.element.rethinkdbdash.pool_master.prototype.getNumAvailableConnections">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getNumAvailableConnections
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNumAvailableConnections = function () {
  var sum = 0;
  for(var i=0; i&#x3c;this._healthyPools.length; i++) {
    sum += this._healthyPools[i].getAvailableLength();
  }
  return sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.getNumConnections" id="apidoc.element.rethinkdbdash.pool_master.prototype.getNumConnections">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getNumConnections
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNumConnections = function () {
  var sum = 0;
  for(var i=0; i&#x3c;this._healthyPools.length; i++) {
    sum += this._healthyPools[i].getLength();
  }
  return sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.getPools" id="apidoc.element.rethinkdbdash.pool_master.prototype.getPools">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>getPools
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPools = function () {
  var result = [];
  helper.loopKeys(this._pools, function(pools, key) {
    if (key === UNKNOWN_POOLS) {
      for(var i=0;i&#x3c;pools[key].length; i++) {
        result.push(pools[key][i]);
      }
    }
    else {
      result.push(pools[key]);
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
r.getPoolMaster().drain();
```

You can access all the pools with:
```js
r.getPoolMaster().<span class="apidocCodeKeywordSpan">getPools</span>();
```

The pool master emits the `healthy` when its state change. Its state is defined as:
- healthy when at least one pool is healthy: Queries can be immediately executed or will be queued.
- not healthy when no pool is healthy: Queries will immediately fail.

A pool being healthy is it has at least one available connection, or it was just
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.handleAllServersResponse" id="apidoc.element.rethinkdbdash.pool_master.prototype.handleAllServersResponse">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>handleAllServersResponse
        <span class="apidocSignatureSpan">(servers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleAllServersResponse = function (servers) {
  var self = this;
  if (self._draining === true) {
    return;
  }
  // Fill all the known server from RethinkDB
  var knownServer = {};
  for(var i=0; i&#x3c;servers.length; i++) {
    var server = servers[i];
    knownServer[server.id] = {count: 0, server: server};
    if (self._pools[server.id] === undefined) {
      // We potentially have a new server in the cluster, or we already have a pool for this server
      // in one of the UNKNOWN_POOLS
      var found = false;
      for(var j=0; j&#x3c;self._pools[UNKNOWN_POOLS].length; j++) {
        if (found) break;
        var pool = self._pools[UNKNOWN_POOLS][j];
        // If a pool is created with localhost, it will probably match the first server even though it may not the the one
        // So it gets an id
        for(var k=0; k&#x3c;server.network.canonical_addresses.length; k++) {
          // Check for the same host (or if they are both localhost) and port
          if (((server.network.canonical_addresses[k].host === pool.options.connection.host) ||
               (server.network.hostname === pool.options.connection.host) ||
            (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) &#x26;&#x26;
            helper.localhostAliases.hasOwnProperty(pool.options.connection.host))) &#x26;&#x26;
            (server.network.reql_port === pool.options.connection.port)) {

            self._pools[server.id] = self._pools[UNKNOWN_POOLS].splice(j, 1)[0];
            // We may assign the wrong pool to this server if it&#x27;s maching on localhost
            if (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host)) {
              self._pools[server.id].options.connection.host = helper.getCanonicalAddress(server.network.canonical_addresses).host
;
              self._pools[server.id].drainLocalhost();
            }
            found = true;
            break;
          }
        }
      }
      if (found === false) {
        // We just found a new server, let&#x27;s extract the canonical address and connect to it
        self.createPool(server);
      }
    }
  } // Each server know has a pool

  // Check if we need to remove pools
  helper.loopKeys(self._pools, function(pools, key) { // among the pools with a server id
    if (key !== UNKNOWN_POOLS) {
      if (knownServer.hasOwnProperty(key) === false) {
        self.deletePool(key); // We just found a pool that doesn&#x27;t map to any known RethinkDB server
      }
      else {
        knownServer[key].count++;
      }
    }
  });
  for(var i=0;i&#x3c;self._pools[UNKNOWN_POOLS].length; i++) {
    // These pools does not match any server returned by RethinkDB.
    var pool = self._pools[UNKNOWN_POOLS].splice(i, 1)[0];
    self._log(&#x27;Removing pool connected to: &#x27;+pool.getAddress())
    pool.drain().then(function() {
      pool.removeAllListeners();
    }).error(function(error) {
      self._log(&#x27;Pool connected to: &#x27;+self._pools[UNKNOWN_POOLS][i].getAddress()+&#x27; could not be properly drained.&#x27;)
      self._log(error.message);
      self._log(error.stack);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }, 0); // Give a timeout to let the driver clean the pools
  }
  return;
}
if (initializing === true) {
  if (change === SEPARATOR) {
    initializing = false;
    self.<span class="apidocCodeKeywordSpan">handleAllServersResponse</span>(servers);
    // Rerun the whole query after to make sure that a change did not skip/sneak between the union. As long
    // as RethinkDB does not provide initial results
    setTimeout(function() {
      self._r.db(&#x27;rethinkdb&#x27;).table(&#x27;server_status&#x27;).run({cursor: false}).then(function(servers) {
        self.handleAllServersResponse(servers);
      }).error(function(error) {
        self._log(&#x27;Fail to retrieve a second copy of server_status&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.initPool" id="apidoc.element.rethinkdbdash.pool_master.prototype.initPool">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>initPool
        <span class="apidocSignatureSpan">(pool)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initPool = function (pool) {
  var self = this;

  pool.on(&#x27;size-diff&#x27;, function(diff) {
    self._numConnections += diff;
    self.emit(&#x27;size&#x27;, self._numConnections)
  });
  pool.on(&#x27;available-size-diff&#x27;, function(diff) {
    self._numAvailableConnections += diff;
    self.emit(&#x27;available-size&#x27;, self._numAvailableConnections)
  });

  pool.on(&#x27;new-connection&#x27;, function() {
    if (self._line.getLength() &#x3e; 0) {
      var p = self._line.shift();
      this.getConnection().then(p.resolve).error(p.reject);
      self.emit(&#x27;queueing&#x27;, self._line.getLength())
    }
  });
  pool.on(&#x27;not-empty&#x27;, function() {
    if (self._draining === false) {
      var found = false;
      for(var i=0; i&#x3c;self._healthyPools.length; i++) {
        if (self._healthyPools[i] === this) {
          self._healthyPools.length;
          found = true;
          break;
        }
      }
      if (found === false) {
        self._healthyPools.push(this);
        self.emitStatus()
        self.resetBufferParameters();
      }
    }
  });
  pool.on(&#x27;empty&#x27;, function() {
    // A pool that become empty is considered unhealthy
    for(var i=0; i&#x3c;self._healthyPools.length; i++) {
      if (self._healthyPools[i] === this) {
        self._healthyPools.splice(i, 1);
        self.emitStatus()
        break;
      }
    }
    if (self._healthyPools.length === 0) {
      self._flushErrors();
    }

    self.resetBufferParameters();
  });
  pool.on(&#x27;draining&#x27;, function() {
    for(var i=0; i&#x3c;self._healthyPools.length; i++) {
      if (self._healthyPools[i] === this) {
        self._healthyPools.splice(i, 1);
        self.emitStatus()
        break;
      }
    }

    if (self._healthyPools === 0) {
      self._flushErrors();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self._pools[UNKNOWN_POOLS].push(pool);
    self._healthyPools.push(pool);
    self.emitStatus()
  }

  // Initialize all the pools - bind listeners
  for(var i=0; i&#x3c;self._pools[UNKNOWN_POOLS].length; i++) {
    self.<span class="apidocCodeKeywordSpan">initPool</span>(self._pools[UNKNOWN_POOLS][i]);
  }
  if ((self._discovery === true)) {
    self._timeout = setTimeout(function() { self.fetchServers() }, 0);
  }
}
util.inherits(PoolMaster, events.EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.pool_master.prototype.resetBufferParameters" id="apidoc.element.rethinkdbdash.pool_master.prototype.resetBufferParameters">
        function <span class="apidocSignatureSpan">rethinkdbdash.pool_master.prototype.</span>resetBufferParameters
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetBufferParameters = function () {
  var max = Math.floor(this._options.max/this._healthyPools.length)
  var buffer = Math.floor(this._options.buffer/this._healthyPools.length)
  for(var i=0; i&#x3c;this._healthyPools.length; i++) {
    if (this._healthyPools[i].getLength() &#x3e; max) {
      this._healthyPools[i]._extraConnections = this._healthyPools[i].getLength()-max;
    }
    else {
      this._healthyPools[i]._extraConnections = 0;
    }
    this._healthyPools[i].options.max = max
    this._healthyPools[i].options.buffer = buffer;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  host: address.host
}, self._log);
var pool = new Pool(self._r, settings);
self._pools[server.id] = pool
self.initPool(pool);
self._healthyPools.push(pool);
self.emitStatus()
self.<span class="apidocCodeKeywordSpan">resetBufferParameters</span>();
}

// Delete a known pool
PoolMaster.prototype.deletePool = function(key) {
var self = this;
var pool = self._pools[key];
self._log(&#x27;Removing pool connected to: &#x27;+pool.getAddress())
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.stream" id="apidoc.module.rethinkdbdash.stream">module rethinkdbdash.stream</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.stream" id="apidoc.element.rethinkdbdash.stream.stream">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>stream
        <span class="apidocSignatureSpan">(options, cursor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadableStream(options, cursor) {
  if (cursor) this._cursor = cursor;
  this._pending = 0; // How many time we called _read while no cursor was available
  this._index = 0;
  this._maxRecursion = 1000; // Hardcoded
  this._highWaterMark = options.highWaterMark;
  this._closed = false;

  Readable.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.super_" id="apidoc.element.rethinkdbdash.stream.super_">
        function <span class="apidocSignatureSpan">rethinkdbdash.stream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options &#x26;&#x26; typeof options.read === &#x27;function&#x27;)
    this._read = options.read;

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.stream.prototype" id="apidoc.module.rethinkdbdash.stream.prototype">module rethinkdbdash.stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.prototype._fetch" id="apidoc.element.rethinkdbdash.stream.prototype._fetch">
        function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fetch = function () {
  var self = this;
  if (self._closed === true) {
    return;
  }
  if (self._cursor._closed === true) {
    self.push(null);
  }
  else {
    self._cursor._next().then(function(data) {
      if (self._closed === true) {
        return;
      }
      // Silently drop null values for now
      if (data === null) {
        if (self._recursion++ === self._maxRecursion) {
          process.nextTick(function() {
            self._fetch();
          });
        }
        else {
          self._fetch();
        }
      }
      else {
        if (self.push(data) !== false) {
          if (self._recursion++ === self._maxRecursion) {
            process.nextTick(function() {
              self._fetch();
            });
          }
          else {
            self._fetch();
          }
        }
      }
      return null;
    }).error(function(error) {
      if (error.message.match(/No more rows in the/)) {
        self.push(null);
      }
      else if (error.message === &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) {
        // if the user call `close`, the cursor may reject pending requests. We just
        // ignore them here.
      }
      else {
        self.emit(&#x27;error&#x27;, error);
        self.push(null);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (self._data[0].length === self._index) {
      self._index = 0;
      self._data.shift();
      if ((self._data.length === 1)
        &#x26;&#x26; (self._canFetch === true)
        &#x26;&#x26; (self._closed === false)
        &#x26;&#x26; (self._fetching === false)) {
          self.<span class="apidocCodeKeywordSpan">_fetch</span>();
      }
    }
    return Promise.resolve(result).nodeify(callback);
  }
}
else {
  return new Promise(function(resolve, reject) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.prototype._fetchAndDecrement" id="apidoc.element.rethinkdbdash.stream.prototype._fetchAndDecrement">
        function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_fetchAndDecrement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fetchAndDecrement = function () {
  var self = this;
  self._pending--;
  if (self._pending &#x3c; 0 || self._closed === true) {
    return;
  }

  if (self._cursor._closed === true) {
    self.push(null);
  }
  else {
    self._cursor._next().then(function(data) {
      // Silently drop null values for now
      if (data === null) {
        if (self._recursion++ === self._maxRecursion) {
          //Avoid maximum call stack errors
          process.nextTick(function() {
            self._fetchAndDecrement();
          });
        }
        else {
          self._fetchAndDecrement();
        }
      }
      else {
        if (self.push(data) !== false) {
          if (self._recursion++ === self._maxRecursion) {
            process.nextTick(function() {
              self._fetchAndDecrement();
            });
          }
          else {
            self._fetchAndDecrement();
          }
        }
      }
      return null;
    }).error(function(error) {
      if (error.message.match(/No more rows in the/)) {
        self.push(null);
      }
      else if (error.message === &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) {
        // if the user call `close`, the cursor may reject pending requests. We just
        // ignore them here.
      }
      else {
        self.emit(&#x27;error&#x27;, error);
        self.push(null);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ReadableStream.prototype._setCursor = function(cursor) {
if (cursor instanceof Cursor === false) {
  this.emit(&#x27;error&#x27;, new Error(&#x27;Cannot create a stream on a single value.&#x27;));
  this.push(null);
  return this;
}
this._cursor = cursor;
this.<span class="apidocCodeKeywordSpan">_fetchAndDecrement</span>();
}
ReadableStream.prototype._read = function(size) {
this._count++;
if (this._cursor === undefined) {
  this._pending++;
  return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.prototype._read" id="apidoc.element.rethinkdbdash.stream.prototype._read">
        function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_read
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function (size) {
  this._count++;
  if (this._cursor === undefined) {
    this._pending++;
    return;
  }

  this._recursion = 0;
  this._fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.prototype._setCursor" id="apidoc.element.rethinkdbdash.stream.prototype._setCursor">
        function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>_setCursor
        <span class="apidocSignatureSpan">(cursor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setCursor = function (cursor) {
  if (cursor instanceof Cursor === false) {
    this.emit(&#x27;error&#x27;, new Error(&#x27;Cannot create a stream on a single value.&#x27;));
    this.push(null);
    return this;
  }
  this._cursor = cursor;
  this._fetchAndDecrement();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //toStream make sure that options is an object
  helper.loopKeys(options, function(obj, key) {
    _options[key] = obj[key];
  });
  _options.cursor = true;
  stream = new ReadableStream(_options);
  this.run(connection, _options).then(function(cursor) {
    stream.<span class="apidocCodeKeywordSpan">_setCursor</span>(cursor);
    return null;
  }).error(function(error) {
    stream.emit(&#x27;error&#x27;, error);
  });
}
else {
  helper.loopKeys(connection, function(obj, key) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.stream.prototype.close" id="apidoc.element.rethinkdbdash.stream.prototype.close">
        function <span class="apidocSignatureSpan">rethinkdbdash.stream.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
  this._closed = true;
  this.push(null);
  return this._cursor.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
2. Remove everything related to a connection:

```js
r.connect({host: ..., port: ...}).then(function(connection) {
  connection.on(&#x27;error&#x27;, handleError);
  query.run(connection).then(function(result) {
    // console.log(result);
    connection.<span class="apidocCodeKeywordSpan">close</span>();
  });
});
```

Becomes:

```js
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.term" id="apidoc.module.rethinkdbdash.term">module rethinkdbdash.term</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.term" id="apidoc.element.rethinkdbdash.term.term">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>term
        <span class="apidocSignatureSpan">(r, value, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Term(r, value, error) {
  var self = this;
  var term = function(field) {
    if (Term.prototype._fastArity(arguments.length, 1) === false) {
      var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
      Term.prototype._arity(_args, 1, &#x27;(...)&#x27;, self);
    }
    return term.bracket(field);
  }
  helper.changeProto(term, self);

  if (value === undefined) {
    term._query = [];
  }
  else {
    term._query = value;
  }
  term._r = r; // Keep a reference to r for global settings

  if (error !== undefined) {
    term._error = error;
    term._frames = [];
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.term.prototype" id="apidoc.module.rethinkdbdash.term.prototype">module rethinkdbdash.term.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.ISO8601" id="apidoc.element.rethinkdbdash.term.prototype.ISO8601">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ISO8601
        <span class="apidocSignatureSpan">(isoTime, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ISO8601 = function (isoTime, options) {
  this._noPrefix(this, &#x27;ISO8601&#x27;);
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, &#x27;ISO8601&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.ISO8601)
  var args = [new Term(this._r).expr(isoTime)._query];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== &#x27;defaultTimezone&#x27;) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `ISO8601`. Available options are primaryKey &#x3c;string&#x3e;,
durability &#x3c;string&#x3e;, datancenter &#x3c;string&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (expression instanceof Term) {
return expression;
  }
  else if (expression instanceof Function) {
return new Func(self._r, expression);
  }
  else if (expression instanceof Date) {
return new Term(self._r).<span class="apidocCodeKeywordSpan">ISO8601</span>(expression.toISOString())
  }
  else if (Array.isArray(expression)) {
var term = new Term(self._r);
term._query.push(termTypes.MAKE_ARRAY);

var args = [];
for(var i=0; i&#x3c;expression.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._arity" id="apidoc.element.rethinkdbdash.term.prototype._arity">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_arity
        <span class="apidocSignatureSpan">(args, num, method, term)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_arity = function (args, num, method, term) {
  var foundArgs = false;
  for(var i=0; i&#x3c;args.length; i++) {
    if ((args[i] instanceof Term) &#x26;&#x26; (args[i]._query[0] === termTypes.ARGS)) {
      foundArgs = true;
      break;
    }
  }
  if (foundArgs === false) {
    throw new Error.ReqlDriverError(&#x27;`&#x27;+method+&#x27;` takes &#x27;+num+&#x27; argument&#x27;+((num&#x3e;1)?&#x27;s&#x27;:&#x27;&#x27;)+&#x27;, &#x27;+args.length+&#x27; provided&#x27;, term._query
);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var TransformStream = require(__dirname+&#x27;/transform_stream.js&#x27;);

function Term(r, value, error) {
var self = this;
var term = function(field) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype.<span class="apidocCodeKeywordSpan">_arity</span>(_args, 1, &#x27;(...)&#x27;, self);
  }
  return term.bracket(field);
}
helper.changeProto(term, self);

if (value === undefined) {
  term._query = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._arityRange" id="apidoc.element.rethinkdbdash.term.prototype._arityRange">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_arityRange
        <span class="apidocSignatureSpan">(args, min, max, method, term)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_arityRange = function (args, min, max, method, term) {
  var foundArgs = false;
  if (args.length &#x3c; min) {
    for(var i=0; i&#x3c;args.length; i++) {
      if ((args[i] instanceof Term) &#x26;&#x26; (args[i]._query[0] === termTypes.ARGS)) {
        foundArgs = true;
        break;
      }
    }
    if (foundArgs === false) {
      throw new Error.ReqlDriverError(&#x27;`&#x27;+method+&#x27;` takes at least &#x27;+min+&#x27; argument&#x27;+((min&#x3e;1)?&#x27;s&#x27;:&#x27;&#x27;)+&#x27;, &#x27;+args.length+&#x27; provided
&#x27;, term._query);
    }
  }
  else if (args.length &#x3e; max) {
    for(var i=0; i&#x3c;args.length; i++) {
      if ((args[i] instanceof Term) &#x26;&#x26; (args[i]._query[0] === termTypes.ARGS)) {
        foundArgs = true;
        break;
      }
    }
    if (foundArgs === false) {
      throw new Error.ReqlDriverError(&#x27;`&#x27;+method+&#x27;` takes at most &#x27;+max+&#x27; argument&#x27;+((max&#x3e;1)?&#x27;s&#x27;:&#x27;&#x27;)+&#x27;, &#x27;+args.length+&#x27; provided
&#x27;, term._query);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Manipulating Tables
Term.prototype.tableCreate = function(table, options) {
var self = this;
if (self._fastArityRange(arguments.length, 1, 2) === false) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  self.<span class="apidocCodeKeywordSpan">_arityRange</span>(_args, 1, 2, &#x27;tableCreate&#x27;, self);
}


var term = new Term(self._r);
term._query.push(termTypes.TABLE_CREATE)

var args = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._fastArity" id="apidoc.element.rethinkdbdash.term.prototype._fastArity">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_fastArity
        <span class="apidocSignatureSpan">(len, num)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fastArity = function (len, num) {
  return (len === num);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ReadableStream = require(__dirname+&#x27;/stream.js&#x27;);
var WritableStream = require(__dirname+&#x27;/writable_stream.js&#x27;);
var TransformStream = require(__dirname+&#x27;/transform_stream.js&#x27;);

function Term(r, value, error) {
var self = this;
var term = function(field) {
  if (Term.prototype.<span class="apidocCodeKeywordSpan">_fastArity</span>(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, &#x27;(...)&#x27;, self);
  }
  return term.bracket(field);
}
helper.changeProto(term, self);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._fastArityRange" id="apidoc.element.rethinkdbdash.term.prototype._fastArityRange">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_fastArityRange
        <span class="apidocSignatureSpan">(len, min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fastArityRange = function (len, min, max) {
  return ((len &#x3e;= min) &#x26;&#x26; (len &#x3c;= max));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
term._query.push(termTypes.DB_LIST)
return term;
}

// Manipulating Tables
Term.prototype.tableCreate = function(table, options) {
var self = this;
if (self.<span class="apidocCodeKeywordSpan">_fastArityRange</span>(arguments.length, 1, 2) === false) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  self._arityRange(_args, 1, 2, &#x27;tableCreate&#x27;, self);
}


var term = new Term(self._r);
term._query.push(termTypes.TABLE_CREATE)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._fillArgs" id="apidoc.element.rethinkdbdash.term.prototype._fillArgs">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_fillArgs
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fillArgs = function (args) {
  var foundError = false;
  var internalArgs = [];
  for(var i=0; i&#x3c;args.length; i++) {
  if (args[i] instanceof Term) {
    internalArgs.push(args[i]._query);
    if (!foundError &#x26;&#x26; (args[i]._error != null)) {
    this._error = args[i]._error;
    this._frames = args[i]._frames;
    this._frames.unshift(i);
    foundError = true;
    }
  }
  else {
    internalArgs.push(args[i]);
  }
  }
  this._query.push(internalArgs);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Term.prototype.dbCreate = function(db) {
// Check for arity is done in r.prototype.dbCreate
this._noPrefix(this, &#x27;dbCreate&#x27;);

var term = new Term(this._r);
term._query.push(termTypes.DB_CREATE);
var args = [new Term(this._r).expr(db)._query]
term.<span class="apidocCodeKeywordSpan">_fillArgs</span>(args);
return term;
}
Term.prototype.dbDrop = function(db) {
this._noPrefix(this, &#x27;dbDrop&#x27;);

var term = new Term(this._r);
term._query.push(termTypes.DB_DROP);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._noPrefix" id="apidoc.element.rethinkdbdash.term.prototype._noPrefix">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_noPrefix
        <span class="apidocSignatureSpan">(term, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_noPrefix = function (term, method) {
  if ((!Array.isArray(term._query)) || (term._query.length &#x3e; 0)) {
    throw new Error.ReqlDriverError(&#x27;`&#x27;+method+&#x27;` is not defined&#x27;, term._query);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}


// Manipulating databases
Term.prototype.dbCreate = function(db) {
  // Check for arity is done in r.prototype.dbCreate
  this.<span class="apidocCodeKeywordSpan">_noPrefix</span>(this, &#x27;dbCreate&#x27;);

  var term = new Term(this._r);
  term._query.push(termTypes.DB_CREATE);
  var args = [new Term(this._r).expr(db)._query]
  term._fillArgs(args);
  return term;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._setArrayLimit" id="apidoc.element.rethinkdbdash.term.prototype._setArrayLimit">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_setArrayLimit
        <span class="apidocSignatureSpan">(arrayLimit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setArrayLimit = function (arrayLimit) {
  Term.prototype._arrayLimit = arrayLimit;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._setNestingLevel" id="apidoc.element.rethinkdbdash.term.prototype._setNestingLevel">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_setNestingLevel
        <span class="apidocSignatureSpan">(nestingLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setNestingLevel = function (nestingLevel) {
  Term.prototype._nestingLevel = nestingLevel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._toReadableStream" id="apidoc.element.rethinkdbdash.term.prototype._toReadableStream">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_toReadableStream
        <span class="apidocSignatureSpan">(connection, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toReadableStream = function (connection, options) {
  var stream;

  var _options = {};
  if (helper.isPlainObject(connection) &#x26;&#x26; (typeof connection._isConnection === &#x27;function&#x27;) &#x26;&#x26; (connection._isConnection() === true
)) {
    //toStream make sure that options is an object
    helper.loopKeys(options, function(obj, key) {
      _options[key] = obj[key];
    });
    _options.cursor = true;
    stream = new ReadableStream(_options);
    this.run(connection, _options).then(function(cursor) {
      stream._setCursor(cursor);
      return null;
    }).error(function(error) {
      stream.emit(&#x27;error&#x27;, error);
    });
  }
  else {
    helper.loopKeys(connection, function(obj, key) {
      _options[key] = obj[key];
    });
    _options.cursor = true;
    stream = new ReadableStream(_options);
    this.run(_options).then(function(cursor) {
      stream._setCursor(cursor);
      return null;
    }).error(function(error) {
      stream.emit(&#x27;error&#x27;, error);
    });
  }
  return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Term.prototype.toStream = function(connection, options) {
if (helper.isPlainObject(connection) &#x26;&#x26; (typeof connection._isConnection === &#x27;function&#x27;) &#x26;&#x26; (connection
._isConnection() === true)) {
  if (helper.isPlainObject(options) === false) {
    options = {};
  }
  if (options.readable === true) {
    return this.<span class="apidocCodeKeywordSpan">_toReadableStream</span>(connection, options);
  }
  else if (options.writable === true) {
    return this._toWritableStream(connection, options);
  }
  else if (options.transform === true) {
    return this._toTransformStream(connection, options);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._toTransformStream" id="apidoc.element.rethinkdbdash.term.prototype._toTransformStream">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_toTransformStream
        <span class="apidocSignatureSpan">(connection, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTransformStream = function (connection, options) {
  if (this._query[0] !== termTypes.TABLE) {
    throw new Error.ReqlDriverError(&#x27;Cannot create a writable stream on something else than a table.&#x27;);
  }

  if (helper.isPlainObject(connection) &#x26;&#x26; (typeof connection._isConnection === &#x27;function&#x27;) &#x26;&#x26; (connection._isConnection() === true
)) {
    return new TransformStream(this, options, connection);
  }
  else {
    return new TransformStream(this, connection);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (options.readable === true) {
    return this._toReadableStream(connection, options);
  }
  else if (options.writable === true) {
    return this._toWritableStream(connection, options);
  }
  else if (options.transform === true) {
    return this.<span class="apidocCodeKeywordSpan">_toTransformStream</span>(connection, options);
  }
  else {
    return this._toReadableStream(connection, options);
  }
}
else {
  options = connection;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._toWritableStream" id="apidoc.element.rethinkdbdash.term.prototype._toWritableStream">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_toWritableStream
        <span class="apidocSignatureSpan">(connection, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toWritableStream = function (connection, options) {
  if (this._query[0] !== termTypes.TABLE) {
    throw new Error.ReqlDriverError(&#x27;Cannot create a writable stream on something else than a table.&#x27;);
  }

  if (helper.isPlainObject(connection) &#x26;&#x26; (typeof connection._isConnection === &#x27;function&#x27;) &#x26;&#x26; (connection._isConnection() === true
)) {
    return new WritableStream(this, options, connection);
  }
  else {
    return new WritableStream(this, connection);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (helper.isPlainObject(options) === false) {
  options = {};
}
if (options.readable === true) {
  return this._toReadableStream(connection, options);
}
else if (options.writable === true) {
  return this.<span class="apidocCodeKeywordSpan">_toWritableStream</span>(connection, options);
}
else if (options.transform === true) {
  return this._toTransformStream(connection, options);
}
else {
  return this._toReadableStream(connection, options);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype._wrap" id="apidoc.element.rethinkdbdash.term.prototype._wrap">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>_wrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_wrap = function () {
  var self = this;
  if (helper.hasImplicit(this._query)) {
    if (this._query[0] === termTypes.ARGS) {
      throw new Error.ReqlDriverError(&#x27;Implicit variable `r.row` cannot be used inside `r.args`&#x27;)
    }
    //Must pass at least one variable to the function or it won&#x27;t accept r.row
    return new Term(this._r).expr(function(doc) { return self; })
  }
  else {
    return self;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fn = undefined;
}

var term = new Term(this._r);
term._query.push(termTypes.INDEX_CREATE);
var args = [this];
args.push(new Term(this._r).expr(name));
if (typeof fn !== &#x27;undefined&#x27;) args.push(new Term(this._r).expr(fn).<span class="apidocCodeKeywordSpan">_wrap</span>());
term._fillArgs(args);

if (helper.isPlainObject(options)) {
  // There is no need to translate here
  helper.loopKeys(options, function(obj, key) {
    if ((key !== &#x27;multi&#x27;) &#x26;&#x26; (key !== &#x27;geo&#x27;)) {
      throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `indexCreate`&#x27;, self._query, &#x27;Available
 option is multi &#x3c;bool&#x3e; and geo &#x3c;bool&#x3e;&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.add" id="apidoc.element.rethinkdbdash.term.prototype.add">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>add
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;add&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.ADD)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (self._options.format === &#x27;primaryKey&#x27;) {
  query = query.do(function(result) {
    return self._r.branch(
      result(&#x27;errors&#x27;).eq(0),
      self._table.config()(&#x27;primary_key&#x27;).do(function(primaryKey) {
        return result(&#x27;changes&#x27;)(&#x27;new_val&#x27;)(primaryKey)
      }),
      result(self._r.error(result(&#x27;errors&#x27;).coerceTo(&#x27;STRING&#x27;).<span class="apidocCodeKeywordSpan">add</span
>(&#x27; errors returned. First error:\n&#x27;).add(result(&#x27;first_error&#x27;))))
    )
  })
}

query.run(self._connection).then(function(result) {
  self._inserting = false;
  if (self._options.format === &#x27;primaryKey&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.and" id="apidoc.element.rethinkdbdash.term.prototype.and">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>and
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">and = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.AND)
  var args = [];
  if (!Array.isArray(this._query) || (this._query.length &#x3e; 0)) {
    args.push(this);
  }
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.append" id="apidoc.element.rethinkdbdash.term.prototype.append">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>append
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;append&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.APPEND)
  var args = [this, new Term(this._r).expr(value)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.april" id="apidoc.element.rethinkdbdash.term.prototype.april">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>april
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">april = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.APRIL);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.args" id="apidoc.element.rethinkdbdash.term.prototype.args">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>args
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">args = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._noPrefix(this, &#x27;args&#x27;);

  var term = new Term(this._r);
  term._query.push(termTypes.ARGS);
  var args = [];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.asc" id="apidoc.element.rethinkdbdash.term.prototype.asc">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>asc
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asc = function (field) {
  this._noPrefix(this, &#x27;asc&#x27;);
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;asc&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.ASC)
  var args = [new Term(this._r).expr(field)._wrap()];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.august" id="apidoc.element.rethinkdbdash.term.prototype.august">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>august
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">august = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.AUGUST);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.avg" id="apidoc.element.rethinkdbdash.term.prototype.avg">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>avg
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">avg = function (field) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, &#x27;avg&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.AVG)
  var args = [this];
  if (field !== undefined) {
    args.push(new Term(this._r).expr(field)._wrap())
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.between" id="apidoc.element.rethinkdbdash.term.prototype.between">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>between
        <span class="apidocSignatureSpan">(start, end, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">between = function (start, end, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 2, 3, &#x27;between&#x27;, self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.BETWEEN);
  var args = [self, new Term(self._r).expr(start), new Term(self._r).expr(end)]
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;index&#x27;) &#x26;&#x26; (key !== &#x27;leftBound&#x27;) &#x26;&#x26; (key !== &#x27;rightBound&#x27;)){
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `between`&#x27;, self._query, &#x27;Available options are index &#x3c;
string&#x3e;, leftBound &#x3c;string&#x3e;, rightBound &#x3c;string&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.binary" id="apidoc.element.rethinkdbdash.term.prototype.binary">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>binary
        <span class="apidocSignatureSpan">(bin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binary = function (bin) {
  this._noPrefix(this, &#x27;binary&#x27;);
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;binary&#x27;, this);
  }

  var term;
  if (bin instanceof Buffer) {
    // We could use BINARY, and coerce `bin` to an ASCII string, but that
    // will break if there is a null char
    term = new Term(this._r, {
      $reql_type$: &#x27;BINARY&#x27;,
      data: bin.toString(&#x27;base64&#x27;)
    });
  }
  else {
    term = new Term(this._r);
    term._query.push(termTypes.BINARY)
    var args = [new Term(this._r).expr(bin)];
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var result = {
  str: &#x27;&#x27;,
  car: &#x27;&#x27;
}

if ((helper.isPlainObject(term)) &#x26;&#x26; (term.$reql_type$ === &#x27;BINARY&#x27;)) {
  carify(result, &#x27;r.<span class="apidocCodeKeywordSpan">binary</span>(&#x3c;Buffer&#x3e;)&#x27;, underline);
  return result;
}

if ((index === 0) &#x26;&#x26; ((father == null) || (!nonPrefix[father[0]]))) carify(result, &#x27;r.expr(&#x27;, underline)

if (typeof term === &#x27;string&#x27; ) {
  carify(result, &#x27;&#x22;&#x27;+term+&#x27;&#x22;&#x27;, underline);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.bracket" id="apidoc.element.rethinkdbdash.term.prototype.bracket">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>bracket
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bracket = function (field) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;(...)&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.BRACKET)
  var args = [this, new Term(this._r).expr(field)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function Term(r, value, error) {
var self = this;
var term = function(field) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, &#x27;(...)&#x27;, self);
  }
  return term.<span class="apidocCodeKeywordSpan">bracket</span>(field);
}
helper.changeProto(term, self);

if (value === undefined) {
  term._query = [];
}
else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.branch" id="apidoc.element.rethinkdbdash.term.prototype.branch">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>branch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">branch = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 2, Infinity, &#x27;&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.BRANCH)
  var args = [];
  args.push(this);
  for(var i=0; i&#x3c;_len; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof pendingCallback === &#x27;function&#x27;) {
  pendingCallback();
}

var query = self._table.insert(cache, self._insertOptions);
if (self._options.format === &#x27;primaryKey&#x27;) {
  query = query.do(function(result) {
    return self._r.<span class="apidocCodeKeywordSpan">branch</span>(
      result(&#x27;errors&#x27;).eq(0),
      self._table.config()(&#x27;primary_key&#x27;).do(function(primaryKey) {
        return result(&#x27;changes&#x27;)(&#x27;new_val&#x27;)(primaryKey)
      }),
      result(self._r.error(result(&#x27;errors&#x27;).coerceTo(&#x27;STRING&#x27;).add(&#x27; errors returned. First error:\n&#x27
;).add(result(&#x27;first_error&#x27;))))
    )
  })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.catch" id="apidoc.element.rethinkdbdash.term.prototype.catch">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>catch
        <span class="apidocSignatureSpan">(reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catch = function (reject) {
  return this.run().catch(reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```


#### Optional `run` with `yield`

The `then` and `catch` methods are implemented on a `Term` - returned by any methods
like `filter`, `update` etc. They are shortcut for `this.run().then(callback)` and
`this.run().<span class="apidocCodeKeywordSpan">catch</span>(callback)`.

This means that you can `yield` any query without calling `run.`

```js
var bluebird = require(&#x27;bluebird&#x27;);
var r = require(&#x27;rethinkdbdash&#x27;)();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.ceil" id="apidoc.element.rethinkdbdash.term.prototype.ceil">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ceil
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ceil = function () {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, &#x27;ceil&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.CEIL)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Create the settings for a given pool. Merge the global options + the servers&#x27;s one.
PoolMaster.prototype.createPoolSettings = function(globalOptions, serverOptions, log) {
var settings = {};
var numServers = Array.isArray(globalOptions.servers) ? globalOptions.servers.length: 1;
helper.loopKeys(globalOptions, function(options, key) {
  if ((key === &#x27;buffer&#x27;) || (key === &#x27;max&#x27;)) {
    settings[key] = Math.<span class="apidocCodeKeywordSpan">ceil</span>(options[key]/numServers);
    settings[key] = Math.ceil(options[key]/numServers);
  }
  else if (key !== &#x27;servers&#x27;) {
    settings[key] = options[key];
  }
});
if (serverOptions) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.changeAt" id="apidoc.element.rethinkdbdash.term.prototype.changeAt">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>changeAt
        <span class="apidocSignatureSpan">(index, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changeAt = function (index, value) {
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, &#x27;changeAt&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.CHANGE_AT);
  var args = [this];
  args.push(new Term(this._r).expr(index))
  args.push(new Term(this._r).expr(value))
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.changes" id="apidoc.element.rethinkdbdash.term.prototype.changes">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>changes
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 0, 1, &#x27;changes&#x27;, self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.CHANGES);
  var args = [self];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;squash&#x27;) &#x26;&#x26; (key !== &#x27;includeStates&#x27;) &#x26;&#x26; (key !== &#x27;includeTypes&#x27;)
          &#x26;&#x26; (key !== &#x27;includeInitial&#x27;) &#x26;&#x26; (key !== &#x27;includeOffsets&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `changes`&#x27;, self._query,
            &#x27;Available options are squash &#x3c;bool&#x3e;, includeInitial &#x3c;bool&#x3e;, includeStates &#x3c;bool&#x3e;, includeOffsets &#x3c;bool&#x3e;, includeTypes
 &#x3c;bool&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

//  Create the feed on server_status and bind the listener to the feed
PoolMaster.prototype.fetchServers = function(useSeeds) {
var self = this;
var query = self._r.db(&#x27;rethinkdb&#x27;).table(&#x27;server_status&#x27;)
    .union([SEPARATOR])
    .union(self._r.db(&#x27;rethinkdb&#x27;).table(&#x27;server_status&#x27;).<span class="apidocCodeKeywordSpan">changes</span>())
// In case useSeeds is true, we rotate through all the seeds + the pool master
if (!useSeeds || self._seed === self._servers.length) {
  if (useSeeds &#x26;&#x26; self._seed === self._servers.length) {
    // We increase the back off only when we went through all the seeds
    self._consecutiveFails++;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.circle" id="apidoc.element.rethinkdbdash.term.prototype.circle">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>circle
        <span class="apidocSignatureSpan">(center, radius, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">circle = function (center, radius, options) {
  var self = this;

  // Arity check is done by r.circle
  self._noPrefix(self, &#x27;circle&#x27;);
  var term = new Term(self._r);
  term._query.push(termTypes.CIRCLE);
  var args = [new Term(self._r).expr(center), new Term(self._r).expr(radius)];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    // There is no need to translate here
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;numVertices&#x27;) &#x26;&#x26; (key !== &#x27;geoSystem&#x27;) &#x26;&#x26; (key !== &#x27;unit&#x27;) &#x26;&#x26; (key !== &#x27;fill&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `circle`&#x27;, self._query, &#x27;Available options are numVertices
 &#x3c;number&#x3e;, geoSsystem &#x3c;string&#x3e;, unit &#x3c;string&#x3e; and fill &#x3c;bool&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.coerceTo" id="apidoc.element.rethinkdbdash.term.prototype.coerceTo">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>coerceTo
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coerceTo = function (type) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;coerceTo&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.COERCE_TO)
  var args = [this, new Term(this._r).expr(type)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (self._options.format === &#x27;primaryKey&#x27;) {
  query = query.do(function(result) {
    return self._r.branch(
      result(&#x27;errors&#x27;).eq(0),
      self._table.config()(&#x27;primary_key&#x27;).do(function(primaryKey) {
        return result(&#x27;changes&#x27;)(&#x27;new_val&#x27;)(primaryKey)
      }),
      result(self._r.error(result(&#x27;errors&#x27;).<span class="apidocCodeKeywordSpan">coerceTo</span>(&#x27;STRING&#x27;).add
(&#x27; errors returned. First error:\n&#x27;).add(result(&#x27;first_error&#x27;))))
    )
  })
}

query.run(self._connection).then(function(result) {
  self._inserting = false;
  if (self._options.format === &#x27;primaryKey&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.concatMap" id="apidoc.element.rethinkdbdash.term.prototype.concatMap">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>concatMap
        <span class="apidocSignatureSpan">(transformation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatMap = function (transformation) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;concatMap&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.CONCAT_MAP);
  var args = [this];
  args.push(new Term(this._r).expr(transformation)._wrap())
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.config" id="apidoc.element.rethinkdbdash.term.prototype.config">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>config
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;config&#x27;, this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.CONFIG);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var query = self._table.insert(cache, self._insertOptions);
if (self._options.format === &#x27;primaryKey&#x27;) {
  query = query.do(function(result) {
    return self._r.branch(
      result(&#x27;errors&#x27;).eq(0),
      self._table.<span class="apidocCodeKeywordSpan">config</span>()(&#x27;primary_key&#x27;).do(function(primaryKey) {
        return result(&#x27;changes&#x27;)(&#x27;new_val&#x27;)(primaryKey)
      }),
      result(self._r.error(result(&#x27;errors&#x27;).coerceTo(&#x27;STRING&#x27;).add(&#x27; errors returned. First error:\n&#x27
;).add(result(&#x27;first_error&#x27;))))
    )
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.contains" id="apidoc.element.rethinkdbdash.term.prototype.contains">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>contains
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;contains&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.CONTAINS)
  var args = [this._query];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i])._wrap())
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.count" id="apidoc.element.rethinkdbdash.term.prototype.count">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>count
        <span class="apidocSignatureSpan">(filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (filter) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, &#x27;count&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.COUNT);
  var args = [];
  args.push(this);
  if (filter !== undefined) {
    args.push(new Term(this._r).expr(filter)._wrap())
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.date" id="apidoc.element.rethinkdbdash.term.prototype.date">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>date
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">date = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;date&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DATE)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.day" id="apidoc.element.rethinkdbdash.term.prototype.day">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>day
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">day = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;day&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DAY)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.dayOfWeek" id="apidoc.element.rethinkdbdash.term.prototype.dayOfWeek">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dayOfWeek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dayOfWeek = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;dayOfWeek&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DAY_OF_WEEK)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.dayOfYear" id="apidoc.element.rethinkdbdash.term.prototype.dayOfYear">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dayOfYear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dayOfYear = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;dayOfYear&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DAY_OF_YEAR)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.db" id="apidoc.element.rethinkdbdash.term.prototype.db">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>db
        <span class="apidocSignatureSpan">(db)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">db = function (db) {
  this._noPrefix(this, &#x27;db&#x27;);
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;db&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DB)
  var args = [new Term(this._r).expr(db)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      carify(result, &#x27;r.&#x27;+typeToString[term[0]]+&#x27;(&#x27;, underline);
      if (Array.isArray(term[1])) {
        for(var i=0; i&#x3c;term[1].length; i++) {
if (i !==0) result.str += &#x27;, &#x27;;


if ((currentFrame != null) &#x26;&#x26; (currentFrame === 1)) {
  // +1 for index because it&#x27;s like if there was a r.<span class="apidocCodeKeywordSpan">db</span>(...) before .table(...)
  backtrace = generateBacktrace(term[1][i], i+1, term, frames, options)
}
else {
  backtrace = generateBacktrace(term[1][i], i+1, term, null, options)
}
result.str += backtrace.str;
result.car += backtrace.car
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.dbCreate" id="apidoc.element.rethinkdbdash.term.prototype.dbCreate">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dbCreate
        <span class="apidocSignatureSpan">(db)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dbCreate = function (db) {
  // Check for arity is done in r.prototype.dbCreate
  this._noPrefix(this, &#x27;dbCreate&#x27;);

  var term = new Term(this._r);
  term._query.push(termTypes.DB_CREATE);
  var args = [new Term(this._r).expr(db)._query]
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tableName = util.uuid()

var query; // without `.run()`
//query = &#x27;r.table(&#x22;foo&#x22;).add(1).add(1).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22
;).add(&#x22;one-last-string&#x22;).map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test
) { return test(&#x22;b&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-
string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add
(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super
-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22
;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).mul(test(&#x22;b&#x22;)).merge({ firstName: &#x22;xxxxxx
&#x22;, lastName: &#x22;yyyy&#x22;, email: &#x22;xxxxx@yyyy.com&#x22;, phone: &#x22;xxx-xxx-xxxx&#x22; }); }).add(2).map(function
(doc) { return doc.add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).
add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super
-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22
;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another
-long-string&#x22;).add(&#x22;one-last-string&#x22;) }); })&#x27;;
query = &#x27;r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })&#x27;;
Promise.coroutine(function* () {
try {
  yield r.<span class="apidocCodeKeywordSpan">dbCreate</span>(dbName).run();
  yield r.db(dbName).tableCreate(tableName).run();

  var result = yield eval(query).run();
  throw new Error(&#x22;Should have thrown an error&#x22;);
}
catch(e) {
  console.log(e.message);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.dbDrop" id="apidoc.element.rethinkdbdash.term.prototype.dbDrop">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dbDrop
        <span class="apidocSignatureSpan">(db)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dbDrop = function (db) {
  this._noPrefix(this, &#x27;dbDrop&#x27;);

  var term = new Term(this._r);
  term._query.push(termTypes.DB_DROP);
  var args = [new Term(this._r).expr(db)._query]
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.dbList" id="apidoc.element.rethinkdbdash.term.prototype.dbList">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>dbList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dbList = function () {
  this._noPrefix(this, &#x27;dbList&#x27;);

  var term = new Term(this._r);
  term._query.push(termTypes.DB_LIST)
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.december" id="apidoc.element.rethinkdbdash.term.prototype.december">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>december
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">december = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.DECEMBER);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.default" id="apidoc.element.rethinkdbdash.term.prototype.default">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>default
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default = function (expression) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;default&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DEFAULT);
  var args = [this, new Term(this._r).expr(expression)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.delay" id="apidoc.element.rethinkdbdash.term.prototype.delay">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>delay
        <span class="apidocSignatureSpan">(msecs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function (msecs) {
  return this.run().delay(msecs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Term.prototype.catch = function(reject) {
  return this.run().catch(reject);
}
Term.prototype.finally = function(handler) {
  return this.run().finally(handler);
}
Term.prototype.delay = function(msecs) {
  return this.run().<span class="apidocCodeKeywordSpan">delay</span>(msecs);
}

Term.prototype.toString = function() {
  return Error.generateBacktrace(this._query, 0, null, [], {indent: 0, extra: 0}).str;
}

Term.prototype._wrap = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.delete" id="apidoc.element.rethinkdbdash.term.prototype.delete">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>delete
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 0, 1, &#x27;delete&#x27;, self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.DELETE);
  var args = [self];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;returnChanges&#x27;) &#x26;&#x26; (key !== &#x27;durability&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `delete`&#x27;, self._query, &#x27;Available options are returnChanges
 &#x3c;bool&#x3e;, durability &#x3c;string&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    connection.on(&#x27;error&#x27;, function(error) {
// We are going to close connection, but we don&#x27;t want another process to use it before
// So we remove it from the pool now (if it&#x27;s inside)
self._log(&#x27;Error emitted by a connection: &#x27;+JSON.stringify(error));
for(var i=0; i&#x3c;self.getAvailableLength(); i++) {
  if (self._pool.get(i) === this) {
    self._pool.<span class="apidocCodeKeywordSpan">delete</span>(i);
    self.emit(&#x27;available-size&#x27;, self._pool.getLength());
    self.emit(&#x27;available-size-diff&#x27;, -1);
    break;
  }
}
// We want to make sure that it&#x27;s not going to try to reconnect
clearTimeout(connection.timeout);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.deleteAt" id="apidoc.element.rethinkdbdash.term.prototype.deleteAt">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>deleteAt
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteAt = function (start, end) {
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, &#x27;deleteAt&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DELETE_AT);
  var args = [this, new Term(this._r).expr(start)];
  if (end !== undefined) {
    args.push(new Term(this._r).expr(end))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.desc" id="apidoc.element.rethinkdbdash.term.prototype.desc">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>desc
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">desc = function (field) {
  this._noPrefix(this, &#x27;desc&#x27;);
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;desc&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DESC)
  var args = [new Term(this._r).expr(field)._wrap()];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.difference" id="apidoc.element.rethinkdbdash.term.prototype.difference">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>difference
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">difference = function (other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;difference&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DIFFERENCE)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.distance" id="apidoc.element.rethinkdbdash.term.prototype.distance">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>distance
        <span class="apidocSignatureSpan">(geometry, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distance = function (geometry, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, &#x27;distance&#x27;, self);
  }
  var term = new Term(self._r);
  term._query.push(termTypes.DISTANCE);
  var args = [self, new Term(self._r).expr(geometry)];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;geoSystem&#x27;) &#x26;&#x26; (key !== &#x27;unit&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `distance`&#x27;, self._query, &#x27;Available options are geoSystem
 &#x3c;string&#x3e;, unit &#x3c;string&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.distinct" id="apidoc.element.rethinkdbdash.term.prototype.distinct">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>distinct
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distinct = function (options) {
  var self= this;
  if (self._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 0, 1, &#x27;distinct&#x27;, self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.DISTINCT)
  var args = [self];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    var keepGoing = true;
    helper.loopKeys(options, function(obj, key) {
      if ((keepGoing === true) &#x26;&#x26; (key !== &#x27;index&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `distinct`&#x27;, self._query, &#x27;Available option is index: &#x3c;
string&#x3e;&#x27;);
        keepGoing = false;
      }
    });
    if (keepGoing === true) {
      term._query.push(new Term(self._r).expr(translateOptions(options))._query);
    }
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.div" id="apidoc.element.rethinkdbdash.term.prototype.div">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>div
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">div = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;div&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.DIV)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.do" id="apidoc.element.rethinkdbdash.term.prototype.do">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>do
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">do = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;do&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.FUNCALL);
  var args = [new Term(this._r).expr(_args[_args.length-1])._wrap()._query];
  args.push(this);
  for(var i=0; i&#x3c;_args.length-1; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

carify(result, &#x27;var_&#x27;+term[1][0], underline);

if (underline) result.car = result.str.replace(/./g, &#x27;^&#x27;);
return result;
  },
  FUNCALL: function(term, index, father, frames, options) {
// The syntax is args[1].<span class="apidocCodeKeywordSpan">do</span>(args[0])
var result = {
  str: &#x27;&#x27;,
  car: &#x27;&#x27;
};
var backtrace, underline, currentFrame;

var underline = Array.isArray(frames) &#x26;&#x26; (frames.length === 0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.downcase" id="apidoc.element.rethinkdbdash.term.prototype.downcase">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>downcase
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">downcase = function (regex) {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;upcase&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DOWNCASE)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.during" id="apidoc.element.rethinkdbdash.term.prototype.during">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>during
        <span class="apidocSignatureSpan">(left, right, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">during = function (left, right, options) {
  if (this._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 2, 3, &#x27;during&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DURING);
  var args = [];
  args.push(this);
  args.push(new Term(this._r).expr(left));
  args.push(new Term(this._r).expr(right));

  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.epochTime" id="apidoc.element.rethinkdbdash.term.prototype.epochTime">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>epochTime
        <span class="apidocSignatureSpan">(epochTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">epochTime = function (epochTime) {
  this._noPrefix(this, &#x27;epochTime&#x27;);

  var term = new Term(this._r);
  term._query.push(termTypes.EPOCH_TIME)
  var args = [new Term(this._r).expr(epochTime)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.eq" id="apidoc.element.rethinkdbdash.term.prototype.eq">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>eq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eq = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;eq&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.EQ)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  pendingCallback();
}

var query = self._table.insert(cache, self._insertOptions);
if (self._options.format === &#x27;primaryKey&#x27;) {
  query = query.do(function(result) {
    return self._r.branch(
      result(&#x27;errors&#x27;).<span class="apidocCodeKeywordSpan">eq</span>(0),
      self._table.config()(&#x27;primary_key&#x27;).do(function(primaryKey) {
        return result(&#x27;changes&#x27;)(&#x27;new_val&#x27;)(primaryKey)
      }),
      result(self._r.error(result(&#x27;errors&#x27;).coerceTo(&#x27;STRING&#x27;).add(&#x27; errors returned. First error:\n&#x27
;).add(result(&#x27;first_error&#x27;))))
    )
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.eqJoin" id="apidoc.element.rethinkdbdash.term.prototype.eqJoin">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>eqJoin
        <span class="apidocSignatureSpan">(rightKey, sequence, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eqJoin = function (rightKey, sequence, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 2, 3, &#x27;eqJoin&#x27;, self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.EQ_JOIN);
  var args = [self];
  args.push(new Term(self._r).expr(rightKey)._wrap());
  args.push(new Term(self._r).expr(sequence));
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;index&#x27;) &#x26;&#x26; (key !== &#x27;ordered&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `eqJoin`&#x27;, self._query, &#x27;Available options are index &#x3c;
string&#x3e;, ordered &#x3c;boolean&#x3e;&#x27;);
      }
    })
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.error" id="apidoc.element.rethinkdbdash.term.prototype.error">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>error
        <span class="apidocSignatureSpan">(reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (reject) {
  return this.run().error(reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Once you have imported the driver, you can immediately run queries,
you don&#x27;t need to call `r.connect`, or pass a connection to `run`.

```js
var r = require(&#x27;rethinkdbdash&#x27;)();
r.table(&#x27;users&#x27;).get(&#x27;orphee@gmail.com&#x27;).run().then(function(user) {
  // ...
}).<span class="apidocCodeKeywordSpan">error</span>(handleError)
```

- Cursors are coerced to arrays by default

```js
var r = require(&#x27;rethinkdbdash&#x27;)();
r.table(&#x27;data&#x27;).run().then(function(result) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.expr" id="apidoc.element.rethinkdbdash.term.prototype.expr">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>expr
        <span class="apidocSignatureSpan">(expression, nestingLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expr = function (expression, nestingLevel) {
  var self = this;
  self._noPrefix(self, &#x27;expr&#x27;);
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, &#x27;expr&#x27;, self);
  }

  // undefined will be caught in the last else
  var ar, obj;

  if (expression === undefined) {
    var error = &#x27;Cannot convert `undefined` with r.expr()&#x27;;
    return new Term(self._r, expression, error);
  }

  var _nestingLevel = nestingLevel;
  if (_nestingLevel == null) {
    _nestingLevel = self._r.nestingLevel;
  }
  //if (nestingLevel == null) nestingLevel = self._r.nestingLevel;
  if (_nestingLevel &#x3c; 0) throw new Error.ReqlDriverError(&#x27;Nesting depth limit exceeded.\nYou probably have a circular reference
somewhere&#x27;)

  if (expression instanceof Term) {
    return expression;
  }
  else if (expression instanceof Function) {
    return new Func(self._r, expression);
  }
  else if (expression instanceof Date) {
    return new Term(self._r).ISO8601(expression.toISOString())
  }
  else if (Array.isArray(expression)) {
    var term = new Term(self._r);
    term._query.push(termTypes.MAKE_ARRAY);

    var args = [];
    for(var i=0; i&#x3c;expression.length; i++) {
      args.push(new Term(self._r).expr(expression[i], _nestingLevel-1))
    }
    term._fillArgs(args);
    return term;
  }
  else if (expression instanceof Buffer) {
    return self._r.binary(expression);
  }
  else if (helper.isPlainObject(expression)) {
    var term = new Term(self._r);
    var optArgs = {};
    var foundError = false;
    helper.loopKeys(expression, function(expression, key) {
      if (expression[key] !== undefined) {
        var optArg = new Term(self._r).expr(expression[key], _nestingLevel-1);
        if (optArg instanceof Term &#x26;&#x26; !foundError &#x26;&#x26; optArg._error != null) {
          foundError = true;
          term._error = optArg._error;
          term._frames = [key].concat(optArg._frames);
        }
        optArgs[key] = optArg._query;
      }
    });
    term._query = optArgs;
    return term;
  }
  else { // Primitive
    if (expression === null) {
      return new Term(self._r, null, expression);
    }
    else if (typeof expression === &#x27;string&#x27;) {
      return new Term(self._r, expression);
    }
    else if (typeof expression === &#x27;number&#x27;) {
      if (expression !== expression) {
        var error = &#x27;Cannot convert `NaN` to JSON&#x27;;
        return new Term(self._r, expression, error);
      }
      else if (!isFinite(expression)) {
        var error = &#x27;Cannot convert `Infinity` to JSON&#x27;;
        return new Term(self._r, expression, error);
      }
      return new Term(self._r, expression);
    }
    else if (typeof expression === &#x27;boolean&#x27;) {
      return new Term(self._r, expression);
    }
    else {
      self._error = new Error.ReqlDriverError(&#x27;Cannot convert `&#x27;+expression+&#x27;` to datum.&#x27;);
      self._frames = [];
    }
  }
  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Arrays by default, not cursors

Rethinkdbdash automatically coerce cursors to arrays. If you need a raw cursor,
you can call the `run` command with the option `{cursor: true}` or import the
driver with `{cursor: true}`.

```js
r.<span class="apidocCodeKeywordSpan">expr</span>([1, 2, 3]).run().then(function(result) {
console.log(JSON.stringify(result)) // print [1, 2, 3]
})
```

```js
r.expr([1, 2, 3]).run({cursor: true}).then(function(cursor) {
cursor.toArray().then(function(result) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.february" id="apidoc.element.rethinkdbdash.term.prototype.february">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>february
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">february = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.FEBRUARY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.fill" id="apidoc.element.rethinkdbdash.term.prototype.fill">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>fill
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fill = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;fill&#x27;, this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.FILL);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.filter" id="apidoc.element.rethinkdbdash.term.prototype.filter">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>filter
        <span class="apidocSignatureSpan">(filter, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (filter, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, &#x27;filter&#x27;, self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.FILTER);
  var args = [self, new Term(self._r).expr(filter)._wrap()]
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== &#x27;default&#x27;) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `filter`&#x27;, self._query, &#x27;Available option is filter&#x27;);
      }
    })
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.finally" id="apidoc.element.rethinkdbdash.term.prototype.finally">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>finally
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finally = function (handler) {
  return this.run().finally(handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
Pool.prototype.drainLocalhost = function() {
var self = this;
// All the connections are to localhost, let&#x27;s create new ones (not to localhost)
self._connectionToReplace = self._numConnections;
;
for(var i=0, numConnections=self._numConnections; i&#x3c;numConnections; i++) {
  self.createConnection().<span class="apidocCodeKeywordSpan">finally</span>(function() {
    self._localhostToDrain++;
    self._connectionToReplace--;
    if ((self._connectionToReplace === 0) &#x26;&#x26; (self._localhostToDrain &#x3e; 0)) {
      var len = self._pool.getLength();
      for(var j=0; j&#x3c;len; j++) {
        if (self._localhostToDrain === 0) {
          break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.floor" id="apidoc.element.rethinkdbdash.term.prototype.floor">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>floor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">floor = function () {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, &#x27;floor&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.FLOOR)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var queryStr = JSON.stringify(query);
var querySize = Buffer.byteLength(queryStr);

var buffer = new Buffer(8+4+querySize);
buffer.writeUInt32LE(token &#x26; 0xFFFFFFFF, 0)
buffer.writeUInt32LE(Math.<span class="apidocCodeKeywordSpan">floor</span>(token / 0xFFFFFFFF), 4)

buffer.writeUInt32LE(querySize, 8);

buffer.write(queryStr, 12);

// noreply instead of noReply because the otpions are translated for the server
if ((!helper.isPlainObject(options)) || (options.noreply != true)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.fold" id="apidoc.element.rethinkdbdash.term.prototype.fold">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>fold
        <span class="apidocSignatureSpan">(base, func, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fold = function (base, func, options) {
  if (this._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 2, 3, &#x27;range&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.FOLD)
  var args = [this, new Term(this._r).expr(base), new Term(this._r).expr(func)._wrap()];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;emit&#x27;) &#x26;&#x26; (key !== &#x27;finalEmit&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `fold`. Available options are emit &#x3c;function&#x3e;, finalEmit
 &#x3c;function&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.forEach" id="apidoc.element.rethinkdbdash.term.prototype.forEach">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>forEach
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (func) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;forEach&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.FOR_EACH);
  var args = [this, new Term(this._r).expr(func)._wrap()];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.friday" id="apidoc.element.rethinkdbdash.term.prototype.friday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>friday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">friday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.FRIDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.ge" id="apidoc.element.rethinkdbdash.term.prototype.ge">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ge
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ge = function (other) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;ge&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.GE)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.geojson" id="apidoc.element.rethinkdbdash.term.prototype.geojson">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>geojson
        <span class="apidocSignatureSpan">(geometry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">geojson = function (geometry) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;geojson&#x27;, this);
  }
  this._noPrefix(this, &#x27;geojson&#x27;);
  var term = new Term(this._r);
  term._query.push(termTypes.GEOJSON);
  var args = [new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.get" id="apidoc.element.rethinkdbdash.term.prototype.get">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>get
        <span class="apidocSignatureSpan">(primaryKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (primaryKey) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;get&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.GET);
  var args = [this, new Term(this._r).expr(primaryKey)]
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Connections are managed by the driver with an efficient connection pool.
Once you have imported the driver, you can immediately run queries,
you don&#x27;t need to call `r.connect`, or pass a connection to `run`.

```js
var r = require(&#x27;rethinkdbdash&#x27;)();
r.table(&#x27;users&#x27;).<span class="apidocCodeKeywordSpan">get</span>(&#x27;orphee@gmail.com&#x27;).run().then(function(user
) {
  // ...
}).error(handleError)
```

- Cursors are coerced to arrays by default

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.getAll" id="apidoc.element.rethinkdbdash.term.prototype.getAll">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAll = function () {
  // We explicitly _args here, so fastArityRange is not useful
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.GET_ALL);

  var args = [];
  args.push(this);
  for(var i=0; i&#x3c;_args.length-1; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  if ((_args.length &#x3e; 0) &#x26;&#x26; (helper.isPlainObject(_args[_args.length-1])) &#x26;&#x26; (_args[_args.length-1].index !== undefined)) {
    term._fillArgs(args);
    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);
  }
  else if (_args.length &#x3e; 0) {
    args.push(new Term(this._r).expr(_args[_args.length-1]))
    term._fillArgs(args);
  } else {
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.getField" id="apidoc.element.rethinkdbdash.term.prototype.getField">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getField
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getField = function (field) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;(...)&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.GET_FIELD)
  var args = [this, new Term(this._r).expr(field)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.getIntersecting" id="apidoc.element.rethinkdbdash.term.prototype.getIntersecting">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getIntersecting
        <span class="apidocSignatureSpan">(geometry, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIntersecting = function (geometry, options) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, &#x27;getIntersecting&#x27;, this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.GET_INTERSECTING);
  var args = [this, new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== &#x27;index&#x27;) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `distance`&#x27;, self._query, &#x27;Available options are index
 &#x3c;string&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.getNearest" id="apidoc.element.rethinkdbdash.term.prototype.getNearest">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>getNearest
        <span class="apidocSignatureSpan">(geometry, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNearest = function (geometry, options) {
  var self = this;
  if (self._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arity(_args, 2, &#x27;getNearest&#x27;, self);
  }
  var term = new Term(self._r);
  term._query.push(termTypes.GET_NEAREST);
  var args = [self, new Term(self._r).expr(geometry)];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;index&#x27;) &#x26;&#x26; (key !== &#x27;maxResults&#x27;) &#x26;&#x26; (key !== &#x27;maxDist&#x27;) &#x26;&#x26; (key !== &#x27;unit&#x27;) &#x26;&#x26; (key !== &#x27;geoSystem&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `getNearest`&#x27;, self._query, &#x27;Available options are index
 &#x3c;string&#x3e;, maxResults &#x3c;number&#x3e;, maxDist &#x3c;number&#x3e;, unit &#x3c;string&#x3e;, geoSystem &#x3c;string&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.grant" id="apidoc.element.rethinkdbdash.term.prototype.grant">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>grant
        <span class="apidocSignatureSpan">(name, access)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">grant = function (name, access) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, &#x27;grant&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.GRANT)
  var args = [this, new Term(this._r).expr(name), new Term(this._r).expr(access)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.group" id="apidoc.element.rethinkdbdash.term.prototype.group">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>group
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">group = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  var self = this;
  self._arityRange(_args, 1, Infinity, &#x27;group&#x27;, self);

  var term = new Term(self._r);
  term._query.push(termTypes.GROUP);
  var args = [self];
  for(var i=0; i&#x3c;_args.length-1; i++) {
    args.push(new Term(self._r).expr(_args[i])._wrap())
  }
  if (_args.length &#x3e; 0) {
    if (helper.isPlainObject(_args[_args.length-1])) {
      helper.loopKeys(_args[_args.length-1], function(obj, key) {
         if ((key !== &#x27;index&#x27;)
        &#x26;&#x26; (key !==  &#x27;multi&#x27;)) {
          throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `group`&#x27;, self._query, &#x27;Available options are index: &#x3c;
string&#x3e;, multi &#x3c;boolean&#x3e;&#x27;);
        }
      });
      term._fillArgs(args);
      term._query.push(new Term(self._r).expr(translateOptions(_args[_args.length-1]))._query);
    }
    else {
      args.push(new Term(self._r).expr(_args[_args.length-1])._wrap())
      term._fillArgs(args);
    }
  }
  else {
    term._fillArgs(args);
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.gt" id="apidoc.element.rethinkdbdash.term.prototype.gt">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>gt
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gt = function (other) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;gt&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.GT)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.hasFields" id="apidoc.element.rethinkdbdash.term.prototype.hasFields">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>hasFields
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasFields = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;hasFields&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.HAS_FIELDS)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.hours" id="apidoc.element.rethinkdbdash.term.prototype.hours">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>hours
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hours = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;hours&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.HOURS)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.http" id="apidoc.element.rethinkdbdash.term.prototype.http">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>http
        <span class="apidocSignatureSpan">(url, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http = function (url, options) {
  this._noPrefix(this, &#x27;http&#x27;);
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, &#x27;http&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.HTTP);
  var args = [new Term(this._r).expr(url)];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;timeout&#x27;)
        &#x26;&#x26; (key !==  &#x27;attempts&#x27;)
        &#x26;&#x26; (key !==  &#x27;redirects&#x27;)
        &#x26;&#x26; (key !==  &#x27;verify&#x27;)
        &#x26;&#x26; (key !==  &#x27;resultFormat&#x27;)
        &#x26;&#x26; (key !==  &#x27;method&#x27;)
        &#x26;&#x26; (key !==  &#x27;auth&#x27;)
        &#x26;&#x26; (key !==  &#x27;params&#x27;)
        &#x26;&#x26; (key !==  &#x27;header&#x27;)
        &#x26;&#x26; (key !==  &#x27;data&#x27;)
        &#x26;&#x26; (key !==  &#x27;page&#x27;)
        &#x26;&#x26; (key !==  &#x27;pageLimit&#x27;)
        &#x26;&#x26; (key !==  &#x27;&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `http`. Available options are attempts &#x3c;number&#x3e;, redirects
 &#x3c;number&#x3e;, verify &#x3c;boolean&#x3e;, resultFormat: &#x3c;string&#x3e;, method: &#x3c;string&#x3e;, auth: &#x3c;object&#x3e;, params: &#x3c;object&#x3e;, header: &#x3c;string&#x3e;, data: &#x3c;
string&#x3e;, page: &#x3c;string/function&#x3e;, pageLimit: &#x3c;number&#x3e;&#x27;);
      }
    });

    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.inTimezone" id="apidoc.element.rethinkdbdash.term.prototype.inTimezone">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>inTimezone
        <span class="apidocSignatureSpan">(timezone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inTimezone = function (timezone) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;inTimezone&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.IN_TIMEZONE)
  var args = [this, new Term(this._r).expr(timezone)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.includes" id="apidoc.element.rethinkdbdash.term.prototype.includes">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>includes
        <span class="apidocSignatureSpan">(geometry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includes = function (geometry) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;includes&#x27;, this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.INCLUDES);
  var args = [this, new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexCreate" id="apidoc.element.rethinkdbdash.term.prototype.indexCreate">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexCreate
        <span class="apidocSignatureSpan">(name, fn, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexCreate = function (name, fn, options) {
  if (this._fastArityRange(arguments.length, 1, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 3, &#x27;indexCreate&#x27;, this);
  }

  if ((options == null) &#x26;&#x26; (helper.isPlainObject(fn))) {
    options = fn;
    fn = undefined;
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_CREATE);
  var args = [this];
  args.push(new Term(this._r).expr(name));
  if (typeof fn !== &#x27;undefined&#x27;) args.push(new Term(this._r).expr(fn)._wrap());
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    // There is no need to translate here
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;multi&#x27;) &#x26;&#x26; (key !== &#x27;geo&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `indexCreate`&#x27;, self._query, &#x27;Available option is multi
 &#x3c;bool&#x3e; and geo &#x3c;bool&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(this._r).expr(options)._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexDrop" id="apidoc.element.rethinkdbdash.term.prototype.indexDrop">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexDrop
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexDrop = function (name) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;indexDrop&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_DROP);
  var args = [this, new Term(this._r).expr(name)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexList" id="apidoc.element.rethinkdbdash.term.prototype.indexList">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexList = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;indexList&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_LIST);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexRename" id="apidoc.element.rethinkdbdash.term.prototype.indexRename">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexRename
        <span class="apidocSignatureSpan">(oldName, newName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexRename = function (oldName, newName, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 2, 3, &#x27;indexRename&#x27;, self);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_RENAME);
  var args = [this, new Term(this._r).expr(oldName), new Term(this._r).expr(newName)];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== &#x27;overwrite&#x27;) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `indexRename`&#x27;, self._query, &#x27;Available options are overwrite
 &#x3c;bool&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }


  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexStatus" id="apidoc.element.rethinkdbdash.term.prototype.indexStatus">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexStatus
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexStatus = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_STATUS);
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexWait" id="apidoc.element.rethinkdbdash.term.prototype.indexWait">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexWait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexWait = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_WAIT);
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.indexesOf" id="apidoc.element.rethinkdbdash.term.prototype.indexesOf">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>indexesOf
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexesOf = function (predicate) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;indexesOf&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.OFFSETS_OF)
  var args = [this, new Term(this._r).expr(predicate)._wrap()];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.info" id="apidoc.element.rethinkdbdash.term.prototype.info">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>info
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">info = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;info&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INFO);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.innerJoin" id="apidoc.element.rethinkdbdash.term.prototype.innerJoin">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>innerJoin
        <span class="apidocSignatureSpan">(sequence, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">innerJoin = function (sequence, predicate) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, &#x27;innerJoin&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INNER_JOIN);
  var args = [this._query];
  args.push(new Term(this._r).expr(sequence)._query);
  args.push(new Term(this._r).expr(predicate)._wrap()._query);
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.insert" id="apidoc.element.rethinkdbdash.term.prototype.insert">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>insert
        <span class="apidocSignatureSpan">(documents, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (documents, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, &#x27;insert&#x27;, self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.INSERT);
  var args = [self, new Term(self._r).expr(documents)];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;returnChanges&#x27;) &#x26;&#x26; (key !== &#x27;durability&#x27;) &#x26;&#x26; (key !== &#x27;conflict&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `insert`&#x27;, self._query, &#x27;Available options are returnChanges
 &#x3c;bool&#x3e;, durability &#x3c;string&#x3e;, conflict &#x3c;string&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var pendingCallback = self._pendingCallback;
self._pendingCallback = null;
if (typeof pendingCallback === &#x27;function&#x27;) {
  pendingCallback();
}

var query = self._table.<span class="apidocCodeKeywordSpan">insert</span>(cache, self._insertOptions);
if (self._options.format === &#x27;primaryKey&#x27;) {
  query = query.do(function(result) {
    return self._r.branch(
      result(&#x27;errors&#x27;).eq(0),
      self._table.config()(&#x27;primary_key&#x27;).do(function(primaryKey) {
        return result(&#x27;changes&#x27;)(&#x27;new_val&#x27;)(primaryKey)
      }),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.insertAt" id="apidoc.element.rethinkdbdash.term.prototype.insertAt">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>insertAt
        <span class="apidocSignatureSpan">(index, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertAt = function (index, value) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, &#x27;insertAt&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INSERT_AT)
  var args = [this, new Term(this._r).expr(index), new Term(this._r).expr(value)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.intersects" id="apidoc.element.rethinkdbdash.term.prototype.intersects">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>intersects
        <span class="apidocSignatureSpan">(geometry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersects = function (geometry) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;intersects&#x27;, this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.INTERSECTS);
  var args = [this, new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.isEmpty" id="apidoc.element.rethinkdbdash.term.prototype.isEmpty">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;isEmpty&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.IS_EMPTY)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.january" id="apidoc.element.rethinkdbdash.term.prototype.january">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>january
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">january = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.JANUARY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.js" id="apidoc.element.rethinkdbdash.term.prototype.js">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>js
        <span class="apidocSignatureSpan">(arg, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">js = function (arg, options) {
  this._noPrefix(this, &#x27;js&#x27;);
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, &#x27;js&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.JAVASCRIPT)
  var args = [new Term(this._r).expr(arg)];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.json" id="apidoc.element.rethinkdbdash.term.prototype.json">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>json
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (json) {
  this._noPrefix(this, &#x27;json&#x27;);
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;info&#x27;, this);
  }
<span class="apidocCodeCommentSpan">  /*
  if ((/\\u0000/.test(json)) || (/\0/.test(json))) {
    this._error = new Error.ReqlDriverError(&#x27;The null character is currently not supported by RethinkDB&#x27;);
  }
  */
</span>  var term = new Term(this._r);
  term._query.push(termTypes.JSON);

  var args = [new Term(this._r).expr(json)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.july" id="apidoc.element.rethinkdbdash.term.prototype.july">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>july
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">july = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.JULY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.june" id="apidoc.element.rethinkdbdash.term.prototype.june">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>june
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">june = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.JUNE);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.keys" id="apidoc.element.rethinkdbdash.term.prototype.keys">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keys = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;keys&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.KEYS)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if ((index === 0) &#x26;&#x26; ((father == null) || (!nonPrefix[father[0]]))) carify(result, &#x27;r.expr(&#x27;, underline)

if (typeof term === &#x27;string&#x27; ) {
  carify(result, &#x27;&#x22;&#x27;+term+&#x27;&#x22;&#x27;, underline);
}
else if (helper.isPlainObject(term)) {
  var totalKeys = Object.<span class="apidocCodeKeywordSpan">keys</span>(term).length;
  if (totalKeys === 0) {
    carify(result, &#x27;{}&#x27;, underline);
  }
  else {
    carify(result, &#x27;{\n&#x27;, underline);
    var countKeys = 0;
    var extraToRemove = options.extra;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.le" id="apidoc.element.rethinkdbdash.term.prototype.le">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>le
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">le = function (other) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;le&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.LE)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.limit" id="apidoc.element.rethinkdbdash.term.prototype.limit">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>limit
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">limit = function (value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;limit&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.LIMIT)
  var args = [this, new Term(this._r).expr(value)]
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.line" id="apidoc.element.rethinkdbdash.term.prototype.line">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">line = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  // Arity check is done by r.line
  this._noPrefix(this, &#x27;line&#x27;);

  var term = new Term(this._r);
  term._query.push(termTypes.LINE);

  var args = [];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.literal" id="apidoc.element.rethinkdbdash.term.prototype.literal">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>literal
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">literal = function (obj) {
  this._noPrefix(this, &#x27;literal&#x27;);
  // The test for arity is performed in r.literal

  var term = new Term(this._r);
  term._query.push(termTypes.LITERAL);
  if (arguments.length &#x3e; 0) {
    var args = [new Term(this._r).expr(obj)];
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.lt" id="apidoc.element.rethinkdbdash.term.prototype.lt">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>lt
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lt = function (other) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;lt&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.LT)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.map" id="apidoc.element.rethinkdbdash.term.prototype.map">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>map
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;map&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.MAP);
  var args = [];
  if (!Array.isArray(this._query) || (this._query.length &#x3e; 0)) {
    args.push(this);
  }
  for(var i=0; i&#x3c;_args.length-1; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  // Make sure that we don&#x27;t push undefined if no argument is passed to map,
  // in which case the server will handle the case and return an error.
  if (_args.length&#x3e; 0) {
    args.push(new Term(this._r).expr(_args[_args.length-1])._wrap())
  }
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



var dbName = util.uuid()
var tableName = util.uuid()

var query; // without `.run()`
//query = &#x27;r.table(&#x22;foo&#x22;).add(1).add(1).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22
;).add(&#x22;one-last-string&#x22;).<span class="apidocCodeKeywordSpan">map</span>( function(doc) { return r.expr([1,2,3,4,5,6,7
,8,9,10,11,12,13,14,15,16]).map(function(test) { return test(&#x22;b&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another
-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22
;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-
last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).
add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).mul(test(&#x22;b&#
x22;)).merge({ firstName: &#x22;xxxxxx&#x22;, lastName: &#x22;yyyy&#x22;, email: &#x22;xxxxx@yyyy.com&#x22;, phone: &#x22;xxx-xxx
-xxxx&#x22; }); }).add(2).map(function(doc) { return doc.add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#
x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one
-last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22
;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello
-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;) }); })&#x27;;
query = &#x27;r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })&#x27;;
Promise.coroutine(function* () {
  try {
yield r.dbCreate(dbName).run();
yield r.db(dbName).tableCreate(tableName).run();

var result = yield eval(query).run();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.march" id="apidoc.element.rethinkdbdash.term.prototype.march">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>march
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">march = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.MARCH);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.match" id="apidoc.element.rethinkdbdash.term.prototype.match">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>match
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (regex) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;match&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MATCH)
  var args = [this, new Term(this._r).expr(regex)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
else {
  if (self._closed === false) {
    if (self._stackSize &#x3c;= MAX_CALL_STACK) {
      self._next().then(resolve).error(function(error) {
        if ((error.message !== &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) &#x26;&#x26;
            (error.message.<span class="apidocCodeKeywordSpan">match</span>(/You cannot call `next` on a closed/) === null)) {
          reject(error);
        }
      });
    }
    else {
      setTimeout(function() {
        self._stackSize = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.max" id="apidoc.element.rethinkdbdash.term.prototype.max">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>max
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function (field) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, &#x27;max&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MAX)
  var args = [this];
  if (field !== undefined) {
    if (helper.isPlainObject(field)) {
      term._fillArgs(args);
      term._query.push(new Term(this._r).expr(translateOptions(field))._query);
    }
    else {
      args.push(new Term(this._r).expr(field)._wrap())
      term._fillArgs(args);
    }
  }
  else {
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.maxval" id="apidoc.element.rethinkdbdash.term.prototype.maxval">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>maxval
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxval = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.MAXVAL);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.may" id="apidoc.element.rethinkdbdash.term.prototype.may">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>may
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">may = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.MAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.merge" id="apidoc.element.rethinkdbdash.term.prototype.merge">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>merge
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (arg) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;merge&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.MERGE)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i])._wrap())
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



var dbName = util.uuid()
var tableName = util.uuid()

var query; // without `.run()`
//query = &#x27;r.table(&#x22;foo&#x22;).add(1).add(1).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22
;).add(&#x22;one-last-string&#x22;).map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test
) { return test(&#x22;b&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-
string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add
(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super
-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22
;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).mul(test(&#x22;b&#x22;)).<span class="apidocCodeKeywordSpan
">merge</span>({ firstName: &#x22;xxxxxx&#x22;, lastName: &#x22;yyyy&#x22;, email: &#x22;xxxxx@yyyy.com&#x22;, phone: &#x22;xxx-
xxx-xxxx&#x22; }); }).add(2).map(function(doc) { return doc.add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string
&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22
;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#
x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello
-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;) }); })&#x27;;
query = &#x27;r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })&#x27;;
Promise.coroutine(function* () {
  try {
yield r.dbCreate(dbName).run();
yield r.db(dbName).tableCreate(tableName).run();

var result = yield eval(query).run();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.min" id="apidoc.element.rethinkdbdash.term.prototype.min">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>min
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">min = function (field) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, &#x27;min&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MIN)
  var args = [this];
  if (field !== undefined) {
    if (helper.isPlainObject(field)) {
      term._fillArgs(args);
      term._query.push(new Term(this._r).expr(translateOptions(field))._query);
    }
    else {
      args.push(new Term(this._r).expr(field)._wrap());
      term._fillArgs(args);
    }
  }
  else {
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return result;
}
module.exports.splitCommaEqual = splitCommaEqual;

function xorBuffer(a, b) {
  var result = [];
  var len = Math.<span class="apidocCodeKeywordSpan">min</span>(a.length, b.length)
  for(var i=0; i&#x3c;len; i++) {
    result.push(a[i] ^ b[i]);
  }
  return new Buffer(result);
}
module.exports.xorBuffer = xorBuffer;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.minutes" id="apidoc.element.rethinkdbdash.term.prototype.minutes">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>minutes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minutes = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;minutes&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MINUTES)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.minval" id="apidoc.element.rethinkdbdash.term.prototype.minval">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>minval
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minval = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.MINVAL);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.mod" id="apidoc.element.rethinkdbdash.term.prototype.mod">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>mod
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mod = function (b) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;mod&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MOD)
  var args = [this, new Term(this._r).expr(b)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.monday" id="apidoc.element.rethinkdbdash.term.prototype.monday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>monday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.MONDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.month" id="apidoc.element.rethinkdbdash.term.prototype.month">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>month
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">month = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;month&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MONTH)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.mul" id="apidoc.element.rethinkdbdash.term.prototype.mul">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>mul
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mul = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;mul&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.MUL)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



var dbName = util.uuid()
var tableName = util.uuid()

var query; // without `.run()`
//query = &#x27;r.table(&#x22;foo&#x22;).add(1).add(1).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22
;).add(&#x22;one-last-string&#x22;).map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test
) { return test(&#x22;b&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-
string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add
(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super
-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22
;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).<span class="apidocCodeKeywordSpan">mul</span>(test(&#x22
;b&#x22;)).merge({ firstName: &#x22;xxxxxx&#x22;, lastName: &#x22;yyyy&#x22;, email: &#x22;xxxxx@yyyy.com&#x22;, phone: &#x22;xxx
-xxx-xxxx&#x22; }); }).add(2).map(function(doc) { return doc.add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string
&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22
;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#
x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello
-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;) }); })&#x27;;
query = &#x27;r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })&#x27;;
Promise.coroutine(function* () {
  try {
yield r.dbCreate(dbName).run();
yield r.db(dbName).tableCreate(tableName).run();

var result = yield eval(query).run();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.ne" id="apidoc.element.rethinkdbdash.term.prototype.ne">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ne
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ne = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;ne&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.NE)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.not" id="apidoc.element.rethinkdbdash.term.prototype.not">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">not = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;not&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.NOT)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.november" id="apidoc.element.rethinkdbdash.term.prototype.november">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>november
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">november = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.NOVEMBER);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.now" id="apidoc.element.rethinkdbdash.term.prototype.now">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>now
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">now = function () {
  this._noPrefix(this, &#x27;now&#x27;);

  var term = new Term(this._r);
  term._query.push(termTypes.NOW)
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.nth" id="apidoc.element.rethinkdbdash.term.prototype.nth">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>nth
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nth = function (value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;nth&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.NTH)
  var args = [this._query, new Term(this._r).expr(value)]
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.object" id="apidoc.element.rethinkdbdash.term.prototype.object">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>object
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">object = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._noPrefix(this, &#x27;object&#x27;);
  this._arityRange(_args, 0, Infinity, &#x27;object&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.OBJECT)
  var args = [];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.october" id="apidoc.element.rethinkdbdash.term.prototype.october">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>october
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">october = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.OCTOBER);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.offsetsOf" id="apidoc.element.rethinkdbdash.term.prototype.offsetsOf">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>offsetsOf
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">offsetsOf = function (predicate) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;indexesOf&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.OFFSETS_OF)
  var args = [this, new Term(this._r).expr(predicate)._wrap()];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.or" id="apidoc.element.rethinkdbdash.term.prototype.or">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>or
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">or = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.OR)
  var args = [];
  if (!Array.isArray(this._query) || (this._query.length &#x3e; 0)) {
    args.push(this);
  }
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.orderBy" id="apidoc.element.rethinkdbdash.term.prototype.orderBy">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>orderBy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">orderBy = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;orderBy&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.ORDER_BY);

  var args = [this];
  for(var i=0; i&#x3c;_args.length-1; i++) {
    if ((_args[i] instanceof Term) &#x26;&#x26;
        ((_args[i]._query[0] === termTypes.DESC) || (_args[i]._query[0] === termTypes.ASC))) {
      args.push(new Term(this._r).expr(_args[i]))
    }
    else {
      args.push(new Term(this._r).expr(_args[i])._wrap())
    }
  }
  // We actually don&#x27;t need to make the difference here, but...
  if ((_args.length &#x3e; 0) &#x26;&#x26; (helper.isPlainObject(_args[_args.length-1])) &#x26;&#x26; (_args[_args.length-1].index !== undefined)) {
    term._fillArgs(args);
    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);
  }
  else {
    if ((_args[_args.length-1] instanceof Term) &#x26;&#x26;
      ((_args[_args.length-1]._query[0] === termTypes.DESC) || (_args[_args.length-1]._query[0] === termTypes.ASC))) {
      args.push(new Term(this._r).expr(_args[_args.length-1]))
    }
    else {
      args.push(new Term(this._r).expr(_args[_args.length-1])._wrap())
    }
    term._fillArgs(args);
  }
  return term;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.outerJoin" id="apidoc.element.rethinkdbdash.term.prototype.outerJoin">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>outerJoin
        <span class="apidocSignatureSpan">(sequence, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outerJoin = function (sequence, predicate) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, &#x27;outerJoin&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.OUTER_JOIN);
  var args = [this];
  args.push(new Term(this._r).expr(sequence));
  args.push(new Term(this._r).expr(predicate)._wrap());
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.pluck" id="apidoc.element.rethinkdbdash.term.prototype.pluck">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>pluck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pluck = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;pluck&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.PLUCK)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.point" id="apidoc.element.rethinkdbdash.term.prototype.point">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>point
        <span class="apidocSignatureSpan">(longitude, latitude)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">point = function (longitude, latitude) {
  // Arity check is done by r.point
  this._noPrefix(this, &#x27;point&#x27;);

  var term = new Term(this._r);
  term._query.push(termTypes.POINT);
  var args = [new Term(this._r).expr(longitude), new Term(this._r).expr(latitude)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.polygon" id="apidoc.element.rethinkdbdash.term.prototype.polygon">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>polygon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">polygon = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  // Arity check is done by r.polygon
  this._noPrefix(this, &#x27;polygon&#x27;);

  var term = new Term(this._r);
  term._query.push(termTypes.POLYGON);

  var args = [];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.polygonSub" id="apidoc.element.rethinkdbdash.term.prototype.polygonSub">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>polygonSub
        <span class="apidocSignatureSpan">(geometry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">polygonSub = function (geometry) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;polygonSub&#x27;, this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.POLYGON_SUB);
  var args = [this, new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.prepend" id="apidoc.element.rethinkdbdash.term.prototype.prepend">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>prepend
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function (value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;prepend&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.PREPEND)
  var args = [this, new Term(this._r).expr(value)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.random" id="apidoc.element.rethinkdbdash.term.prototype.random">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>random
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">random = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  var self = this;
  self._noPrefix(this, &#x27;random&#x27;);
  self._arityRange(_args, 0, 3, &#x27;random&#x27;, self);

  var term = new Term(self._r);
  term._query.push(termTypes.RANDOM);

  var args = [];
  for(var i=0; i&#x3c;_args.length-1; i++) {
    args.push(new Term(self._r).expr(_args[i]))
  }
  if (_args.length &#x3e; 0) {
    if (helper.isPlainObject(_args[_args.length-1])) {
      helper.loopKeys(_args[_args.length-1], function(obj, key) {
        if (key !== &#x27;float&#x27;) {
          throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `random`&#x27;, self._query, &#x27;Available option is float: &#x3c;
boolean&#x3e;&#x27;);
        }
      });
      term._fillArgs(args);
      term._query.push(new Term(self._r).expr(translateOptions(_args[_args.length-1]))._query);
    }
    else {
      args.push(new Term(self._r).expr(_args[_args.length-1]))
      term._fillArgs(args);
    }
  }
  else {
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     for(var i=0; i&#x3c;self.options.buffer; i++) {
       if (self.getLength() &#x3c; self.options.max) {
         self.createConnection();
       }
     }
   }
 }, 0);
 this.id = Math.floor(Math.<span class="apidocCodeKeywordSpan">random</span>()*100000);
 this._log(&#x27;Creating a pool connected to &#x27;+this.getAddress());
}

util.inherits(Pool, events.EventEmitter);
/*
* Events:
*  - draining // when `drain` is called
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.range" id="apidoc.element.rethinkdbdash.term.prototype.range">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>range
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">range = function (start, end) {
  this._noPrefix(this, &#x27;range&#x27;);
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, &#x27;r.range&#x27;, this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.RANGE);
  var args = [];
  args.push(new Term(this._r).expr(start));
  if (end !== undefined) {
    args.push(new Term(this._r).expr(end));
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.rebalance" id="apidoc.element.rethinkdbdash.term.prototype.rebalance">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>rebalance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rebalance = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;rebalance&#x27;, this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.REBALANCE);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var dbName = util.uuid()
var tableName = util.uuid()

var query; // without `.run()`
//query = &#x27;r.table(&#x22;foo&#x22;).add(1).add(1).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22
;).add(&#x22;one-last-string&#x22;).map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test
) { return test(&#x22;b&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-
string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add
(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super
-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22
;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).mul(test(&#x22;b&#x22;)).merge({ firstName: &#x22;xxxxxx
&#x22;, lastName: &#x22;yyyy&#x22;, email: &#x22;xxxxx@yyyy.com&#x22;, phone: &#x22;xxx-xxx-xxxx&#x22; }); }).add(2).map(function
(doc) { return doc.add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).
add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super
-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22
;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another
-long-string&#x22;).add(&#x22;one-last-string&#x22;) }); })&#x27;;
query = &#x27;r.db(dbName).table(tableName).<span class="apidocCodeKeywordSpan">rebalance</span>().do(function(x) { return x.add
(4) })&#x27;;
Promise.coroutine(function* () {
  try {
yield r.dbCreate(dbName).run();
yield r.db(dbName).tableCreate(tableName).run();

var result = yield eval(query).run();
throw new Error(&#x22;Should have thrown an error&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.reconfigure" id="apidoc.element.rethinkdbdash.term.prototype.reconfigure">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>reconfigure
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconfigure = function (config) {
  var self = this;
  if (self._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arity(_args, 1, &#x27;reconfigure&#x27;, self);
  }
  var term = new Term(self._r);
  term._query.push(termTypes.RECONFIGURE);

  var args = [this];
  term._fillArgs(args);
  if (helper.isPlainObject(config)) {
    helper.loopKeys(config, function(obj, key) {
      if ((key !== &#x27;shards&#x27;) &#x26;&#x26; (key !== &#x27;replicas&#x27;) &#x26;&#x26;
        (key !== &#x27;dryRun&#x27;) &#x26;&#x26; (key !== &#x27;primaryReplicaTag&#x27;) &#x26;&#x26;
        (key !== &#x27;nonvotingReplicaTags&#x27;) &#x26;&#x26; (key !== &#x27;emergencyRepair&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `reconfigure`&#x27;, self._query, &#x27;Available options are shards
: &#x3c;number&#x3e;, replicas: &#x3c;number&#x3e;, primaryReplicaTag: &#x3c;object&#x3e;, dryRun &#x3c;boolean&#x3e;, emergencyRepair: &#x3c;string&#x3e;, nonvotingReplicaTags: &#x3c;
array&#x3c;string&#x3e;&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(config))._query);
  }
  else {
    throw new Error.ReqlDriverError(&#x27;First argument of `reconfigure` must be an object&#x27;);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.reduce" id="apidoc.element.rethinkdbdash.term.prototype.reduce">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>reduce
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reduce = function (func) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;reduce&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.REDUCE)
  var args = [this, new Term(this._r).expr(func)._wrap()];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.replace" id="apidoc.element.rethinkdbdash.term.prototype.replace">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>replace
        <span class="apidocSignatureSpan">(newValue, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (newValue, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, &#x27;replace&#x27;, self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.REPLACE);
  var args = [self, new Term(self._r).expr(newValue)._wrap()];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;returnChanges&#x27;) &#x26;&#x26; (key !== &#x27;durability&#x27;) &#x26;&#x26; (key !== &#x27;nonAtomic&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `replace`&#x27;, self._query, &#x27;Available options are returnChanges
 &#x3c;bool&#x3e;, durability &#x3c;string&#x3e;, nonAtomic &#x3c;bool&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  else {
    carify(result, &#x27;&#x27;+term, underline);
  }

  if ((index === 0) &#x26;&#x26; ((father == null) || (!nonPrefix[father[0]]))) carify(result, &#x27;)&#x27;, underline);

  if (underline) result.car = result.str.<span class="apidocCodeKeywordSpan">replace</span>(/./g, &#x27;^&#x27;);

  return result;
},
TABLE: function(term, index, father, frames, options) {
  var result = {
    str: &#x27;&#x27;,
    car: &#x27;&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.round" id="apidoc.element.rethinkdbdash.term.prototype.round">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>round
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">round = function () {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, &#x27;round&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.ROUND)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.row" id="apidoc.element.rethinkdbdash.term.prototype.row">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>row
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">row = function () {
  this._noPrefix(this, &#x27;row&#x27;);
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;r.row&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.IMPLICIT_VAR)
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.run" id="apidoc.element.rethinkdbdash.term.prototype.run">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>run
        <span class="apidocSignatureSpan">(connection, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (connection, options, callback) {
  var self = this;

  if (self._error != null) {
    var error = new Error.ReqlRuntimeError(self._error, self._query, {b: self._frames});
    return Promise.reject(error);
  }

  if (helper.isPlainObject(connection) &#x26;&#x26; (typeof connection._isConnection === &#x27;function&#x27;) &#x26;&#x26; (connection._isConnection() === true
)) {
    if (typeof options === &#x27;function&#x27;) {
      callback = options;
      options = {};
    }
    else {
      if (!helper.isPlainObject(options)) options = {};
    }

    if (connection._isOpen() !== true) {
      return new Promise(function(resolve, reject) {
        reject(new Error.ReqlDriverError(&#x27;`run` was called with a closed connection&#x27;, self._query).setOperational());
      });
    }
    var p = new Promise(function(resolve, reject) {
      var token = connection._getToken();

      var query = [protodef.Query.QueryType.START];
      query.push(self._query);

      var _options = {};
      var sendOptions = false;
      if (connection.db != null) {
        sendOptions = true;
        _options.db = self._r.db(connection.db)._query;
      }

      if (self._r.arrayLimit != null) {
        sendOptions = true;
        _options[self._translateArgs[&#x27;arrayLimit&#x27;]] = self._r.arrayLimit;
      };


      var keepGoing = true; // we need it just to avoir calling resolve/reject multiple times
      helper.loopKeys(options, function(options, key) {
        if (keepGoing === true) {
          if ((key === &#x27;readMode&#x27;) || (key === &#x27;durability&#x27;) || (key === &#x27;db&#x27;) ||
            (key === &#x27;noreply&#x27;) || (key === &#x27;arrayLimit&#x27;) || (key === &#x27;profile&#x27;) ||
            (key === &#x27;minBatchRows&#x27;) || (key === &#x27;maxBatchRows&#x27;) || (key === &#x27;maxBatchBytes&#x27;) ||
            (key === &#x27;maxBatchSeconds&#x27;) || (key === &#x27;firstBatchScaledownFactor&#x27;)) {

            sendOptions = true;
            if (key === &#x27;db&#x27;) {
              _options[key] = self._r.db(options[key])._query;
            }
            else if (self._translateArgs.hasOwnProperty(key)) {
              _options[self._translateArgs[key]] = new Term(self._r).expr(options[key])._query;
            }
            else {
              _options[key] = new Term(self._r).expr(options[key])._query;
            }
          }
          else if ((key !== &#x27;timeFormat&#x27;) &#x26;&#x26; (key !== &#x27;groupFormat&#x27;) &#x26;&#x26;
              (key !== &#x27;binaryFormat&#x27;) &#x26;&#x26; (key !== &#x27;cursor&#x27;) &#x26;&#x26;
              (key !== &#x27;readable&#x27;) &#x26;&#x26; (key !== &#x27;writable&#x27;) &#x26;&#x26;
              (key !== &#x27;transform&#x27;) &#x26;&#x26; (key !== &#x27;stream&#x27;) &#x26;&#x26;
              (key !== &#x27;highWaterMark&#x27;)) {
            reject(new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `run`. Available options are readMode &#x3c;string&#x3e;, durability
 &#x3c;string&#x3e;, noreply &#x3c;bool&#x3e;, timeFormat &#x3c;string&#x3e;, groupFormat: &#x3c;string&#x3e;, profile &#x3c;bool&#x3e;, binaryFormat &#x3c;bool&#x3e;, cursor &#x3c;bool&#x3e;, stream
 &#x3c;bool&#x3e;&#x27;));
            keepGoing = false;
          }
        }
      });

      if (keepGoing === false) {
        connection.emit(&#x27;release&#x27;);
        return // The promise was rejected in the loopKeys
      }

      if (sendOptions === true) {
        query.push(_options);
      }
      connection._send(query, token, resolve, reject, self._query, options);
    }).nodeify(callback);
  }
  else {
    var poolMaster = self._r.getPoolMaster(); // if self._r is defined, so is self._r.getPool()
    if (!poolMaster) {
      throw new Error.ReqlDriverError(&#x27;`run` was called without a connection and no pool has been created&#x27;, self._query);
    }
    else {
      if (typeof connection === &#x27;function&#x27;) {
        // run(callback);
        callback = connection;
        options = {};
      }
      else if (helper.isPlainObject(connection)) {
        // run(options[, callback])
        callback = options;
        options = connection;
      }
      else {
        options = {};
      }


      var p = new Promise(function(resolve, reject) {
        poolMaster.getConnection().then(function(connection) {
          var token = connection._getToken();
          var query = [protodef.Query.QueryType.START];
          query.push(self._query);

          var _options = {};
          var send ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Connections are managed by the driver with an efficient connection pool.
Once you have imported the driver, you can immediately run queries,
you don&#x27;t need to call `r.connect`, or pass a connection to `run`.

```js
var r = require(&#x27;rethinkdbdash&#x27;)();
r.table(&#x27;users&#x27;).get(&#x27;orphee@gmail.com&#x27;).<span class="apidocCodeKeywordSpan">run</span>().then(function(user
) {
  // ...
}).error(handleError)
```

- Cursors are coerced to arrays by default

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.sample" id="apidoc.element.rethinkdbdash.term.prototype.sample">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sample
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sample = function (size) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;sample&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SAMPLE)
  var args = [this, new Term(this._r).expr(size)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.saturday" id="apidoc.element.rethinkdbdash.term.prototype.saturday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>saturday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saturday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.SATURDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.seconds" id="apidoc.element.rethinkdbdash.term.prototype.seconds">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>seconds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seconds = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;seconds&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SECONDS)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.september" id="apidoc.element.rethinkdbdash.term.prototype.september">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>september
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">september = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.SEPTEMBER);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.setDifference" id="apidoc.element.rethinkdbdash.term.prototype.setDifference">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setDifference
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDifference = function (other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;setDifference&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SET_DIFFERENCE)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.setInsert" id="apidoc.element.rethinkdbdash.term.prototype.setInsert">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setInsert
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setInsert = function (other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;setInsert&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SET_INSERT)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.setIntersection" id="apidoc.element.rethinkdbdash.term.prototype.setIntersection">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setIntersection
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setIntersection = function (other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;setIntersection&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SET_INTERSECTION)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.setUnion" id="apidoc.element.rethinkdbdash.term.prototype.setUnion">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>setUnion
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setUnion = function (other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;setUnion&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SET_UNION)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.skip" id="apidoc.element.rethinkdbdash.term.prototype.skip">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>skip
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function (value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;skip&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SKIP)
  var args = [this, new Term(this._r).expr(value)]
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.slice" id="apidoc.element.rethinkdbdash.term.prototype.slice">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>slice
        <span class="apidocSignatureSpan">(start, end, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (start, end, options) {
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 3, &#x27;slice&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SLICE);

  var args = [];
  args.push(this);
  args.push(new Term(this._r).expr(start));

  if ((end !== undefined) &#x26;&#x26; (options !== undefined)) {
    args.push(new Term(this._r).expr(end));
    term._fillArgs(args);
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  else if ((end !== undefined) &#x26;&#x26; (options === undefined)) {
    if (helper.isPlainObject(end) === false) {
      args.push(new Term(this._r).expr(end));
      term._fillArgs(args);
    }
    else {
      term._fillArgs(args);
      term._query.push(new Term(this._r).expr(translateOptions(end))._query);
    }
  }
  else { // end and options are both undefined
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return;
}
self.buffer = Buffer.concat([self.buffer, buffer]);

if (self.open == false) {
  for(var i=0; i&#x3c;self.buffer.length; i++) {
    if (self.buffer[i] === 0) {
      var messageServerStr = self.buffer.<span class="apidocCodeKeywordSpan">slice</span>(0, i).toString();
      self.buffer = self.buffer.slice(i+1); // +1 to remove the null byte
      try {
        var messageServer = JSON.parse(messageServerStr);
      } catch(error) {
        self._abort();
        reject(new Err.ReqlDriverError(&#x27;Could not parse the message sent by the server : \&#x27;&#x27;+messageServerStr+&#x27
;\&#x27;&#x27;).setOperational());
        return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.spliceAt" id="apidoc.element.rethinkdbdash.term.prototype.spliceAt">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>spliceAt
        <span class="apidocSignatureSpan">(index, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spliceAt = function (index, array) {
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, &#x27;spliceAt&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SPLICE_AT)
  var args = [this, new Term(this._r).expr(index), new Term(this._r).expr(array)];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.split" id="apidoc.element.rethinkdbdash.term.prototype.split">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>split
        <span class="apidocSignatureSpan">(separator, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (separator, max) {
  if (this._fastArityRange(arguments.length, 0, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 2, &#x27;split&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SPLIT)
  var args = [this];
  if (separator !== undefined) {
    args.push(new Term(this._r).expr(separator))
    if (max !== undefined) {
      args.push(new Term(this._r).expr(max))
    }
  }
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

frames = frames.b;
if (frames) this.frames = frames.slice(0);
//this.frames = JSON.stringify(frames, null, 2);

var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});

var queryLines = backtrace.str.<span class="apidocCodeKeywordSpan">split</span>(&#x27;\n&#x27;);
var carrotLines = backtrace.car.split(&#x27;\n&#x27;);

for(var i=0; i&#x3c;queryLines.length; i++) {
  this.message += queryLines[i]+&#x27;\n&#x27;;
  if (carrotLines[i].match(/\^/)) {
    var pos = queryLines[i].match(/[^\s]/);
    if ((pos) &#x26;&#x26; (pos.index)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.status" id="apidoc.element.rethinkdbdash.term.prototype.status">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>status
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">status = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;status&#x27;, this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.STATUS);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.sub" id="apidoc.element.rethinkdbdash.term.prototype.sub">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sub = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;sub&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.SUB)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.sum" id="apidoc.element.rethinkdbdash.term.prototype.sum">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sum
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sum = function (field) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, &#x27;sum&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SUM);
  var args = [this];
  if (field !== undefined) {
    args.push(new Term(this._r).expr(field)._wrap())
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.sunday" id="apidoc.element.rethinkdbdash.term.prototype.sunday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sunday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sunday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.SUNDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.sync" id="apidoc.element.rethinkdbdash.term.prototype.sync">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>sync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sync = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;sync&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SYNC)
  var args = [this._query];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.table" id="apidoc.element.rethinkdbdash.term.prototype.table">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>table
        <span class="apidocSignatureSpan">(table, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">table = function (table, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, &#x27;table&#x27;, self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.TABLE)

  var args = [];
  if (Array.isArray(self._query) &#x26;&#x26; (self._query.length &#x3e; 0)) {
    args.push(self);
  }
  args.push(new Term(self._r).expr(table))
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== &#x27;readMode&#x27;) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `table`&#x27;, self._query, &#x27;Available option is readMode &#x3c;
string&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Connections are managed by the driver with an efficient connection pool.
Once you have imported the driver, you can immediately run queries,
you don&#x27;t need to call `r.connect`, or pass a connection to `run`.

```js
var r = require(&#x27;rethinkdbdash&#x27;)();
r.<span class="apidocCodeKeywordSpan">table</span>(&#x27;users&#x27;).get(&#x27;orphee@gmail.com&#x27;).run().then(function(user
) {
  // ...
}).error(handleError)
```

- Cursors are coerced to arrays by default

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.tableCreate" id="apidoc.element.rethinkdbdash.term.prototype.tableCreate">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tableCreate
        <span class="apidocSignatureSpan">(table, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tableCreate = function (table, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, &#x27;tableCreate&#x27;, self);
  }


  var term = new Term(self._r);
  term._query.push(termTypes.TABLE_CREATE)

  var args = [];
  if (Array.isArray(self._query) &#x26;&#x26; (self._query.length &#x3e; 0)) {
    args.push(self); // Push db
  }
  args.push(new Term(self._r).expr(table))
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    // Check for non valid key
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;primaryKey&#x27;)
          &#x26;&#x26; (key !== &#x27;durability&#x27;)
          &#x26;&#x26; (key !== &#x27;shards&#x27;)
          &#x26;&#x26; (key !== &#x27;replicas&#x27;)
          &#x26;&#x26; (key !== &#x27;primaryReplicaTag&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `tableCreate`&#x27;, self._query, &#x27;Available options are primaryKey
 &#x3c;string&#x3e;, durability &#x3c;string&#x3e;, shards &#x3c;number&#x3e;, replicas &#x3c;number/object&#x3e;, primaryReplicaTag &#x3c;object&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var query; // without `.run()`
//query = &#x27;r.table(&#x22;foo&#x22;).add(1).add(1).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22
;).add(&#x22;one-last-string&#x22;).map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test
) { return test(&#x22;b&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-
string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add
(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super
-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22
;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).mul(test(&#x22;b&#x22;)).merge({ firstName: &#x22;xxxxxx
&#x22;, lastName: &#x22;yyyy&#x22;, email: &#x22;xxxxx@yyyy.com&#x22;, phone: &#x22;xxx-xxx-xxxx&#x22; }); }).add(2).map(function
(doc) { return doc.add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).
add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super
-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22
;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another
-long-string&#x22;).add(&#x22;one-last-string&#x22;) }); })&#x27;;
query = &#x27;r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })&#x27;;
Promise.coroutine(function* () {
try {
  yield r.dbCreate(dbName).run();
  yield r.db(dbName).<span class="apidocCodeKeywordSpan">tableCreate</span>(tableName).run();

  var result = yield eval(query).run();
  throw new Error(&#x22;Should have thrown an error&#x22;);
}
catch(e) {
  console.log(e.message);
  console.log(&#x27;&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.tableDrop" id="apidoc.element.rethinkdbdash.term.prototype.tableDrop">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tableDrop
        <span class="apidocSignatureSpan">(table)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tableDrop = function (table) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, &#x27;tableDrop&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TABLE_DROP)

  var args = [];
  if (!Array.isArray(this._query) || (this._query.length &#x3e; 0)) {
    args.push(this); // push db
  }
  args.push(new Term(this._r).expr(table))
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.tableList" id="apidoc.element.rethinkdbdash.term.prototype.tableList">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tableList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tableList = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;tableList&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TABLE_LIST);

  var args = [];
  if (!Array.isArray(this._query) || (this._query.length &#x3e; 0)) {
    args.push(this);
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.then" id="apidoc.element.rethinkdbdash.term.prototype.then">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>then
        <span class="apidocSignatureSpan">(resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (resolve, reject) {
  return this.run().then(resolve, reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Connections are managed by the driver with an efficient connection pool.
Once you have imported the driver, you can immediately run queries,
you don&#x27;t need to call `r.connect`, or pass a connection to `run`.

```js
var r = require(&#x27;rethinkdbdash&#x27;)();
r.table(&#x27;users&#x27;).get(&#x27;orphee@gmail.com&#x27;).run().<span class="apidocCodeKeywordSpan">then</span>(function(user
) {
  // ...
}).error(handleError)
```

- Cursors are coerced to arrays by default

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.thursday" id="apidoc.element.rethinkdbdash.term.prototype.thursday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>thursday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thursday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.THURSDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.time" id="apidoc.element.rethinkdbdash.term.prototype.time">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>time
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._noPrefix(this, &#x27;time&#x27;);
  // Special check for arity
  var foundArgs = false;
  for(var i=0; i&#x3c;_args.length; i++) {
    if ((_args[i] instanceof Term) &#x26;&#x26; (_args[i]._query[0] === termTypes.ARGS)) {
      foundArgs = true;
      break;
    }
  }
  if (foundArgs === false) {
    if ((_args.length !== 4) &#x26;&#x26; (_args.length !== 7)) {
      throw new Error.ReqlDriverError(&#x27;`r.time` called with &#x27;+_args.length+&#x27; argument&#x27;+((_args.length&#x3e;1)?&#x27;s&#x27;:&#x27;&#x27;), null, &#x27;`r.time
` takes 4 or 7 arguments&#x27;);
    }
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TIME)
  var args = [];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.timeOfDay" id="apidoc.element.rethinkdbdash.term.prototype.timeOfDay">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>timeOfDay
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeOfDay = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;timeOfDay&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TIME_OF_DAY)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.timezone" id="apidoc.element.rethinkdbdash.term.prototype.timezone">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>timezone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timezone = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;timezone&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TIMEZONE)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toEpochTime" id="apidoc.element.rethinkdbdash.term.prototype.toEpochTime">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toEpochTime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toEpochTime = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;toEpochTime&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TO_EPOCH_TIME)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toGeojson" id="apidoc.element.rethinkdbdash.term.prototype.toGeojson">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toGeojson
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toGeojson = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;toGeojson&#x27;, this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.TO_GEOJSON);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toISO8601" id="apidoc.element.rethinkdbdash.term.prototype.toISO8601">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toISO8601
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toISO8601 = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;toISO8601&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TO_ISO8601)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toJSON" id="apidoc.element.rethinkdbdash.term.prototype.toJSON">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;toJSON&#x27;, this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.TO_JSON_STRING);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toJsonString" id="apidoc.element.rethinkdbdash.term.prototype.toJsonString">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toJsonString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJsonString = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;toJSON&#x27;, this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.TO_JSON_STRING);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toStream" id="apidoc.element.rethinkdbdash.term.prototype.toStream">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toStream
        <span class="apidocSignatureSpan">(connection, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toStream = function (connection, options) {
  if (helper.isPlainObject(connection) &#x26;&#x26; (typeof connection._isConnection === &#x27;function&#x27;) &#x26;&#x26; (connection._isConnection() === true
)) {
    if (helper.isPlainObject(options) === false) {
      options = {};
    }
    if (options.readable === true) {
      return this._toReadableStream(connection, options);
    }
    else if (options.writable === true) {
      return this._toWritableStream(connection, options);
    }
    else if (options.transform === true) {
      return this._toTransformStream(connection, options);
    }
    else {
      return this._toReadableStream(connection, options);
    }
  }
  else {
    options = connection;
    if (helper.isPlainObject(options) === false) {
      options = {};
    }
    if (options.readable === true) {
      return this._toReadableStream(options);
    }
    else if (options.writable === true) {
      return this._toWritableStream(options);
    }
    else if (options.transform === true) {
      return this._toTransformStream(options);
    }
    else {
      return this._toReadableStream(options);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
synchronously returned with the `toStream([connection])` method.

```js
var fs = require(&#x27;fs&#x27;);
var file = fs.createWriteStream(&#x27;file.txt&#x27;);

var r = require(&#x27;rethinkdbdash&#x27;)();
r.table(&#x27;users&#x27;).<span class="apidocCodeKeywordSpan">toStream</span>()
  .on(&#x27;error&#x27;, console.log)
  .pipe(file)
  .on(&#x27;error&#x27;, console.log)
  .on(&#x27;end&#x27;, function() {
    r.getPool().drain();
  });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.toString" id="apidoc.element.rethinkdbdash.term.prototype.toString">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return Error.generateBacktrace(this._query, 0, null, [], {indent: 0, extra: 0}).str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.connection.on(&#x27;error&#x27;, function(error) {
  self.emit(&#x27;error&#x27;, error);
});

var versionBuffer = new Buffer(4)
versionBuffer.writeUInt32LE(protodef.VersionDummy.Version.V1_0, 0)

self.randomString = new Buffer(crypto.randomBytes(18)).<span class="apidocCodeKeywordSpan">toString</span>(&#x27;base64&#x27;)
var authBuffer = new Buffer(JSON.stringify({
  protocol_version: PROTOCOL_VERSION,
  authentication_method: AUTHENTIFICATION_METHOD,
  authentication: &#x22;n,,n=&#x22; + self.user + &#x22;,r=&#x22; + self.randomString
}));

helper.tryCatch(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.tuesday" id="apidoc.element.rethinkdbdash.term.prototype.tuesday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>tuesday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tuesday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.TUESDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.typeOf" id="apidoc.element.rethinkdbdash.term.prototype.typeOf">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>typeOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeOf = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;typeOf&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TYPE_OF);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.ungroup" id="apidoc.element.rethinkdbdash.term.prototype.ungroup">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>ungroup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ungroup = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;ungroup&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.UNGROUP)
  var args = [this._query];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.union" id="apidoc.element.rethinkdbdash.term.prototype.union">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>union
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">union = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.UNION)
  var args = [];
  if (!Array.isArray(this._query) || (this._query.length &#x3e; 0)) {
    args.push(this);
  }
  for(var i=0; i&#x3c;_args.length-1; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  if ((_args.length &#x3e; 1) &#x26;&#x26; (helper.isPlainObject(_args[_args.length-1])) &#x26;&#x26; (_args[_args.length-1].interleave !== undefined)) {
    term._fillArgs(args);
    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);
  }
  else if (_args.length &#x3e; 0) {
    args.push(new Term(this._r).expr(_args[_args.length-1]))
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.resetBufferParameters();
}

//  Create the feed on server_status and bind the listener to the feed
PoolMaster.prototype.fetchServers = function(useSeeds) {
var self = this;
var query = self._r.db(&#x27;rethinkdb&#x27;).table(&#x27;server_status&#x27;)
    .<span class="apidocCodeKeywordSpan">union</span>([SEPARATOR])
    .union(self._r.db(&#x27;rethinkdb&#x27;).table(&#x27;server_status&#x27;).changes())
// In case useSeeds is true, we rotate through all the seeds + the pool master
if (!useSeeds || self._seed === self._servers.length) {
  if (useSeeds &#x26;&#x26; self._seed === self._servers.length) {
    // We increase the back off only when we went through all the seeds
    self._consecutiveFails++;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.upcase" id="apidoc.element.rethinkdbdash.term.prototype.upcase">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>upcase
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">upcase = function (regex) {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;upcase&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.UPCASE)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.update" id="apidoc.element.rethinkdbdash.term.prototype.update">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>update
        <span class="apidocSignatureSpan">(newValue, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (newValue, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, &#x27;update&#x27;, self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.UPDATE);
  var args = [self, new Term(self._r).expr(newValue)._wrap()];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;returnChanges&#x27;) &#x26;&#x26; (key !== &#x27;durability&#x27;) &#x26;&#x26; (key !== &#x27;nonAtomic&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `update`&#x27;, self._query, &#x27;Available options are returnChanges
 &#x3c;bool&#x3e;, durability &#x3c;string&#x3e;, nonAtomic &#x3c;bool&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var bluebird = require(&#x27;bluebird&#x27;);
var r = require(&#x27;rethinkdbdash&#x27;)();

bluebird.coroutine(function*() {
  try {
    var result = yield r.table(&#x27;users&#x27;).get(&#x27;orphee@gmail.com&#x27;).<span class="apidocCodeKeywordSpan">update</
span>({name: &#x27;Michel&#x27;});
    assert.equal(result.errors, 0);
  } catch(err) {
    console.log(err);
  }
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.uuid" id="apidoc.element.rethinkdbdash.term.prototype.uuid">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>uuid
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uuid = function (str) {
  this._noPrefix(this, &#x27;uuid&#x27;);

  var term = new Term(this._r);
  term._query.push(termTypes.UUID)

  if (str !== undefined) {
    var args = [new Term(this._r).expr(str)];
    term._fillArgs(args);
  }
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var r = require(__dirname+&#x27;/../lib&#x27;)(config);
var util = require(__dirname+&#x27;/../test/util/common.js&#x27;);
var assert = require(&#x27;assert&#x27;);




var dbName = util.<span class="apidocCodeKeywordSpan">uuid</span>()
var tableName = util.uuid()

var query; // without `.run()`
//query = &#x27;r.table(&#x22;foo&#x22;).add(1).add(1).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22
;).add(&#x22;one-last-string&#x22;).map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test
) { return test(&#x22;b&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-
string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add
(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super
-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22
;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).mul(test(&#x22;b&#x22;)).merge({ firstName: &#x22;xxxxxx
&#x22;, lastName: &#x22;yyyy&#x22;, email: &#x22;xxxxx@yyyy.com&#x22;, phone: &#x22;xxx-xxx-xxxx&#x22; }); }).add(2).map(function
(doc) { return doc.add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).
add(&#x22;hello-super-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super
-long-string&#x22;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22
;).add(&#x22;another-long-string&#x22;).add(&#x22;one-last-string&#x22;).add(&#x22;hello-super-long-string&#x22;).add(&#x22;another
-long-string&#x22;).add(&#x22;one-last-string&#x22;) }); })&#x27;;
query = &#x27;r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })&#x27;;
Promise.coroutine(function* () {
try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.values" id="apidoc.element.rethinkdbdash.term.prototype.values">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;keys&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.VALUES)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.wait" id="apidoc.element.rethinkdbdash.term.prototype.wait">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>wait
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wait = function (options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 0, 1, &#x27;wait&#x27;, self);
  }
  var term = new Term(self._r);
  term._query.push(termTypes.WAIT);
  var args = [self];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== &#x27;waitFor&#x27;) &#x26;&#x26; (key !== &#x27;timeout&#x27;)) {
        throw new Error.ReqlDriverError(&#x27;Unrecognized option `&#x27;+key+&#x27;` in `wait`&#x27;, self._query, &#x27;Available options are waitFor: &#x3c;
string&#x3e;, timeout: &#x3c;number&#x3e;&#x27;);
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.wednesday" id="apidoc.element.rethinkdbdash.term.prototype.wednesday">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>wednesday
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wednesday = function () {
  var term = new Term(this._r);
  term._query.push(termTypes.WEDNESDAY);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.withFields" id="apidoc.element.rethinkdbdash.term.prototype.withFields">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>withFields
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withFields = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;withFields&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.WITH_FIELDS);
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);

  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.without" id="apidoc.element.rethinkdbdash.term.prototype.without">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>without
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">without = function () {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, &#x27;without&#x27;, this);

  var term = new Term(this._r);
  term._query.push(termTypes.WITHOUT)
  var args = [this];
  for(var i=0; i&#x3c;_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.year" id="apidoc.element.rethinkdbdash.term.prototype.year">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>year
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">year = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;year&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.YEAR)
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.term.prototype.zip" id="apidoc.element.rethinkdbdash.term.prototype.zip">
        function <span class="apidocSignatureSpan">rethinkdbdash.term.prototype.</span>zip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zip = function () {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i &#x3c; _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, &#x27;zip&#x27;, this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.ZIP);
  var args = [this];
  term._fillArgs(args);
  return term;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.transform_stream" id="apidoc.module.rethinkdbdash.transform_stream">module rethinkdbdash.transform_stream</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream.transform_stream" id="apidoc.element.rethinkdbdash.transform_stream.transform_stream">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>transform_stream
        <span class="apidocSignatureSpan">(table, options, connection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TransformStream(table, options, connection) {
  this._table = table;
  this._r = table._r;
  this._options = options;
  this._cache = [];
  this._pendingCallback = null;
  this._ended = false;
  this._inserting = false;
  this._delayed = false;
  this._connection = connection;
  this._highWaterMark = options.highWaterMark || 100;
  this._insertOptions = {};
  this._insertOptions.durability = options.durability || &#x27;hard&#x27;;
  this._insertOptions.conflict = options.conflict || &#x27;error&#x27;;
  this._insertOptions.returnChanges = options.returnChanges || true;

  // Internal option to run some tests
  if (options.debug === true) {
    this._sequence = [];
  }

  Transform.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream.super_" id="apidoc.element.rethinkdbdash.transform_stream.super_">
        function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === &#x27;function&#x27;)
      this._transform = options.transform;

    if (typeof options.flush === &#x27;function&#x27;)
      this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once(&#x27;prefinish&#x27;, function() {
    if (typeof this._flush === &#x27;function&#x27;)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.transform_stream.prototype" id="apidoc.module.rethinkdbdash.transform_stream.prototype">module rethinkdbdash.transform_stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream.prototype._flush" id="apidoc.element.rethinkdbdash.transform_stream.prototype._flush">
        function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_flush
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (done) {
  this._ended = true;
  if ((this._cache.length === 0) &#x26;&#x26; (this._inserting === false)) {
    done();
  }
  else { // this._inserting === true
    if (this._inserting === false) {
      this._flushCallback = done;
      this._insert();
    }
    else {
      this._flushCallback = done;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  reject(new Err.ReqlDriverError(&#x27;Failed to connect to &#x27;+self.host+&#x27;:&#x27;+self.port+&#x27; in less than &#x27;+
self.timeoutConnect+&#x27;s&#x27;).setOperational());
}, self.timeoutConnect*1000);

self.connection.on(&#x27;end&#x27;, function() {
  self.open = false;
  self.emit(&#x27;end&#x27;);
  // We got a FIN packet, so we&#x27;ll just flush
  self.<span class="apidocCodeKeywordSpan">_flush</span>();
});
self.connection.on(&#x27;close&#x27;, function() {
  // We emit end or close just once
  clearTimeout(self.timeoutOpen)
  clearInterval(self.pingIntervalId);
  self.connection.removeAllListeners();
  self.open = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream.prototype._insert" id="apidoc.element.rethinkdbdash.transform_stream.prototype._insert">
        function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_insert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_insert = function () {
  var self = this;
  self._inserting = true;

  var cache = self._cache;
  self._cache = [];

  if (Array.isArray(self._sequence)) {
    self._sequence.push(cache.length);
  }

  var pendingCallback = self._pendingCallback;
  self._pendingCallback = null;
  if (typeof pendingCallback === &#x27;function&#x27;) {
    pendingCallback();
  }

  var query = self._table.insert(cache, self._insertOptions);
  if (self._options.format === &#x27;primaryKey&#x27;) {
    query = query.do(function(result) {
      return self._r.branch(
        result(&#x27;errors&#x27;).eq(0),
        self._table.config()(&#x27;primary_key&#x27;).do(function(primaryKey) {
          return result(&#x27;changes&#x27;)(&#x27;new_val&#x27;)(primaryKey)
        }),
        result(self._r.error(result(&#x27;errors&#x27;).coerceTo(&#x27;STRING&#x27;).add(&#x27; errors returned. First error:\n&#x27;).add(result(&#x27;first_error
&#x27;))))
      )
    })
  }

  query.run(self._connection).then(function(result) {
    self._inserting = false;
    if (self._options.format === &#x27;primaryKey&#x27;) {
      for(var i=0; i&#x3c;result.length; i++) {
        self.push(result[i]);
      }
    }
    else {
      if (result.errors &#x3e; 0) {
        self._inserting = false;
        self.emit(&#x27;error&#x27;, new Error(&#x27;Failed to insert some documents:&#x27;+JSON.stringify(result, null, 2)));
      }
      else {
        if (self._insertOptions.returnChanges === true) {
          for(var i=0; i&#x3c;result.changes.length; i++) {
            self.push(result.changes[i].new_val);
          }
        }
      }
    }

    pendingCallback = self._pendingCallback
    self._pendingCallback = null;
    if (typeof pendingCallback === &#x27;function&#x27;) {
      // Mean that we can buffer more
      pendingCallback();
    }
    else if (self._ended !== true) {
      if (((((self._writableState.lastBufferedRequest === null) ||
          self._writableState.lastBufferedRequest.chunk === self._cache[self._cache.length-1])))
        &#x26;&#x26; (self._cache.length &#x3e; 0)) {
          self._insert();
      }
    }
    else if (self._ended === true) {
      if (self._cache.length &#x3e; 0) {
        self._insert();
      }
      else {
        if (typeof self._flushCallback === &#x27;function&#x27;) {
          self._flushCallback();
        }
        self.push(null);
      }
    }
  }).error(function(error) {
    self._inserting = false;
    self.emit(&#x27;error&#x27;, error);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  done();
}
else {
  if (this._inserting === false) {
    if (this._delayed === true) {
      // We have to flush
      this._delayed = false;
      this.<span class="apidocCodeKeywordSpan">_insert</span>();
      // Fill the buffer while we are inserting data
      done();
    }
    else {
      var self = this;
      this._delayed = true;
      setImmediate(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream.prototype._next" id="apidoc.element.rethinkdbdash.transform_stream.prototype._next">
        function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_next
        <span class="apidocSignatureSpan">(value, encoding, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_next = function (value, encoding, done) {
  if ((this._writableState.lastBufferedRequest != null) &#x26;&#x26; (this._writableState.lastBufferedRequest.chunk !== value)) {
    // There&#x27;s more data to buffer
    if (this._cache.length &#x3c; this._highWaterMark) {
      this._delayed = false;
      // Call done now, and more data will be put in the cache
      done();
    }
    else {
      if (this._inserting === false) {
        if (this._delayed === true) {
          // We have to flush
          this._delayed = false;
          this._insert();
          // Fill the buffer while we are inserting data
          done();
        }
        else {
          var self = this;
          this._delayed = true;
          setImmediate(function() {
            self._next(value, encoding, done);
          })
        }

      }
      else {
        // to call when we are dong inserting to keep buffering
        this._pendingCallback = done;
      }
    }
  }
  else { // We just pushed the last element in the internal buffer
    if (this._inserting === false) {
      if (this._delayed === true) {
        this._delayed = false;
        // to call when we are dong inserting to maybe flag the end
        this._insert();
        // We can call done now, because we have _flush to close the stream
        done();
      }
      else {
        var self = this;
        this._delayed = true;
        setImmediate(function() {
          self._next(value, encoding, done);
        })
      }
    }
    else {
      this._delayed = false;
      // There is nothing left in the internal buffer
      // But something is already inserting stuff.
      if (this._cache.length &#x3c; this._highWaterMark-1) {
        // Call done, to attempt to buffer more
        // This may trigger _flush
        //this._pendingCallback = done;
        done();
      }
      else {
        this._pendingCallback = done;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (typeof onFinish === &#x27;function&#x27;) {
    onFinish();
  }
}
else {
  if (self._closed === false) {
    if (self._stackSize &#x3c;= MAX_CALL_STACK) {
      self.<span class="apidocCodeKeywordSpan">_next</span>().then(resolve).error(function(error) {
        if ((error.message !== &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) &#x26;&#x26;
            (error.message.match(/You cannot call `next` on a closed/) === null)) {
          reject(error);
        }
      });
    }
    else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.transform_stream.prototype._transform" id="apidoc.element.rethinkdbdash.transform_stream.prototype._transform">
        function <span class="apidocSignatureSpan">rethinkdbdash.transform_stream.prototype.</span>_transform
        <span class="apidocSignatureSpan">(value, encoding, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (value, encoding, done) {
  this._cache.push(value);
  this._next(value, encoding, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.writable_stream" id="apidoc.module.rethinkdbdash.writable_stream">module rethinkdbdash.writable_stream</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.writable_stream.writable_stream" id="apidoc.element.rethinkdbdash.writable_stream.writable_stream">
        function <span class="apidocSignatureSpan">rethinkdbdash.</span>writable_stream
        <span class="apidocSignatureSpan">(table, options, connection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WritableStream(table, options, connection) {
  this._table = table;
  this._options = options;
  this._cache = [];
  this._pendingCallback = null;
  this._inserting = false;
  this._delayed = false;
  this._connection = connection;
  this._highWaterMark = options.highWaterMark || 100;

  this._insertOptions = {};
  this._insertOptions.durability = options.durability || &#x27;hard&#x27;;
  this._insertOptions.conflict = options.conflict || &#x27;error&#x27;;

  // Internal option to run some tests
  if (options.debug === true) {
    this._sequence = [];
  }

  Writable.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
  this._i = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.writable_stream.super_" id="apidoc.element.rethinkdbdash.writable_stream.super_">
        function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!(realHasInstance.call(Writable, this)) &#x26;&#x26;
      !(this instanceof Stream.Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === &#x27;function&#x27;)
      this._write = options.write;

    if (typeof options.writev === &#x27;function&#x27;)
      this._writev = options.writev;
  }

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rethinkdbdash.writable_stream.prototype" id="apidoc.module.rethinkdbdash.writable_stream.prototype">module rethinkdbdash.writable_stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rethinkdbdash.writable_stream.prototype._insert" id="apidoc.element.rethinkdbdash.writable_stream.prototype._insert">
        function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.prototype.</span>_insert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_insert = function () {
  var self = this;
  self._inserting = true;

  var cache = self._cache;
  self._cache = [];

  if (Array.isArray(self._sequence)) {
    self._sequence.push(cache.length);
  }

  self._table.insert(cache, self._insertOptions).run(self._connection).then(function(result) {
    self._inserting = false;
    if (result.errors &#x3e; 0) {
      self._inserting = false;
      self.emit(&#x27;error&#x27;, new Error(&#x27;Failed to insert some documents:&#x27;+JSON.stringify(result, null, 2)));
    }
    if (typeof self._pendingCallback === &#x27;function&#x27;) {
      var pendingCallback = self._pendingCallback;
      self._pendingCallback = null;
      pendingCallback();
    }
    return null;
  }).error(function(error) {
    self._inserting = false;
    self.emit(&#x27;error&#x27;, error);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  done();
}
else {
  if (this._inserting === false) {
    if (this._delayed === true) {
      // We have to flush
      this._delayed = false;
      this.<span class="apidocCodeKeywordSpan">_insert</span>();
      // Fill the buffer while we are inserting data
      done();
    }
    else {
      var self = this;
      this._delayed = true;
      setImmediate(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.writable_stream.prototype._next" id="apidoc.element.rethinkdbdash.writable_stream.prototype._next">
        function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.prototype.</span>_next
        <span class="apidocSignatureSpan">(value, encoding, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_next = function (value, encoding, done) {
  var self = this;
  if ((this._writableState.lastBufferedRequest != null) &#x26;&#x26; (this._writableState.lastBufferedRequest.chunk !== value)) {
    // There&#x27;s more data to buffer
    if (this._cache.length &#x3c; this._highWaterMark) {
      this._delayed = false;
      // Call done now, and more data will be put in the cache
      done();
    }
    else {
      if (this._inserting === false) {
        if (this._delayed === true) {
          this._delayed = false;
          // We have to flush
          this._insert();
          // Fill the buffer while we are inserting data
          done();
        }
        else {
          var self = this;
          this._delayed = true;
          setImmediate(function() {
            self._next(value, encoding, done);
          })
        }

      }
      else {
        this._delayed = false;
        // to call when we are dong inserting to keep buffering
        this._pendingCallback = done;
      }
    }
  }
  else { // We just pushed the last element in the internal buffer
    if (this._inserting === false) {
      if (this._delayed === true) {
        this._delayed = false;
        // to call when we are dong inserting to maybe flag the end
        // We cannot call done here as we may be inserting the last batch
        this._pendingCallback = done;
        this._insert();
      }
      else {
        var self = this;
        this._delayed = true;
        setImmediate(function() {
          self._next(value, encoding, done);
        })
      }
    }
    else {
      this._delayed = false;
      // We cannot call done here as we may be inserting the last batch
      //this._pendingCallback = done;
      this._pendingCallback = function() {
        self._next(value, encoding, done);
      };
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (typeof onFinish === &#x27;function&#x27;) {
    onFinish();
  }
}
else {
  if (self._closed === false) {
    if (self._stackSize &#x3c;= MAX_CALL_STACK) {
      self.<span class="apidocCodeKeywordSpan">_next</span>().then(resolve).error(function(error) {
        if ((error.message !== &#x27;You cannot retrieve data from a cursor that is closed.&#x27;) &#x26;&#x26;
            (error.message.match(/You cannot call `next` on a closed/) === null)) {
          reject(error);
        }
      });
    }
    else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rethinkdbdash.writable_stream.prototype._write" id="apidoc.element.rethinkdbdash.writable_stream.prototype._write">
        function <span class="apidocSignatureSpan">rethinkdbdash.writable_stream.prototype.</span>_write
        <span class="apidocSignatureSpan">(value, encoding, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (value, encoding, done) {
  this._i++;
  this._cache.push(value);
  this._next(value, encoding, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
